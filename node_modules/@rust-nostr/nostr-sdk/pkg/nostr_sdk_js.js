let imports = {};
imports['__wbindgen_placeholder__'] = module.exports;
let wasm;

const heap = new Array(128).fill(undefined);

heap.push(undefined, null, true, false);

let heap_next = heap.length;

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

function getObject(idx) { return heap[idx]; }

function dropObject(idx) {
    if (idx < 132) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

let WASM_VECTOR_LEN = 0;

let cachedUint8Memory0 = null;

function getUint8Memory0() {
    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
}

let cachedTextEncoder = new TextEncoder('utf-8');

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length, 1) >>> 0;
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len, 1) >>> 0;

    const mem = getUint8Memory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

let cachedInt32Memory0 = null;

function getInt32Memory0() {
    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
}

let cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

function debugString(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' && name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString(val[0]);
        }
        for(let i = 1; i < length; i++) {
            debug += ', ' + debugString(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}

const CLOSURE_DTORS = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(state => {
    wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b)
});

function makeMutClosure(arg0, arg1, dtor, f) {
    const state = { a: arg0, b: arg1, cnt: 1, dtor };
    const real = (...args) => {
        // First up with a closure we increment the internal reference
        // count. This ensures that the Rust closure environment won't
        // be deallocated while we're invoking it.
        state.cnt++;
        const a = state.a;
        state.a = 0;
        try {
            return f(a, state.b, ...args);
        } finally {
            if (--state.cnt === 0) {
                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);
                CLOSURE_DTORS.unregister(state);
            } else {
                state.a = a;
            }
        }
    };
    real.original = state;
    CLOSURE_DTORS.register(real, state, state);
    return real;
}
function __wbg_adapter_32(arg0, arg1, arg2) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.__wbindgen_export_3(retptr, arg0, arg1, addHeapObject(arg2));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        if (r1) {
            throw takeObject(r0);
        }
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

function __wbg_adapter_35(arg0, arg1, arg2) {
    wasm.__wbindgen_export_4(arg0, arg1, addHeapObject(arg2));
}

function __wbg_adapter_38(arg0, arg1, arg2) {
    wasm.__wbindgen_export_5(arg0, arg1, addHeapObject(arg2));
}

function makeClosure(arg0, arg1, dtor, f) {
    const state = { a: arg0, b: arg1, cnt: 1, dtor };
    const real = (...args) => {
        // First up with a closure we increment the internal reference
        // count. This ensures that the Rust closure environment won't
        // be deallocated while we're invoking it.
        state.cnt++;
        try {
            return f(state.a, state.b, ...args);
        } finally {
            if (--state.cnt === 0) {
                wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b);
                state.a = 0;
                CLOSURE_DTORS.unregister(state);
            }
        }
    };
    real.original = state;
    CLOSURE_DTORS.register(real, state, state);
    return real;
}
function __wbg_adapter_41(arg0, arg1) {
    wasm.__wbindgen_export_6(arg0, arg1);
}

function __wbg_adapter_44(arg0, arg1, arg2) {
    wasm.__wbindgen_export_7(arg0, arg1, addHeapObject(arg2));
}

function __wbg_adapter_47(arg0, arg1) {
    wasm.__wbindgen_export_8(arg0, arg1);
}

function __wbg_adapter_50(arg0, arg1, arg2) {
    wasm.__wbindgen_export_9(arg0, arg1, addHeapObject(arg2));
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
}

let cachedUint32Memory0 = null;

function getUint32Memory0() {
    if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {
        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);
    }
    return cachedUint32Memory0;
}

function passArrayJsValueToWasm0(array, malloc) {
    const ptr = malloc(array.length * 4, 4) >>> 0;
    const mem = getUint32Memory0();
    for (let i = 0; i < array.length; i++) {
        mem[ptr / 4 + i] = addHeapObject(array[i]);
    }
    WASM_VECTOR_LEN = array.length;
    return ptr;
}
/**
* @param {LogLevel} level
*/
module.exports.initLogger = function(level) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(level, LogLevel);
        var ptr0 = level.__destroy_into_raw();
        wasm.initLogger(retptr, ptr0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        if (r1) {
            throw takeObject(r0);
        }
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
};

function handleError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        wasm.__wbindgen_export_11(addHeapObject(e));
    }
}

function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1, 1) >>> 0;
    getUint8Memory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}

function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}

function getArrayJsValueFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    const mem = getUint32Memory0();
    const slice = mem.subarray(ptr / 4, ptr / 4 + len);
    const result = [];
    for (let i = 0; i < slice.length; i++) {
        result.push(takeObject(slice[i]));
    }
    return result;
}
/**
* Encrypt (NIP04)
* @param {SecretKey} sk
* @param {PublicKey} pk
* @param {string} text
* @returns {string}
*/
module.exports.nip04Encrypt = function(sk, pk, text) {
    let deferred3_0;
    let deferred3_1;
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(sk, SecretKey);
        _assertClass(pk, PublicKey);
        const ptr0 = passStringToWasm0(text, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.nip04Encrypt(retptr, sk.__wbg_ptr, pk.__wbg_ptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
            ptr2 = 0; len2 = 0;
            throw takeObject(r2);
        }
        deferred3_0 = ptr2;
        deferred3_1 = len2;
        return getStringFromWasm0(ptr2, len2);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_10(deferred3_0, deferred3_1, 1);
    }
};

/**
* Decrypt (NIP04)
* @param {SecretKey} sk
* @param {PublicKey} pk
* @param {string} encrypted_content
* @returns {string}
*/
module.exports.nip04Decrypt = function(sk, pk, encrypted_content) {
    let deferred3_0;
    let deferred3_1;
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(sk, SecretKey);
        _assertClass(pk, PublicKey);
        const ptr0 = passStringToWasm0(encrypted_content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.nip04Decrypt(retptr, sk.__wbg_ptr, pk.__wbg_ptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
            ptr2 = 0; len2 = 0;
            throw takeObject(r2);
        }
        deferred3_0 = ptr2;
        deferred3_1 = len2;
        return getStringFromWasm0(ptr2, len2);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_10(deferred3_0, deferred3_1, 1);
    }
};

/**
* Verify NIP05
* @param {PublicKey} public_key
* @param {string} nip05
* @returns {Promise<void>}
*/
module.exports.verifyNip05 = function(public_key, nip05) {
    _assertClass(public_key, PublicKey);
    var ptr0 = public_key.__destroy_into_raw();
    const ptr1 = passStringToWasm0(nip05, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    const ret = wasm.verifyNip05(ptr0, ptr1, len1);
    return takeObject(ret);
};

let cachedUint16Memory0 = null;

function getUint16Memory0() {
    if (cachedUint16Memory0 === null || cachedUint16Memory0.byteLength === 0) {
        cachedUint16Memory0 = new Uint16Array(wasm.memory.buffer);
    }
    return cachedUint16Memory0;
}

function getArrayU16FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint16Memory0().subarray(ptr / 2, ptr / 2 + len);
}
/**
* Create a NIP-26 delegation tag (including the signature).
* See also validate_delegation_tag().
* @param {Keys} delegator_keys
* @param {PublicKey} delegatee_pubkey
* @param {string} conditions
* @returns {string}
*/
module.exports.createDelegationTag = function(delegator_keys, delegatee_pubkey, conditions) {
    let deferred3_0;
    let deferred3_1;
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(delegator_keys, Keys);
        _assertClass(delegatee_pubkey, PublicKey);
        const ptr0 = passStringToWasm0(conditions, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.createDelegationTag(retptr, delegator_keys.__wbg_ptr, delegatee_pubkey.__wbg_ptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
            ptr2 = 0; len2 = 0;
            throw takeObject(r2);
        }
        deferred3_0 = ptr2;
        deferred3_1 = len2;
        return getStringFromWasm0(ptr2, len2);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_10(deferred3_0, deferred3_1, 1);
    }
};

/**
* Validate a NIP-26 delegation tag, check signature and conditions.
* @param {string} delegation_tag
* @param {PublicKey} delegatee_pubkey
* @param {number} event_kind
* @param {Timestamp} created_at
* @returns {boolean}
*/
module.exports.validateDelegationTag = function(delegation_tag, delegatee_pubkey, event_kind, created_at) {
    const ptr0 = passStringToWasm0(delegation_tag, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len0 = WASM_VECTOR_LEN;
    _assertClass(delegatee_pubkey, PublicKey);
    _assertClass(created_at, Timestamp);
    const ret = wasm.validateDelegationTag(ptr0, len0, delegatee_pubkey.__wbg_ptr, event_kind, created_at.__wbg_ptr);
    return ret !== 0;
};

/**
* Sign delegation (NIP26)
* @param {Keys} keys
* @param {PublicKey} delegatee_pk
* @param {string} conditions
* @returns {string}
*/
module.exports.signDelegation = function(keys, delegatee_pk, conditions) {
    let deferred3_0;
    let deferred3_1;
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(keys, Keys);
        _assertClass(delegatee_pk, PublicKey);
        const ptr0 = passStringToWasm0(conditions, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.signDelegation(retptr, keys.__wbg_ptr, delegatee_pk.__wbg_ptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
            ptr2 = 0; len2 = 0;
            throw takeObject(r2);
        }
        deferred3_0 = ptr2;
        deferred3_1 = len2;
        return getStringFromWasm0(ptr2, len2);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_10(deferred3_0, deferred3_1, 1);
    }
};

/**
* Verify delegation signature (NIP26)
* @param {PublicKey} delegator_public_key
* @param {PublicKey} delegatee_public_key
* @param {string} conditions
* @param {string} signature
* @returns {boolean}
*/
module.exports.verifyDelegationSignature = function(delegator_public_key, delegatee_public_key, conditions, signature) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(delegator_public_key, PublicKey);
        _assertClass(delegatee_public_key, PublicKey);
        const ptr0 = passStringToWasm0(conditions, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(signature, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        wasm.verifyDelegationSignature(retptr, delegator_public_key.__wbg_ptr, delegatee_public_key.__wbg_ptr, ptr0, len0, ptr1, len1);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 !== 0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
};

/**
* Encrypt (NIP44)
* @param {SecretKey} sk
* @param {PublicKey} pk
* @param {string} content
* @param {NIP44Version} version
* @returns {string}
*/
module.exports.nip44Encrypt = function(sk, pk, content, version) {
    let deferred3_0;
    let deferred3_1;
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(sk, SecretKey);
        _assertClass(pk, PublicKey);
        const ptr0 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.nip44Encrypt(retptr, sk.__wbg_ptr, pk.__wbg_ptr, ptr0, len0, version);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
            ptr2 = 0; len2 = 0;
            throw takeObject(r2);
        }
        deferred3_0 = ptr2;
        deferred3_1 = len2;
        return getStringFromWasm0(ptr2, len2);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_10(deferred3_0, deferred3_1, 1);
    }
};

/**
* Decrypt (NIP44)
* @param {SecretKey} sk
* @param {PublicKey} pk
* @param {string} payload
* @returns {string}
*/
module.exports.nip44Decrypt = function(sk, pk, payload) {
    let deferred3_0;
    let deferred3_1;
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(sk, SecretKey);
        _assertClass(pk, PublicKey);
        const ptr0 = passStringToWasm0(payload, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.nip44Decrypt(retptr, sk.__wbg_ptr, pk.__wbg_ptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
            ptr2 = 0; len2 = 0;
            throw takeObject(r2);
        }
        deferred3_0 = ptr2;
        deferred3_1 = len2;
        return getStringFromWasm0(ptr2, len2);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_10(deferred3_0, deferred3_1, 1);
    }
};

let cachedBigInt64Memory0 = null;

function getBigInt64Memory0() {
    if (cachedBigInt64Memory0 === null || cachedBigInt64Memory0.byteLength === 0) {
        cachedBigInt64Memory0 = new BigInt64Array(wasm.memory.buffer);
    }
    return cachedBigInt64Memory0;
}

let cachedFloat64Memory0 = null;

function getFloat64Memory0() {
    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {
        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);
    }
    return cachedFloat64Memory0;
}
/**
* @param {Event} event
* @returns {(RelayListItem)[]}
*/
module.exports.extractRelayList = function(event) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(event, Event);
        wasm.extractRelayList(retptr, event.__wbg_ptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_10(r0, r1 * 4, 4);
        return v1;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
};

function passArrayF64ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 8, 8) >>> 0;
    getFloat64Memory0().set(arg, ptr / 8);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
/**
* Run some stuff when the Wasm module is instantiated.
*
* Right now, it does the following:
*
* * Redirect Rust panics to JavaScript console.
*/
module.exports.start = function() {
    wasm.start();
};

function __wbg_adapter_986(arg0, arg1, arg2, arg3) {
    wasm.__wbindgen_export_12(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));
}

/**
* Encrypted Secret Key version (NIP49)
*/
module.exports.EncryptedSecretKeyVersion = Object.freeze({ V2:0,"0":"V2", });
/**
*/
module.exports.DataVendingMachineStatus = Object.freeze({ PaymentRequired:0,"0":"PaymentRequired",Processing:1,"1":"Processing",Error:2,"2":"Error",Success:3,"3":"Success",Partial:4,"4":"Partial", });
/**
* NIP47 Response Error codes
*/
module.exports.Nip47ErrorCode = Object.freeze({
/**
*  The client is sending commands too fast.
*/
RateLimited:0,"0":"RateLimited",
/**
* The command is not known of is intentionally not implemented
*/
NotImplemented:1,"1":"NotImplemented",
/**
* The wallet does not have enough funds to cover a fee reserve or the payment amount
*/
InsufficientBalance:2,"2":"InsufficientBalance",
/**
* The payment failed. This may be due to a timeout, exhausting all routes, insufficient capacity or similar.
*/
PaymentFailed:3,"3":"PaymentFailed",
/**
* The invoice could not be found by the given parameters.
*/
NotFound:4,"4":"NotFound",
/**
* The wallet has exceeded its spending quota
*/
QuotaExceeded:5,"5":"QuotaExceeded",
/**
* This public key is not allowed to do this operation
*/
Restricted:6,"6":"Restricted",
/**
* This public key has no wallet connected
*/
Unauthorized:7,"7":"Unauthorized",
/**
* An internal error
*/
Internal:8,"8":"Internal",
/**
* Other error
*/
Other:9,"9":"Other", });
/**
* Key security
*/
module.exports.KeySecurity = Object.freeze({
/**
* The key has been known to have been handled insecurely (stored unencrypted, cut and paste unencrypted, etc)
*/
Weak:0,"0":"Weak",
/**
* The key has NOT been known to have been handled insecurely (stored encrypted, cut and paste encrypted, etc)
*/
Medium:1,"1":"Medium",
/**
* The client does not track this data
*/
Unknown:2,"2":"Unknown", });
/**
* Transaction Type
*/
module.exports.TransactionType = Object.freeze({
/**
* Incoming payments
*/
Incoming:0,"0":"Incoming",
/**
* Outgoing payments
*/
Outgoing:1,"1":"Outgoing", });
/**
*/
module.exports.ZapType = Object.freeze({
/**
* Public
*/
Public:0,"0":"Public",
/**
* Private
*/
Private:1,"1":"Private",
/**
* Anonymous
*/
Anonymous:2,"2":"Anonymous", });
/**
*/
module.exports.HttpMethod = Object.freeze({ GET:0,"0":"GET",POST:1,"1":"POST",PUT:2,"2":"PUT",PATCH:3,"3":"PATCH", });
/**
*/
module.exports.NegentropyDirection = Object.freeze({ Up:0,"0":"Up",Down:1,"1":"Down",Both:2,"2":"Both", });
/**
*/
module.exports.NIP44Version = Object.freeze({
/**
* V1 - Deprecated
*/
Deprecated:1,"1":"Deprecated",V2:2,"2":"V2", });
/**
*/
module.exports.RelayMetadata = Object.freeze({ Read:0,"0":"Read",Write:1,"1":"Write", });
/**
*/
module.exports.RelayStatus = Object.freeze({
/**
* Relay initialized
*/
Initialized:0,"0":"Initialized",
/**
* Pending
*/
Pending:1,"1":"Pending",
/**
* Connecting
*/
Connecting:2,"2":"Connecting",
/**
* Relay connected
*/
Connected:3,"3":"Connected",
/**
* Relay disconnected, will retry to connect again
*/
Disconnected:4,"4":"Disconnected",
/**
* Stop
*/
Stopped:5,"5":"Stopped",
/**
* Relay completely disconnected
*/
Terminated:6,"6":"Terminated", });
/**
*/
module.exports.Alphabet = Object.freeze({ A:0,"0":"A",B:1,"1":"B",C:2,"2":"C",D:3,"3":"D",E:4,"4":"E",F:5,"5":"F",G:6,"6":"G",H:7,"7":"H",I:8,"8":"I",J:9,"9":"J",K:10,"10":"K",L:11,"11":"L",M:12,"12":"M",N:13,"13":"N",O:14,"14":"O",P:15,"15":"P",Q:16,"16":"Q",R:17,"17":"R",S:18,"18":"S",T:19,"19":"T",U:20,"20":"U",V:21,"21":"V",W:22,"22":"W",X:23,"23":"X",Y:24,"24":"Y",Z:25,"25":"Z", });

const AbortHandleFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_aborthandle_free(ptr >>> 0));
/**
*/
class AbortHandle {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(AbortHandle.prototype);
        obj.__wbg_ptr = ptr;
        AbortHandleFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AbortHandleFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_aborthandle_free(ptr);
    }
    /**
    * Abort thread
    */
    abort() {
        wasm.aborthandle_abort(this.__wbg_ptr);
    }
    /**
    * Check if thread is aborted
    * @returns {boolean}
    */
    is_aborted() {
        const ret = wasm.aborthandle_is_aborted(this.__wbg_ptr);
        return ret !== 0;
    }
}
module.exports.AbortHandle = AbortHandle;

const Aes256GcmFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_aes256gcm_free(ptr >>> 0));
/**
*/
class Aes256Gcm {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Aes256Gcm.prototype);
        obj.__wbg_ptr = ptr;
        Aes256GcmFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Aes256GcmFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_aes256gcm_free(ptr);
    }
    /**
    * @returns {string}
    */
    get key() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_key(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} arg0
    */
    set key(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_key(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {string}
    */
    get iv() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_iv(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} arg0
    */
    set iv(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_iv(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @param {string} key
    * @param {string} iv
    */
    constructor(key, iv) {
        const ptr0 = passStringToWasm0(key, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(iv, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.aes256gcm_new(ptr0, len0, ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
}
module.exports.Aes256Gcm = Aes256Gcm;

const ArticlesCurationFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_articlescuration_free(ptr >>> 0));
/**
* Groups of articles picked by users as interesting and/or belonging to the same category
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
class ArticlesCuration {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ArticlesCurationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_articlescuration_free(ptr);
    }
    /**
    * @returns {(Coordinate)[]}
    */
    get coordinate() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_articlescuration_coordinate(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(Coordinate)[]} arg0
    */
    set coordinate(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_articlescuration_coordinate(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(EventId)[]}
    */
    get event_ids() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_articlescuration_event_ids(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(EventId)[]} arg0
    */
    set event_ids(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_articlescuration_event_ids(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.ArticlesCuration = ArticlesCuration;

const AtomicRelayServiceFlagsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_atomicrelayserviceflags_free(ptr >>> 0));
/**
*/
class AtomicRelayServiceFlags {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(AtomicRelayServiceFlags.prototype);
        obj.__wbg_ptr = ptr;
        AtomicRelayServiceFlagsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AtomicRelayServiceFlagsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_atomicrelayserviceflags_free(ptr);
    }
    /**
    * @param {RelayServiceFlags} flags
    * @returns {AtomicRelayServiceFlags}
    */
    static new(flags) {
        _assertClass(flags, RelayServiceFlags);
        const ret = wasm.atomicrelayserviceflags_new(flags.__wbg_ptr);
        return AtomicRelayServiceFlags.__wrap(ret);
    }
    /**
    * @param {RelayServiceFlags} flags
    */
    add(flags) {
        _assertClass(flags, RelayServiceFlags);
        wasm.atomicrelayserviceflags_add(this.__wbg_ptr, flags.__wbg_ptr);
    }
    /**
    * @param {RelayServiceFlags} flags
    */
    remove(flags) {
        _assertClass(flags, RelayServiceFlags);
        wasm.atomicrelayserviceflags_remove(this.__wbg_ptr, flags.__wbg_ptr);
    }
    /**
    * Check whether `RelayServiceFlags` are included in this one.
    * @param {RelayServiceFlags} flags
    * @returns {boolean}
    */
    has(flags) {
        _assertClass(flags, RelayServiceFlags);
        const ret = wasm.atomicrelayserviceflags_has(this.__wbg_ptr, flags.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Check if `READ` service is enabled
    * @returns {boolean}
    */
    has_read() {
        const ret = wasm.atomicrelayserviceflags_has_read(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Check if `WRITE` service is enabled
    * @returns {boolean}
    */
    has_write() {
        const ret = wasm.atomicrelayserviceflags_has_write(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * Check if `PING` service is enabled
    * @returns {boolean}
    */
    has_ping() {
        const ret = wasm.atomicrelayserviceflags_has_ping(this.__wbg_ptr);
        return ret !== 0;
    }
}
module.exports.AtomicRelayServiceFlags = AtomicRelayServiceFlags;

const BookmarksFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_bookmarks_free(ptr >>> 0));
/**
* Uncategorized, "global" list of things a user wants to save
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
class Bookmarks {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BookmarksFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_bookmarks_free(ptr);
    }
    /**
    * @returns {(EventId)[]}
    */
    get event_ids() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_bookmarks_event_ids(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(EventId)[]} arg0
    */
    set event_ids(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_bookmarks_event_ids(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(Coordinate)[]}
    */
    get coordinate() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_bookmarks_coordinate(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(Coordinate)[]} arg0
    */
    set coordinate(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_bookmarks_coordinate(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(string)[]}
    */
    get hashtags() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_bookmarks_hashtags(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(string)[]} arg0
    */
    set hashtags(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_bookmarks_hashtags(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(string)[]}
    */
    get urls() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_bookmarks_urls(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(string)[]} arg0
    */
    set urls(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_bookmarks_urls(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.Bookmarks = Bookmarks;

const ClientFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_client_free(ptr >>> 0));
/**
*/
class Client {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Client.prototype);
        obj.__wbg_ptr = ptr;
        ClientFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ClientFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_client_free(ptr);
    }
    /**
    * @param {NostrSigner | undefined} [signer]
    */
    constructor(signer) {
        let ptr0 = 0;
        if (!isLikeNone(signer)) {
            _assertClass(signer, NostrSigner);
            ptr0 = signer.__destroy_into_raw();
        }
        const ret = wasm.client_new(ptr0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Create a new Client with Options
    * @param {NostrSigner | undefined} signer
    * @param {Options} opts
    * @returns {Client}
    */
    static withOpts(signer, opts) {
        let ptr0 = 0;
        if (!isLikeNone(signer)) {
            _assertClass(signer, NostrSigner);
            ptr0 = signer.__destroy_into_raw();
        }
        _assertClass(opts, Options);
        const ret = wasm.client_withOpts(ptr0, opts.__wbg_ptr);
        return Client.__wrap(ret);
    }
    /**
    * Update default difficulty for new `Event`
    * @param {number} difficulty
    */
    updateDifficulty(difficulty) {
        wasm.client_updateDifficulty(this.__wbg_ptr, difficulty);
    }
    /**
    * Get current nostr signer
    *
    * Rise error if it not set.
    * @returns {Promise<NostrSigner>}
    */
    signer() {
        const ret = wasm.client_signer(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @returns {NostrDatabase}
    */
    get database() {
        const ret = wasm.client_database(this.__wbg_ptr);
        return NostrDatabase.__wrap(ret);
    }
    /**
    * Completely shutdown `Client`
    * @returns {Promise<void>}
    */
    shutdown() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.client_shutdown(ptr);
        return takeObject(ret);
    }
    /**
    * Get relays
    * @returns {Promise<JsRelay[]>}
    */
    relays() {
        const ret = wasm.client_relays(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Get a previously added `Relay`
    * @param {string} url
    * @returns {Promise<Relay>}
    */
    relay(url) {
        const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.client_relay(this.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Add new relay
    *
    * Return `false` if the relay already exists.
    *
    * This method use perviously set or default `Options` to configure the `Relay` (ex. set proxy, set min POW, set relay limits, ...).
    *
    * Connection is **NOT** automatically started with relay, remember to call `connect` method!
    * @param {string} url
    * @returns {Promise<boolean>}
    */
    addRelay(url) {
        const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.client_addRelay(this.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Add multiple relays
    *
    * Connection is **NOT** automatically started with relays, remember to call `connect` method!
    * @param {(string)[]} urls
    * @returns {Promise<void>}
    */
    addRelays(urls) {
        const ptr0 = passArrayJsValueToWasm0(urls, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.client_addRelays(this.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Remove relay
    * @param {string} url
    * @returns {Promise<void>}
    */
    removeRelay(url) {
        const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.client_removeRelay(this.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Connect relay
    * @param {string} url
    * @returns {Promise<void>}
    */
    connectRelay(url) {
        const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.client_connectRelay(this.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Disconnect relay
    * @param {string} url
    * @returns {Promise<void>}
    */
    disconnectRelay(url) {
        const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.client_disconnectRelay(this.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Connect to all added relays
    * @returns {Promise<void>}
    */
    connect() {
        const ret = wasm.client_connect(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Disconnect from all relays
    * @returns {Promise<void>}
    */
    disconnect() {
        const ret = wasm.client_disconnect(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Subscribe to filters
    *
    * ### Auto-closing subscription
    *
    * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
    * @param {(Filter)[]} filters
    * @param {SubscribeAutoCloseOptions | undefined} [opts]
    * @returns {Promise<string>}
    */
    subscribe(filters, opts) {
        const ptr0 = passArrayJsValueToWasm0(filters, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        let ptr1 = 0;
        if (!isLikeNone(opts)) {
            _assertClass(opts, SubscribeAutoCloseOptions);
            ptr1 = opts.__destroy_into_raw();
        }
        const ret = wasm.client_subscribe(this.__wbg_ptr, ptr0, len0, ptr1);
        return takeObject(ret);
    }
    /**
    * Subscribe to filters with custom subscription ID
    *
    * ### Auto-closing subscription
    *
    * It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
    * @param {string} id
    * @param {(Filter)[]} filters
    * @param {SubscribeAutoCloseOptions | undefined} [opts]
    * @returns {Promise<void>}
    */
    subscribeWithId(id, filters, opts) {
        const ptr0 = passStringToWasm0(id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(filters, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        let ptr2 = 0;
        if (!isLikeNone(opts)) {
            _assertClass(opts, SubscribeAutoCloseOptions);
            ptr2 = opts.__destroy_into_raw();
        }
        const ret = wasm.client_subscribeWithId(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2);
        return takeObject(ret);
    }
    /**
    * Unsubscribe
    * @param {string} subscription_id
    * @returns {Promise<void>}
    */
    unsubscribe(subscription_id) {
        const ptr0 = passStringToWasm0(subscription_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.client_unsubscribe(this.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Unsubscribe
    * @returns {Promise<void>}
    */
    unsubscribeAll() {
        const ret = wasm.client_unsubscribeAll(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Get events of filters
    *
    * If timeout is not set, the default one from Options will be used.
    * @param {(Filter)[]} filters
    * @param {Duration | undefined} [timeout]
    * @returns {Promise<Event[]>}
    */
    getEventsOf(filters, timeout) {
        const ptr0 = passArrayJsValueToWasm0(filters, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        let ptr1 = 0;
        if (!isLikeNone(timeout)) {
            _assertClass(timeout, Duration);
            ptr1 = timeout.__destroy_into_raw();
        }
        const ret = wasm.client_getEventsOf(this.__wbg_ptr, ptr0, len0, ptr1);
        return takeObject(ret);
    }
    /**
    * Get events of filters from specific relays
    *
    * Get events both from **local database** and **relays**
    * @param {(string)[]} urls
    * @param {(Filter)[]} filters
    * @param {Duration | undefined} [timeout]
    * @returns {Promise<Event[]>}
    */
    getEventsFrom(urls, filters, timeout) {
        const ptr0 = passArrayJsValueToWasm0(urls, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(filters, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        let ptr2 = 0;
        if (!isLikeNone(timeout)) {
            _assertClass(timeout, Duration);
            ptr2 = timeout.__destroy_into_raw();
        }
        const ret = wasm.client_getEventsFrom(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2);
        return takeObject(ret);
    }
    /**
    * Send client message
    * @param {ClientMessage} msg
    * @returns {Promise<void>}
    */
    sendMsg(msg) {
        _assertClass(msg, ClientMessage);
        const ret = wasm.client_sendMsg(this.__wbg_ptr, msg.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Send client message to a specific relay
    * @param {(string)[]} urls
    * @param {ClientMessage} msg
    * @returns {Promise<void>}
    */
    sendMsgTo(urls, msg) {
        const ptr0 = passArrayJsValueToWasm0(urls, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(msg, ClientMessage);
        const ret = wasm.client_sendMsgTo(this.__wbg_ptr, ptr0, len0, msg.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Send event
    *
    * This method will wait for the `OK` message from the relay.
    * If you not want to wait for the `OK` message, use `sendMsg` method instead.
    * @param {Event} event
    * @returns {Promise<EventId>}
    */
    sendEvent(event) {
        _assertClass(event, Event);
        const ret = wasm.client_sendEvent(this.__wbg_ptr, event.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Send event to specific relay
    *
    * This method will wait for the `OK` message from the relay.
    * If you not want to wait for the `OK` message, use `sendMsgTo` method instead.
    * @param {(string)[]} urls
    * @param {Event} event
    * @returns {Promise<EventId>}
    */
    sendEventTo(urls, event) {
        const ptr0 = passArrayJsValueToWasm0(urls, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(event, Event);
        const ret = wasm.client_sendEventTo(this.__wbg_ptr, ptr0, len0, event.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Signs the `EventBuilder` into an `Event` using the `NostrSigner`
    * @param {EventBuilder} builder
    * @returns {Promise<Event>}
    */
    signEventBuilder(builder) {
        _assertClass(builder, EventBuilder);
        const ret = wasm.client_signEventBuilder(this.__wbg_ptr, builder.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Take an [`EventBuilder`], sign it by using the [`NostrSigner`] and broadcast to all relays.
    *
    * Rise an error if the [`NostrSigner`] is not set.
    * @param {EventBuilder} builder
    * @returns {Promise<EventId>}
    */
    sendEventBuilder(builder) {
        _assertClass(builder, EventBuilder);
        const ret = wasm.client_sendEventBuilder(this.__wbg_ptr, builder.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Take an [`EventBuilder`], sign it by using the [`NostrSigner`] and broadcast to specific relays.
    *
    * Rise an error if the [`NostrSigner`] is not set.
    * @param {(string)[]} urls
    * @param {EventBuilder} builder
    * @returns {Promise<EventId>}
    */
    sendEventBuilderTo(urls, builder) {
        const ptr0 = passArrayJsValueToWasm0(urls, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(builder, EventBuilder);
        const ret = wasm.client_sendEventBuilderTo(this.__wbg_ptr, ptr0, len0, builder.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Update metadata
    *
    * <https://github.com/nostr-protocol/nips/blob/master/01.md>
    * @param {Metadata} metadata
    * @returns {Promise<EventId>}
    */
    setMetadata(metadata) {
        _assertClass(metadata, Metadata);
        const ret = wasm.client_setMetadata(this.__wbg_ptr, metadata.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Publish text note
    *
    * <https://github.com/nostr-protocol/nips/blob/master/01.md>
    * @param {string} content
    * @param {(Tag)[]} tags
    * @returns {Promise<EventId>}
    */
    publishTextNote(content, tags) {
        const ptr0 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(tags, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.client_publishTextNote(this.__wbg_ptr, ptr0, len0, ptr1, len1);
        return takeObject(ret);
    }
    /**
    * Set contact list
    *
    * <https://github.com/nostr-protocol/nips/blob/master/02.md>
    * @param {(Contact)[]} list
    * @returns {Promise<EventId>}
    */
    setContactList(list) {
        const ptr0 = passArrayJsValueToWasm0(list, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.client_setContactList(this.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Send encrypted direct message
    *
    * <https://github.com/nostr-protocol/nips/blob/master/04.md>
    * @param {PublicKey} receiver
    * @param {string} msg
    * @param {EventId | undefined} [reply]
    * @returns {Promise<EventId>}
    */
    sendDirectMsg(receiver, msg, reply) {
        _assertClass(receiver, PublicKey);
        const ptr0 = passStringToWasm0(msg, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        let ptr1 = 0;
        if (!isLikeNone(reply)) {
            _assertClass(reply, EventId);
            ptr1 = reply.__destroy_into_raw();
        }
        const ret = wasm.client_sendDirectMsg(this.__wbg_ptr, receiver.__wbg_ptr, ptr0, len0, ptr1);
        return takeObject(ret);
    }
    /**
    * Repost
    * @param {Event} event
    * @param {string | undefined} [relay_url]
    * @returns {Promise<EventId>}
    */
    repost(event, relay_url) {
        _assertClass(event, Event);
        var ptr0 = isLikeNone(relay_url) ? 0 : passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.client_repost(this.__wbg_ptr, event.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Delete event
    *
    * <https://github.com/nostr-protocol/nips/blob/master/09.md>
    * @param {EventId} event_id
    * @returns {Promise<EventId>}
    */
    deleteEvent(event_id) {
        _assertClass(event_id, EventId);
        const ret = wasm.client_deleteEvent(this.__wbg_ptr, event_id.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Like event
    *
    * <https://github.com/nostr-protocol/nips/blob/master/25.md>
    * @param {Event} event
    * @returns {Promise<EventId>}
    */
    like(event) {
        _assertClass(event, Event);
        const ret = wasm.client_like(this.__wbg_ptr, event.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Disike event
    *
    * <https://github.com/nostr-protocol/nips/blob/master/25.md>
    * @param {Event} event
    * @returns {Promise<EventId>}
    */
    dislike(event) {
        _assertClass(event, Event);
        const ret = wasm.client_dislike(this.__wbg_ptr, event.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * React to an [`Event`]
    *
    * <https://github.com/nostr-protocol/nips/blob/master/25.md>
    * @param {Event} event
    * @param {string} reaction
    * @returns {Promise<EventId>}
    */
    reaction(event, reaction) {
        _assertClass(event, Event);
        const ptr0 = passStringToWasm0(reaction, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.client_reaction(this.__wbg_ptr, event.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Create new channel
    *
    * <https://github.com/nostr-protocol/nips/blob/master/28.md>
    * @param {Metadata} metadata
    * @returns {Promise<EventId>}
    */
    newChannel(metadata) {
        _assertClass(metadata, Metadata);
        const ret = wasm.client_newChannel(this.__wbg_ptr, metadata.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Update channel metadata
    *
    * <https://github.com/nostr-protocol/nips/blob/master/28.md>
    * @param {EventId} channel_id
    * @param {string | undefined} relay_url
    * @param {Metadata} metadata
    * @returns {Promise<EventId>}
    */
    setChannelMetadata(channel_id, relay_url, metadata) {
        _assertClass(channel_id, EventId);
        var ptr0 = isLikeNone(relay_url) ? 0 : passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        _assertClass(metadata, Metadata);
        const ret = wasm.client_setChannelMetadata(this.__wbg_ptr, channel_id.__wbg_ptr, ptr0, len0, metadata.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Send message to channel
    *
    * <https://github.com/nostr-protocol/nips/blob/master/28.md>
    * @param {EventId} channel_id
    * @param {string} relay_url
    * @param {string} msg
    * @returns {Promise<EventId>}
    */
    sendChannelMsg(channel_id, relay_url, msg) {
        _assertClass(channel_id, EventId);
        const ptr0 = passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(msg, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.client_sendChannelMsg(this.__wbg_ptr, channel_id.__wbg_ptr, ptr0, len0, ptr1, len1);
        return takeObject(ret);
    }
    /**
    * Hide channel message
    *
    * <https://github.com/nostr-protocol/nips/blob/master/28.md>
    * @param {EventId} message_id
    * @param {string | undefined} [reason]
    * @returns {Promise<EventId>}
    */
    hideChannelUser(message_id, reason) {
        _assertClass(message_id, EventId);
        var ptr0 = isLikeNone(reason) ? 0 : passStringToWasm0(reason, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.client_hideChannelUser(this.__wbg_ptr, message_id.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Mute channel user
    *
    * <https://github.com/nostr-protocol/nips/blob/master/28.md>
    * @param {PublicKey} pubkey
    * @param {string | undefined} [reason]
    * @returns {Promise<EventId>}
    */
    muteChannelUser(pubkey, reason) {
        _assertClass(pubkey, PublicKey);
        var ptr0 = isLikeNone(reason) ? 0 : passStringToWasm0(reason, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.client_muteChannelUser(this.__wbg_ptr, pubkey.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Send a Zap!
    *
    * This method automatically create a split zap to support Rust Nostr development.
    * @param {ZapEntity} to
    * @param {number} satoshi
    * @param {ZapDetails | undefined} [details]
    * @returns {Promise<void>}
    */
    zap(to, satoshi, details) {
        _assertClass(to, ZapEntity);
        let ptr0 = 0;
        if (!isLikeNone(details)) {
            _assertClass(details, ZapDetails);
            ptr0 = details.__destroy_into_raw();
        }
        const ret = wasm.client_zap(this.__wbg_ptr, to.__wbg_ptr, satoshi, ptr0);
        return takeObject(ret);
    }
    /**
    * Gift Wrap
    *
    * <https://github.com/nostr-protocol/nips/blob/master/59.md>
    * @param {PublicKey} receiver
    * @param {EventBuilder} rumor
    * @param {Timestamp | undefined} [expiration]
    * @returns {Promise<void>}
    */
    giftWrap(receiver, rumor, expiration) {
        _assertClass(receiver, PublicKey);
        _assertClass(rumor, EventBuilder);
        let ptr0 = 0;
        if (!isLikeNone(expiration)) {
            _assertClass(expiration, Timestamp);
            ptr0 = expiration.__destroy_into_raw();
        }
        const ret = wasm.client_giftWrap(this.__wbg_ptr, receiver.__wbg_ptr, rumor.__wbg_ptr, ptr0);
        return takeObject(ret);
    }
    /**
    * Send GiftWrapper Sealed Direct message
    * @param {PublicKey} receiver
    * @param {string} message
    * @param {Timestamp | undefined} [expiration]
    * @returns {Promise<void>}
    */
    sendSealedMsg(receiver, message, expiration) {
        _assertClass(receiver, PublicKey);
        const ptr0 = passStringToWasm0(message, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        let ptr1 = 0;
        if (!isLikeNone(expiration)) {
            _assertClass(expiration, Timestamp);
            ptr1 = expiration.__destroy_into_raw();
        }
        const ret = wasm.client_sendSealedMsg(this.__wbg_ptr, receiver.__wbg_ptr, ptr0, len0, ptr1);
        return takeObject(ret);
    }
    /**
    * Negentropy reconciliation
    *
    * <https://github.com/hoytech/negentropy>
    * @param {Filter} filter
    * @param {NegentropyOptions} opts
    * @returns {Promise<void>}
    */
    reconcile(filter, opts) {
        _assertClass(filter, Filter);
        _assertClass(opts, NegentropyOptions);
        const ret = wasm.client_reconcile(this.__wbg_ptr, filter.__wbg_ptr, opts.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Handle notifications
    *
    * **This method spawn a thread**, so ensure to keep up the app after calling this (if needed).
    *
    * To exit from the handle notifications loop, return `true` or call `abortable.abort();`.
    *
    * # Example
    * ```javascript
    * // Subscribe to filters
    * const filter = new Filter().author(keys.publicKey);
    * await client.subscribe([filter]);
    *
    * const handle = {
    *    // Handle event
    *    handleEvent: async (relayUrl, subscriptionId, event) => {
    *        console.log("Received new event from", relayUrl);
    *        if (event.kind == 4) {
    *            try {
    *                let content = nip04Decrypt(keys.secretKey, event.author, event.content);
    *                console.log("Message:", content);
    *                await client.sendDirectMsg(event.author, "Echo: " + content);
    *
    *                if (content == "stop") {
    *                    return true;
    *                }
    *            } catch (error) {
    *                console.log("Impossible to decrypt DM:", error);
    *            }
    *         }
    *     },
    *     // Handle relay message
    *     handleMsg: async (relayUrl, message) => {
    *         console.log("Received message from", relayUrl, message.asJson());
    *     }
    *  };
    *
    * let abortable = client.handleNotifications(handle);
    * // Optionally, call `abortable.abort();` when you need to stop handle notifications thread
    * ```
    * @param {HandleNotification} callback
    * @returns {AbortHandle}
    */
    handleNotifications(callback) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.client_handleNotifications(retptr, this.__wbg_ptr, addHeapObject(callback));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return AbortHandle.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Client = Client;

const ClientBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_clientbuilder_free(ptr >>> 0));
/**
*/
class ClientBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ClientBuilder.prototype);
        obj.__wbg_ptr = ptr;
        ClientBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ClientBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_clientbuilder_free(ptr);
    }
    /**
    * New client builder
    */
    constructor() {
        const ret = wasm.clientbuilder_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @param {NostrSigner} signer
    * @returns {ClientBuilder}
    */
    signer(signer) {
        const ptr = this.__destroy_into_raw();
        _assertClass(signer, NostrSigner);
        const ret = wasm.clientbuilder_signer(ptr, signer.__wbg_ptr);
        return ClientBuilder.__wrap(ret);
    }
    /**
    * @param {NostrZapper} zapper
    * @returns {ClientBuilder}
    */
    zapper(zapper) {
        const ptr = this.__destroy_into_raw();
        _assertClass(zapper, NostrZapper);
        const ret = wasm.clientbuilder_zapper(ptr, zapper.__wbg_ptr);
        return ClientBuilder.__wrap(ret);
    }
    /**
    * @param {NostrDatabase} database
    * @returns {ClientBuilder}
    */
    database(database) {
        const ptr = this.__destroy_into_raw();
        _assertClass(database, NostrDatabase);
        const ret = wasm.clientbuilder_database(ptr, database.__wbg_ptr);
        return ClientBuilder.__wrap(ret);
    }
    /**
    * @param {Options} opts
    * @returns {ClientBuilder}
    */
    opts(opts) {
        const ptr = this.__destroy_into_raw();
        _assertClass(opts, Options);
        const ret = wasm.clientbuilder_opts(ptr, opts.__wbg_ptr);
        return ClientBuilder.__wrap(ret);
    }
    /**
    * Build `Client`
    *
    * This method **consume** the `ClientBuilder`!
    * @returns {Client}
    */
    build() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.clientbuilder_build(ptr);
        return Client.__wrap(ret);
    }
}
module.exports.ClientBuilder = ClientBuilder;

const ClientMessageFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_clientmessage_free(ptr >>> 0));
/**
*/
class ClientMessage {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ClientMessage.prototype);
        obj.__wbg_ptr = ptr;
        ClientMessageFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ClientMessageFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_clientmessage_free(ptr);
    }
    /**
    * Create new `EVENT` message
    * @param {Event} event
    * @returns {ClientMessage}
    */
    static event(event) {
        _assertClass(event, Event);
        const ret = wasm.clientmessage_event(event.__wbg_ptr);
        return ClientMessage.__wrap(ret);
    }
    /**
    * Create new `REQ` message
    * @param {string} subscription_id
    * @param {(Filter)[]} filters
    * @returns {ClientMessage}
    */
    static req(subscription_id, filters) {
        const ptr0 = passStringToWasm0(subscription_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(filters, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.clientmessage_req(ptr0, len0, ptr1, len1);
        return ClientMessage.__wrap(ret);
    }
    /**
    * Create new `COUNT` message
    * @param {string} subscription_id
    * @param {(Filter)[]} filters
    * @returns {ClientMessage}
    */
    static count(subscription_id, filters) {
        const ptr0 = passStringToWasm0(subscription_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(filters, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.clientmessage_count(ptr0, len0, ptr1, len1);
        return ClientMessage.__wrap(ret);
    }
    /**
    * Create new `CLOSE` message
    * @param {string} subscription_id
    * @returns {ClientMessage}
    */
    static close(subscription_id) {
        const ptr0 = passStringToWasm0(subscription_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.clientmessage_close(ptr0, len0);
        return ClientMessage.__wrap(ret);
    }
    /**
    * Create new `AUTH` message
    * @param {Event} event
    * @returns {ClientMessage}
    */
    static auth(event) {
        _assertClass(event, Event);
        const ret = wasm.clientmessage_auth(event.__wbg_ptr);
        return ClientMessage.__wrap(ret);
    }
    /**
    * Deserialize `ClientMessage` from JSON string
    *
    * **This method NOT verify the event signature!**
    * @param {string} json
    * @returns {ClientMessage}
    */
    static fromJson(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.clientmessage_fromJson(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ClientMessage.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    asJson() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.clientmessage_asJson(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.ClientMessage = ClientMessage;

const ContactFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_contact_free(ptr >>> 0));
/**
*/
class Contact {

    static __unwrap(jsValue) {
        if (!(jsValue instanceof Contact)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ContactFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_contact_free(ptr);
    }
    /**
    * @param {PublicKey} public_key
    * @param {string | undefined} [relay_url]
    * @param {string | undefined} [alias]
    */
    constructor(public_key, relay_url, alias) {
        _assertClass(public_key, PublicKey);
        var ptr0 = isLikeNone(relay_url) ? 0 : passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(alias) ? 0 : passStringToWasm0(alias, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len1 = WASM_VECTOR_LEN;
        const ret = wasm.contact_new(public_key.__wbg_ptr, ptr0, len0, ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
}
module.exports.Contact = Contact;

const CoordinateFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_coordinate_free(ptr >>> 0));
/**
*/
class Coordinate {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Coordinate.prototype);
        obj.__wbg_ptr = ptr;
        CoordinateFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof Coordinate)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CoordinateFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_coordinate_free(ptr);
    }
    /**
    * @param {number} kind
    * @param {PublicKey} public_key
    * @param {string | undefined} [identifier]
    * @param {(string)[] | undefined} [relays]
    */
    constructor(kind, public_key, identifier, relays) {
        _assertClass(public_key, PublicKey);
        var ptr0 = isLikeNone(identifier) ? 0 : passStringToWasm0(identifier, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(relays) ? 0 : passArrayJsValueToWasm0(relays, wasm.__wbindgen_export_0);
        var len1 = WASM_VECTOR_LEN;
        const ret = wasm.coordinate_new(kind, public_key.__wbg_ptr, ptr0, len0, ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @returns {number}
    */
    get kind() {
        const ret = wasm.coordinate_kind(this.__wbg_ptr);
        return ret;
    }
    /**
    * @returns {PublicKey}
    */
    get publicKey() {
        const ret = wasm.coordinate_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {string}
    */
    get identifier() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.coordinate_identifier(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {(string)[]}
    */
    get relays() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.coordinate_relays(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Coordinate = Coordinate;

const DurationFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_duration_free(ptr >>> 0));
/**
*/
class Duration {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Duration.prototype);
        obj.__wbg_ptr = ptr;
        DurationFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        DurationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_duration_free(ptr);
    }
    /**
    * @param {number} secs
    * @returns {Duration}
    */
    static fromSecs(secs) {
        const ret = wasm.duration_fromSecs(secs);
        return Duration.__wrap(ret);
    }
    /**
    * @param {bigint} millis
    * @returns {Duration}
    */
    static fromMillis(millis) {
        const ret = wasm.duration_fromMillis(millis);
        return Duration.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    asSecs() {
        const ret = wasm.duration_asSecs(this.__wbg_ptr);
        return ret;
    }
    /**
    * @returns {number}
    */
    asMillis() {
        const ret = wasm.duration_asMillis(this.__wbg_ptr);
        return ret >>> 0;
    }
}
module.exports.Duration = Duration;

const EmojiInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_emojiinfo_free(ptr >>> 0));
/**
* Emoji
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
class EmojiInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(EmojiInfo.prototype);
        obj.__wbg_ptr = ptr;
        EmojiInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof EmojiInfo)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EmojiInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_emojiinfo_free(ptr);
    }
    /**
    * @returns {string}
    */
    get shortcode() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_key(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} arg0
    */
    set shortcode(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_key(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {string}
    */
    get url() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_iv(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} arg0
    */
    set url(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_iv(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.EmojiInfo = EmojiInfo;

const EmojisFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_emojis_free(ptr >>> 0));
/**
* User preferred emojis and pointers to emoji sets
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
class Emojis {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EmojisFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_emojis_free(ptr);
    }
    /**
    * @returns {(EmojiInfo)[]}
    */
    get emojis() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_emojis_emojis(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(EmojiInfo)[]} arg0
    */
    set emojis(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_emojis_emojis(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(Coordinate)[]}
    */
    get coordinate() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_bookmarks_coordinate(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(Coordinate)[]} arg0
    */
    set coordinate(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_bookmarks_coordinate(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.Emojis = Emojis;

const EncryptedSecretKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_encryptedsecretkey_free(ptr >>> 0));
/**
* Encrypted Secret Key
*/
class EncryptedSecretKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(EncryptedSecretKey.prototype);
        obj.__wbg_ptr = ptr;
        EncryptedSecretKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EncryptedSecretKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_encryptedsecretkey_free(ptr);
    }
    /**
    * Encrypt secret key
    * @param {SecretKey} secret_key
    * @param {string} password
    * @param {number} log_n
    * @param {KeySecurity} key_security
    */
    constructor(secret_key, password, log_n, key_security) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(secret_key, SecretKey);
            const ptr0 = passStringToWasm0(password, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.encryptedsecretkey_new(retptr, secret_key.__wbg_ptr, ptr0, len0, log_n, key_security);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            this.__wbg_ptr = r0 >>> 0;
            return this;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} bech32
    * @returns {EncryptedSecretKey}
    */
    static fromBech32(bech32) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.encryptedsecretkey_fromBech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EncryptedSecretKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Get encrypted secret key version
    * @returns {EncryptedSecretKeyVersion}
    */
    version() {
        const ret = wasm.encryptedsecretkey_version(this.__wbg_ptr);
        return ret;
    }
    /**
    * Get encrypted secret key security
    * @returns {KeySecurity}
    */
    keySecurity() {
        const ret = wasm.encryptedsecretkey_keySecurity(this.__wbg_ptr);
        return ret;
    }
    /**
    * Consume `EncryptedSecretKey` and return `SecretKey`
    * @param {string} password
    * @returns {SecretKey}
    */
    toSecretKey(password) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(password, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.encryptedsecretkey_toSecretKey(retptr, ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SecretKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Decrypt to `SecretKey`
    * @param {string} password
    * @returns {SecretKey}
    */
    asSecretKey(password) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(password, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.encryptedsecretkey_asSecretKey(retptr, this.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SecretKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    toBech32() {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.encryptedsecretkey_toBech32(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred2_0, deferred2_1, 1);
        }
    }
}
module.exports.EncryptedSecretKey = EncryptedSecretKey;

const EventFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_event_free(ptr >>> 0));
/**
*/
class Event {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Event.prototype);
        obj.__wbg_ptr = ptr;
        EventFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof Event)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EventFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_event_free(ptr);
    }
    /**
    * @returns {EventId}
    */
    get id() {
        const ret = wasm.event_id(this.__wbg_ptr);
        return EventId.__wrap(ret);
    }
    /**
    * Get event author (`pubkey` field)
    * @returns {PublicKey}
    */
    get author() {
        const ret = wasm.coordinate_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {Timestamp}
    */
    get createdAt() {
        const ret = wasm.event_createdAt(this.__wbg_ptr);
        return Timestamp.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    get kind() {
        const ret = wasm.event_kind(this.__wbg_ptr);
        return ret;
    }
    /**
    * @returns {(Tag)[]}
    */
    get tags() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.event_tags(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    get content() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.event_content(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    get signature() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.event_signature(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {boolean}
    */
    verify() {
        const ret = wasm.event_verify(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * @param {string} json
    * @returns {Event}
    */
    static fromJson(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.event_fromJson(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    asJson() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.event_asJson(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.Event = Event;

const EventBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_eventbuilder_free(ptr >>> 0));
/**
*/
class EventBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(EventBuilder.prototype);
        obj.__wbg_ptr = ptr;
        EventBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EventBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_eventbuilder_free(ptr);
    }
    /**
    * @param {number} kind
    * @param {string} content
    * @param {(Tag)[]} tags
    */
    constructor(kind, content, tags) {
        const ptr0 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(tags, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_new(kind, ptr0, len0, ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Set a custom `created_at` UNIX timestamp
    * @param {Timestamp} created_at
    * @returns {EventBuilder}
    */
    customCreatedAt(created_at) {
        const ptr = this.__destroy_into_raw();
        _assertClass(created_at, Timestamp);
        var ptr0 = created_at.__destroy_into_raw();
        const ret = wasm.eventbuilder_customCreatedAt(ptr, ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Build `Event`
    *
    * **This method consume the builder, so it will no longer be usable!**
    * @param {Keys} keys
    * @returns {Event}
    */
    toEvent(keys) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(keys, Keys);
            wasm.eventbuilder_toEvent(retptr, ptr, keys.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Build `UnsignedEvent`
    *
    * **This method consume the builder, so it will no longer be usable!**
    * @param {PublicKey} public_key
    * @returns {UnsignedEvent}
    */
    toUnsignedEvent(public_key) {
        const ptr = this.__destroy_into_raw();
        _assertClass(public_key, PublicKey);
        const ret = wasm.eventbuilder_toUnsignedEvent(ptr, public_key.__wbg_ptr);
        return UnsignedEvent.__wrap(ret);
    }
    /**
    * Build POW `Event`
    *
    * **This method consume the builder, so it will no longer be usable!**
    * @param {Keys} keys
    * @param {number} difficulty
    * @returns {Event}
    */
    toPowEvent(keys, difficulty) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(keys, Keys);
            wasm.eventbuilder_toPowEvent(retptr, ptr, keys.__wbg_ptr, difficulty);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Build Unisgned POW Event
    *
    * **This method consume the builder, so it will no longer be usable!**
    * @param {PublicKey} public_key
    * @param {number} difficulty
    * @returns {UnsignedEvent}
    */
    toUnsignedPowEvent(public_key, difficulty) {
        const ptr = this.__destroy_into_raw();
        _assertClass(public_key, PublicKey);
        const ret = wasm.eventbuilder_toUnsignedPowEvent(ptr, public_key.__wbg_ptr, difficulty);
        return UnsignedEvent.__wrap(ret);
    }
    /**
    * @param {Metadata} metadata
    * @returns {EventBuilder}
    */
    static metadata(metadata) {
        _assertClass(metadata, Metadata);
        const ret = wasm.eventbuilder_metadata(metadata.__wbg_ptr);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {(RelayListItem)[]} relays
    * @returns {EventBuilder}
    */
    static relayList(relays) {
        const ptr0 = passArrayJsValueToWasm0(relays, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_relayList(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {string} content
    * @param {(Tag)[]} tags
    * @returns {EventBuilder}
    */
    static textNote(content, tags) {
        const ptr0 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(tags, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_textNote(ptr0, len0, ptr1, len1);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Text note reply
    *
    * If no `root` is passed, the `rely_to` will be used for root `e` tag.
    *
    * <https://github.com/nostr-protocol/nips/blob/master/10.md>
    * @param {string} content
    * @param {Event} reply_to
    * @param {Event | undefined} [root]
    * @param {string | undefined} [relay_url]
    * @returns {EventBuilder}
    */
    static textNoteReply(content, reply_to, root, relay_url) {
        const ptr0 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(reply_to, Event);
        let ptr1 = 0;
        if (!isLikeNone(root)) {
            _assertClass(root, Event);
            ptr1 = root.__destroy_into_raw();
        }
        var ptr2 = isLikeNone(relay_url) ? 0 : passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len2 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_textNoteReply(ptr0, len0, reply_to.__wbg_ptr, ptr1, ptr2, len2);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {string} content
    * @param {(Tag)[]} tags
    * @returns {EventBuilder}
    */
    static longFormTextNote(content, tags) {
        const ptr0 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(tags, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_longFormTextNote(ptr0, len0, ptr1, len1);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {(Contact)[]} list
    * @returns {EventBuilder}
    */
    static contactList(list) {
        const ptr0 = passArrayJsValueToWasm0(list, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_contactList(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {Keys} sender_keys
    * @param {PublicKey} receiver_pubkey
    * @param {string} content
    * @param {EventId | undefined} [reply_to]
    * @returns {EventBuilder}
    */
    static encryptedDirectMsg(sender_keys, receiver_pubkey, content, reply_to) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(sender_keys, Keys);
            _assertClass(receiver_pubkey, PublicKey);
            const ptr0 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            let ptr1 = 0;
            if (!isLikeNone(reply_to)) {
                _assertClass(reply_to, EventId);
                ptr1 = reply_to.__destroy_into_raw();
            }
            wasm.eventbuilder_encryptedDirectMsg(retptr, sender_keys.__wbg_ptr, receiver_pubkey.__wbg_ptr, ptr0, len0, ptr1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Repost
    * @param {Event} event
    * @param {string | undefined} [relay_url]
    * @returns {EventBuilder}
    */
    static repost(event, relay_url) {
        _assertClass(event, Event);
        var ptr0 = isLikeNone(relay_url) ? 0 : passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_repost(event.__wbg_ptr, ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {(EventId)[]} ids
    * @param {string | undefined} [reason]
    * @returns {EventBuilder}
    */
    static delete(ids, reason) {
        const ptr0 = passArrayJsValueToWasm0(ids, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(reason) ? 0 : passStringToWasm0(reason, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len1 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_delete(ptr0, len0, ptr1, len1);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Add reaction (like/upvote, dislike/downvote or emoji) to an event
    * @param {Event} event
    * @param {string} reaction
    * @returns {EventBuilder}
    */
    static reaction(event, reaction) {
        _assertClass(event, Event);
        const ptr0 = passStringToWasm0(reaction, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_reaction(event.__wbg_ptr, ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Add reaction (like/upvote, dislike/downvote or emoji) to an event
    * @param {EventId} event_id
    * @param {PublicKey} public_key
    * @param {number} kind
    * @param {string} reaction
    * @returns {EventBuilder}
    */
    static reactionExtended(event_id, public_key, kind, reaction) {
        _assertClass(event_id, EventId);
        _assertClass(public_key, PublicKey);
        const ptr0 = passStringToWasm0(reaction, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_reactionExtended(event_id.__wbg_ptr, public_key.__wbg_ptr, kind, ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {Metadata} metadata
    * @returns {EventBuilder}
    */
    static channel(metadata) {
        _assertClass(metadata, Metadata);
        const ret = wasm.eventbuilder_channel(metadata.__wbg_ptr);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {EventId} channel_id
    * @param {string | undefined} relay_url
    * @param {Metadata} metadata
    * @returns {EventBuilder}
    */
    static channelMetadata(channel_id, relay_url, metadata) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(channel_id, EventId);
            var ptr0 = isLikeNone(relay_url) ? 0 : passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            var len0 = WASM_VECTOR_LEN;
            _assertClass(metadata, Metadata);
            wasm.eventbuilder_channelMetadata(retptr, channel_id.__wbg_ptr, ptr0, len0, metadata.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {EventId} channel_id
    * @param {string} relay_url
    * @param {string} content
    * @returns {EventBuilder}
    */
    static channelMsg(channel_id, relay_url, content) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(channel_id, EventId);
            const ptr0 = passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len1 = WASM_VECTOR_LEN;
            wasm.eventbuilder_channelMsg(retptr, channel_id.__wbg_ptr, ptr0, len0, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {EventId} message_id
    * @param {string | undefined} [reason]
    * @returns {EventBuilder}
    */
    static hideChannelMsg(message_id, reason) {
        _assertClass(message_id, EventId);
        var ptr0 = isLikeNone(reason) ? 0 : passStringToWasm0(reason, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_hideChannelMsg(message_id.__wbg_ptr, ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {PublicKey} pubkey
    * @param {string | undefined} [reason]
    * @returns {EventBuilder}
    */
    static muteChannelUser(pubkey, reason) {
        _assertClass(pubkey, PublicKey);
        var ptr0 = isLikeNone(reason) ? 0 : passStringToWasm0(reason, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_muteChannelUser(pubkey.__wbg_ptr, ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {string} challenge
    * @param {string} relay
    * @returns {EventBuilder}
    */
    static auth(challenge, relay) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(challenge, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passStringToWasm0(relay, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len1 = WASM_VECTOR_LEN;
            wasm.eventbuilder_auth(retptr, ptr0, len0, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {LiveEvent} live_event
    * @returns {EventBuilder}
    */
    static liveEvent(live_event) {
        _assertClass(live_event, LiveEvent);
        var ptr0 = live_event.__destroy_into_raw();
        const ret = wasm.eventbuilder_liveEvent(ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {string} live_event_id
    * @param {PublicKey} live_event_host
    * @param {string} content
    * @param {string | undefined} relay_url
    * @param {(Tag)[]} tags
    * @returns {EventBuilder}
    */
    static liveEventMsg(live_event_id, live_event_host, content, relay_url, tags) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(live_event_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            _assertClass(live_event_host, PublicKey);
            var ptr1 = live_event_host.__destroy_into_raw();
            const ptr2 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len2 = WASM_VECTOR_LEN;
            var ptr3 = isLikeNone(relay_url) ? 0 : passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            var len3 = WASM_VECTOR_LEN;
            const ptr4 = passArrayJsValueToWasm0(tags, wasm.__wbindgen_export_0);
            const len4 = WASM_VECTOR_LEN;
            wasm.eventbuilder_liveEventMsg(retptr, ptr0, len0, ptr1, ptr2, len2, ptr3, len3, ptr4, len4);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(Tag)[]} tags
    * @param {string} content
    * @returns {EventBuilder}
    */
    static report(tags, content) {
        const ptr0 = passArrayJsValueToWasm0(tags, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_report(ptr0, len0, ptr1, len1);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {ZapRequestData} data
    * @returns {EventBuilder}
    */
    static publicZapRequest(data) {
        _assertClass(data, ZapRequestData);
        var ptr0 = data.__destroy_into_raw();
        const ret = wasm.eventbuilder_publicZapRequest(ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {string} bolt11
    * @param {string | undefined} preimage
    * @param {Event} zap_request
    * @returns {EventBuilder}
    */
    static zapReceipt(bolt11, preimage, zap_request) {
        const ptr0 = passStringToWasm0(bolt11, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(preimage) ? 0 : passStringToWasm0(preimage, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len1 = WASM_VECTOR_LEN;
        _assertClass(zap_request, Event);
        var ptr2 = zap_request.__destroy_into_raw();
        const ret = wasm.eventbuilder_zapReceipt(ptr0, len0, ptr1, len1, ptr2);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {string} badge_id
    * @param {string | undefined} name
    * @param {string | undefined} description
    * @param {string | undefined} image
    * @param {ImageDimensions | undefined} image_dimensions
    * @param {(Thumbnails)[]} thumbnails
    * @returns {EventBuilder}
    */
    static defineBadge(badge_id, name, description, image, image_dimensions, thumbnails) {
        const ptr0 = passStringToWasm0(badge_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(name) ? 0 : passStringToWasm0(name, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len1 = WASM_VECTOR_LEN;
        var ptr2 = isLikeNone(description) ? 0 : passStringToWasm0(description, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len2 = WASM_VECTOR_LEN;
        var ptr3 = isLikeNone(image) ? 0 : passStringToWasm0(image, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len3 = WASM_VECTOR_LEN;
        let ptr4 = 0;
        if (!isLikeNone(image_dimensions)) {
            _assertClass(image_dimensions, ImageDimensions);
            ptr4 = image_dimensions.__destroy_into_raw();
        }
        const ptr5 = passArrayJsValueToWasm0(thumbnails, wasm.__wbindgen_export_0);
        const len5 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_defineBadge(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, ptr4, ptr5, len5);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {Event} badge_definition
    * @param {(Tag)[]} awarded_pubkeys
    * @returns {EventBuilder}
    */
    static awardBadge(badge_definition, awarded_pubkeys) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(badge_definition, Event);
            const ptr0 = passArrayJsValueToWasm0(awarded_pubkeys, wasm.__wbindgen_export_0);
            const len0 = WASM_VECTOR_LEN;
            wasm.eventbuilder_awardBadge(retptr, badge_definition.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(Event)[]} badge_definitions
    * @param {(Event)[]} badge_awards
    * @param {PublicKey} pubkey_awarded
    * @returns {EventBuilder}
    */
    static profileBadges(badge_definitions, badge_awards, pubkey_awarded) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArrayJsValueToWasm0(badge_definitions, wasm.__wbindgen_export_0);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passArrayJsValueToWasm0(badge_awards, wasm.__wbindgen_export_0);
            const len1 = WASM_VECTOR_LEN;
            _assertClass(pubkey_awarded, PublicKey);
            wasm.eventbuilder_profileBadges(retptr, ptr0, len0, ptr1, len1, pubkey_awarded.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {number} kind
    * @param {(Tag)[]} tags
    * @returns {EventBuilder}
    */
    static jobRequest(kind, tags) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArrayJsValueToWasm0(tags, wasm.__wbindgen_export_0);
            const len0 = WASM_VECTOR_LEN;
            wasm.eventbuilder_jobRequest(retptr, kind, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Event} job_request
    * @param {number} amount_millisats
    * @param {string | undefined} [bolt11]
    * @returns {EventBuilder}
    */
    static jobResult(job_request, amount_millisats, bolt11) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(job_request, Event);
            var ptr0 = isLikeNone(bolt11) ? 0 : passStringToWasm0(bolt11, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            var len0 = WASM_VECTOR_LEN;
            wasm.eventbuilder_jobResult(retptr, job_request.__wbg_ptr, amount_millisats, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Event} job_request
    * @param {DataVendingMachineStatus} status
    * @param {string | undefined} extra_info
    * @param {bigint} amount_millisats
    * @param {string | undefined} [bolt11]
    * @param {string | undefined} [payload]
    * @returns {EventBuilder}
    */
    static jobFeedback(job_request, status, extra_info, amount_millisats, bolt11, payload) {
        _assertClass(job_request, Event);
        var ptr0 = isLikeNone(extra_info) ? 0 : passStringToWasm0(extra_info, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(bolt11) ? 0 : passStringToWasm0(bolt11, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len1 = WASM_VECTOR_LEN;
        var ptr2 = isLikeNone(payload) ? 0 : passStringToWasm0(payload, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len2 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_jobFeedback(job_request.__wbg_ptr, status, ptr0, len0, amount_millisats, ptr1, len1, ptr2, len2);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {string} description
    * @param {FileMetadata} metadata
    * @returns {EventBuilder}
    */
    static fileMetadata(description, metadata) {
        const ptr0 = passStringToWasm0(description, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(metadata, FileMetadata);
        var ptr1 = metadata.__destroy_into_raw();
        const ret = wasm.eventbuilder_fileMetadata(ptr0, len0, ptr1);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {HttpData} data
    * @returns {EventBuilder}
    */
    static httpAuth(data) {
        _assertClass(data, HttpData);
        var ptr0 = data.__destroy_into_raw();
        const ret = wasm.eventbuilder_httpAuth(ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {StallData} data
    * @returns {EventBuilder}
    */
    static stallData(data) {
        _assertClass(data, StallData);
        const ret = wasm.eventbuilder_stallData(data.__wbg_ptr);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {ProductData} data
    * @returns {EventBuilder}
    */
    static productData(data) {
        _assertClass(data, ProductData);
        var ptr0 = data.__destroy_into_raw();
        const ret = wasm.eventbuilder_productData(ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Gift Wrap from seal
    *
    * <https://github.com/nostr-protocol/nips/blob/master/59.md>
    * @param {PublicKey} receiver
    * @param {Event} seal
    * @param {Timestamp | undefined} [expiration]
    * @returns {Event}
    */
    static giftWrapFromSeal(receiver, seal, expiration) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(receiver, PublicKey);
            _assertClass(seal, Event);
            let ptr0 = 0;
            if (!isLikeNone(expiration)) {
                _assertClass(expiration, Timestamp);
                ptr0 = expiration.__destroy_into_raw();
            }
            wasm.eventbuilder_giftWrapFromSeal(retptr, receiver.__wbg_ptr, seal.__wbg_ptr, ptr0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Gift Wrap
    *
    * <https://github.com/nostr-protocol/nips/blob/master/59.md>
    * @param {Keys} sender_keys
    * @param {PublicKey} receiver
    * @param {UnsignedEvent} rumor
    * @param {Timestamp | undefined} [expiration]
    * @returns {Event}
    */
    static giftWrap(sender_keys, receiver, rumor, expiration) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(sender_keys, Keys);
            _assertClass(receiver, PublicKey);
            _assertClass(rumor, UnsignedEvent);
            let ptr0 = 0;
            if (!isLikeNone(expiration)) {
                _assertClass(expiration, Timestamp);
                ptr0 = expiration.__destroy_into_raw();
            }
            wasm.eventbuilder_giftWrap(retptr, sender_keys.__wbg_ptr, receiver.__wbg_ptr, rumor.__wbg_ptr, ptr0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * GiftWrapped Sealed Direct message
    * @param {PublicKey} receiver
    * @param {string} message
    * @returns {EventBuilder}
    */
    static sealedDirect(receiver, message) {
        _assertClass(receiver, PublicKey);
        const ptr0 = passStringToWasm0(message, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_sealedDirect(receiver.__wbg_ptr, ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Mute list
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {MuteList} list
    * @returns {EventBuilder}
    */
    static muteList(list) {
        _assertClass(list, MuteList);
        var ptr0 = list.__destroy_into_raw();
        const ret = wasm.eventbuilder_muteList(ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Pinned notes
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(EventId)[]} ids
    * @returns {EventBuilder}
    */
    static pinnedNotes(ids) {
        const ptr0 = passArrayJsValueToWasm0(ids, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_pinnedNotes(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Bookmarks
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {Bookmarks} list
    * @returns {EventBuilder}
    */
    static bookmarks(list) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(list, Bookmarks);
            var ptr0 = list.__destroy_into_raw();
            wasm.eventbuilder_bookmarks(retptr, ptr0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Communities
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(Coordinate)[]} communities
    * @returns {EventBuilder}
    */
    static communities(communities) {
        const ptr0 = passArrayJsValueToWasm0(communities, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_communities(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Public chats
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(EventId)[]} chat
    * @returns {EventBuilder}
    */
    static publicChats(chat) {
        const ptr0 = passArrayJsValueToWasm0(chat, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_publicChats(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Blocked relays
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(string)[]} relays
    * @returns {EventBuilder}
    */
    static blockedRelays(relays) {
        const ptr0 = passArrayJsValueToWasm0(relays, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_blockedRelays(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Search relays
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(string)[]} relays
    * @returns {EventBuilder}
    */
    static searchRelays(relays) {
        const ptr0 = passArrayJsValueToWasm0(relays, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_searchRelays(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Interests
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {Interests} list
    * @returns {EventBuilder}
    */
    static interests(list) {
        _assertClass(list, Interests);
        var ptr0 = list.__destroy_into_raw();
        const ret = wasm.eventbuilder_interests(ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Emojis
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {Emojis} list
    * @returns {EventBuilder}
    */
    static emojis(list) {
        _assertClass(list, Emojis);
        var ptr0 = list.__destroy_into_raw();
        const ret = wasm.eventbuilder_emojis(ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Follow sets
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(PublicKey)[]} public_keys
    * @returns {EventBuilder}
    */
    static followSets(public_keys) {
        const ptr0 = passArrayJsValueToWasm0(public_keys, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_followSets(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Relay sets
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(string)[]} relays
    * @returns {EventBuilder}
    */
    static relaySets(relays) {
        const ptr0 = passArrayJsValueToWasm0(relays, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_relaySets(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Bookmark sets
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {Bookmarks} list
    * @returns {EventBuilder}
    */
    static bookmarksSets(list) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(list, Bookmarks);
            var ptr0 = list.__destroy_into_raw();
            wasm.eventbuilder_bookmarksSets(retptr, ptr0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Article Curation sets
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {ArticlesCuration} list
    * @returns {EventBuilder}
    */
    static articlesCurationSets(list) {
        _assertClass(list, ArticlesCuration);
        var ptr0 = list.__destroy_into_raw();
        const ret = wasm.eventbuilder_articlesCurationSets(ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Videos Curation sets
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(Coordinate)[]} video
    * @returns {EventBuilder}
    */
    static videosCurationSets(video) {
        const ptr0 = passArrayJsValueToWasm0(video, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_videosCurationSets(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Emoji sets
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(EmojiInfo)[]} emoji
    * @returns {EventBuilder}
    */
    static emojiSets(emoji) {
        const ptr0 = passArrayJsValueToWasm0(emoji, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_emojiSets(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Label
    *
    * <https://github.com/nostr-protocol/nips/blob/master/32.md>
    * @param {string} label_namespace
    * @param {(string)[]} labels
    * @returns {EventBuilder}
    */
    static label(label_namespace, labels) {
        const ptr0 = passStringToWasm0(label_namespace, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(labels, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_label(ptr0, len0, ptr1, len1);
        return EventBuilder.__wrap(ret);
    }
}
module.exports.EventBuilder = EventBuilder;

const EventIdFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_eventid_free(ptr >>> 0));
/**
*/
class EventId {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(EventId.prototype);
        obj.__wbg_ptr = ptr;
        EventIdFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof EventId)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EventIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_eventid_free(ptr);
    }
    /**
    * @param {PublicKey} pubkey
    * @param {Timestamp} created_at
    * @param {number} kind
    * @param {(Tag)[]} tags
    * @param {string} content
    */
    constructor(pubkey, created_at, kind, tags, content) {
        _assertClass(pubkey, PublicKey);
        _assertClass(created_at, Timestamp);
        const ptr0 = passArrayJsValueToWasm0(tags, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.eventid_new(pubkey.__wbg_ptr, created_at.__wbg_ptr, kind, ptr0, len0, ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Try to parse event ID from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
    * @param {string} id
    * @returns {EventId}
    */
    static parse(id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.eventid_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {EventId}
    */
    static fromSlice(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_export_0);
            const len0 = WASM_VECTOR_LEN;
            wasm.eventid_fromSlice(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} hex
    * @returns {EventId}
    */
    static fromHex(hex) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.eventid_fromHex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} bech32
    * @returns {EventId}
    */
    static fromBech32(bech32) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.eventid_fromBech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    asBytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.eventid_asBytes(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    toHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.eventid_toHex(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    toBech32() {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.eventid_toBech32(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred2_0, deferred2_1, 1);
        }
    }
}
module.exports.EventId = EventId;

const FileMetadataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_filemetadata_free(ptr >>> 0));
/**
*/
class FileMetadata {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FileMetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_filemetadata_free(ptr);
    }
    /**
    * @param {string} url
    * @param {string} mime_type
    * @param {string} hash
    */
    constructor(url, mime_type, hash) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passStringToWasm0(mime_type, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len1 = WASM_VECTOR_LEN;
            const ptr2 = passStringToWasm0(hash, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len2 = WASM_VECTOR_LEN;
            wasm.filemetadata_new(retptr, ptr0, len0, ptr1, len1, ptr2, len2);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            this.__wbg_ptr = r0 >>> 0;
            return this;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    get urls() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.filemetadata_urls(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    get mimeType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.filemetadata_mimeType(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    get hash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.filemetadata_hash(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {Aes256Gcm | undefined}
    */
    get aes256Gcm() {
        const ret = wasm.filemetadata_aes256Gcm(this.__wbg_ptr);
        return ret === 0 ? undefined : Aes256Gcm.__wrap(ret);
    }
    /**
    * @returns {number | undefined}
    */
    get size() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.filemetadata_size(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getFloat64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {ImageDimensions | undefined}
    */
    get dim() {
        const ret = wasm.filemetadata_dim(this.__wbg_ptr);
        return ret === 0 ? undefined : ImageDimensions.__wrap(ret);
    }
    /**
    * @returns {string | undefined}
    */
    get magnet() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.filemetadata_magnet(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get blurhash() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.filemetadata_blurhash(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.FileMetadata = FileMetadata;

const FilterFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_filter_free(ptr >>> 0));
/**
*/
class Filter {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Filter.prototype);
        obj.__wbg_ptr = ptr;
        FilterFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof Filter)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FilterFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_filter_free(ptr);
    }
    /**
    */
    constructor() {
        const ret = wasm.filter_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @param {string} json
    * @returns {Filter}
    */
    static fromJson(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.filter_fromJson(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Filter.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    asJson() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.filter_asJson(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Set subscription id
    * @param {EventId} id
    * @returns {Filter}
    */
    id(id) {
        const ptr = this.__destroy_into_raw();
        _assertClass(id, EventId);
        const ret = wasm.filter_id(ptr, id.__wbg_ptr);
        return Filter.__wrap(ret);
    }
    /**
    * Set subscription ids
    * @param {(EventId)[]} ids
    * @returns {Filter}
    */
    ids(ids) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(ids, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_ids(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set author
    * @param {PublicKey} author
    * @returns {Filter}
    */
    author(author) {
        const ptr = this.__destroy_into_raw();
        _assertClass(author, PublicKey);
        const ret = wasm.filter_author(ptr, author.__wbg_ptr);
        return Filter.__wrap(ret);
    }
    /**
    * Set authors
    * @param {(PublicKey)[]} authors
    * @returns {Filter}
    */
    authors(authors) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(authors, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_authors(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set kind
    * @param {number} kind
    * @returns {Filter}
    */
    kind(kind) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.filter_kind(ptr, kind);
        return Filter.__wrap(ret);
    }
    /**
    * Set kinds
    * @param {Float64Array} kinds
    * @returns {Filter}
    */
    kinds(kinds) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayF64ToWasm0(kinds, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_kinds(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set event
    * @param {EventId} id
    * @returns {Filter}
    */
    event(id) {
        const ptr = this.__destroy_into_raw();
        _assertClass(id, EventId);
        const ret = wasm.filter_event(ptr, id.__wbg_ptr);
        return Filter.__wrap(ret);
    }
    /**
    * Set events
    * @param {(EventId)[]} ids
    * @returns {Filter}
    */
    events(ids) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(ids, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_events(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set pubkey
    * @param {PublicKey} pubkey
    * @returns {Filter}
    */
    pubkey(pubkey) {
        const ptr = this.__destroy_into_raw();
        _assertClass(pubkey, PublicKey);
        const ret = wasm.filter_pubkey(ptr, pubkey.__wbg_ptr);
        return Filter.__wrap(ret);
    }
    /**
    * Set pubkeys
    * @param {(PublicKey)[]} pubkeys
    * @returns {Filter}
    */
    pubkeys(pubkeys) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(pubkeys, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_pubkeys(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set hashtag
    *
    * <https://github.com/nostr-protocol/nips/blob/master/12.md>
    * @param {string} hashtag
    * @returns {Filter}
    */
    hashtag(hashtag) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passStringToWasm0(hashtag, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_hashtag(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set hashtags
    *
    * <https://github.com/nostr-protocol/nips/blob/master/12.md>
    * @param {(string)[]} hashtags
    * @returns {Filter}
    */
    hashtags(hashtags) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(hashtags, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_hashtags(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set reference
    *
    * <https://github.com/nostr-protocol/nips/blob/master/12.md>
    * @param {string} v
    * @returns {Filter}
    */
    reference(v) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passStringToWasm0(v, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_reference(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set references
    *
    * <https://github.com/nostr-protocol/nips/blob/master/12.md>
    * @param {(string)[]} v
    * @returns {Filter}
    */
    references(v) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(v, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_references(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set search field
    * @param {string} value
    * @returns {Filter}
    */
    search(value) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passStringToWasm0(value, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_search(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set since unix timestamp
    * @param {Timestamp} since
    * @returns {Filter}
    */
    since(since) {
        const ptr = this.__destroy_into_raw();
        _assertClass(since, Timestamp);
        const ret = wasm.filter_since(ptr, since.__wbg_ptr);
        return Filter.__wrap(ret);
    }
    /**
    * Set until unix timestamp
    * @param {Timestamp} until
    * @returns {Filter}
    */
    until(until) {
        const ptr = this.__destroy_into_raw();
        _assertClass(until, Timestamp);
        const ret = wasm.filter_until(ptr, until.__wbg_ptr);
        return Filter.__wrap(ret);
    }
    /**
    * Set limit
    * @param {number} limit
    * @returns {Filter}
    */
    limit(limit) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.filter_limit(ptr, limit);
        return Filter.__wrap(ret);
    }
    /**
    * @param {SingleLetterTag} tag
    * @param {(string)[]} values
    * @returns {Filter}
    */
    customTag(tag, values) {
        const ptr = this.__destroy_into_raw();
        _assertClass(tag, SingleLetterTag);
        const ptr0 = passArrayJsValueToWasm0(values, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_customTag(ptr, tag.__wbg_ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * @param {SingleLetterTag} tag
    * @param {(string)[]} values
    * @returns {Filter}
    */
    removeCustomTag(tag, values) {
        const ptr = this.__destroy_into_raw();
        _assertClass(tag, SingleLetterTag);
        const ptr0 = passArrayJsValueToWasm0(values, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_removeCustomTag(ptr, tag.__wbg_ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Determine if `Filter` match given `Event`.
    *
    * The `search` filed is not supported yet!
    * @param {Event} event
    * @returns {boolean}
    */
    matchEvent(event) {
        _assertClass(event, Event);
        const ret = wasm.filter_matchEvent(this.__wbg_ptr, event.__wbg_ptr);
        return ret !== 0;
    }
}
module.exports.Filter = Filter;

const FilterOptionsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_filteroptions_free(ptr >>> 0));
/**
* Filter options
*/
class FilterOptions {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FilterOptions.prototype);
        obj.__wbg_ptr = ptr;
        FilterOptionsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FilterOptionsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_filteroptions_free(ptr);
    }
    /**
    * Exit on EOSE
    * @returns {FilterOptions}
    */
    static exitOnEose() {
        const ret = wasm.filteroptions_exitOnEose();
        return FilterOptions.__wrap(ret);
    }
    /**
    * After EOSE is received, keep listening for N more events that match the filter, then return
    * @param {number} num
    * @returns {FilterOptions}
    */
    static waitForEventsAfterEOSE(num) {
        const ret = wasm.filteroptions_waitForEventsAfterEOSE(num);
        return FilterOptions.__wrap(ret);
    }
    /**
    * After EOSE is received, keep listening for matching events for `Duration` more time, then return
    * @param {Duration} duration
    * @returns {FilterOptions}
    */
    static waitDurationAfterEOSE(duration) {
        _assertClass(duration, Duration);
        const ret = wasm.filteroptions_waitDurationAfterEOSE(duration.__wbg_ptr);
        return FilterOptions.__wrap(ret);
    }
}
module.exports.FilterOptions = FilterOptions;

const GetBalanceResponseResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_getbalanceresponseresult_free(ptr >>> 0));
/**
*/
class GetBalanceResponseResult {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GetBalanceResponseResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_getbalanceresponseresult_free(ptr);
    }
    /**
    * Balance amount in msats
    * @returns {bigint}
    */
    get balance() {
        const ret = wasm.__wbg_get_getbalanceresponseresult_balance(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * Balance amount in msats
    * @param {bigint} arg0
    */
    set balance(arg0) {
        wasm.__wbg_set_getbalanceresponseresult_balance(this.__wbg_ptr, arg0);
    }
}
module.exports.GetBalanceResponseResult = GetBalanceResponseResult;

const GetInfoResponseResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_getinforesponseresult_free(ptr >>> 0));
/**
*/
class GetInfoResponseResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GetInfoResponseResult.prototype);
        obj.__wbg_ptr = ptr;
        GetInfoResponseResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GetInfoResponseResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_getinforesponseresult_free(ptr);
    }
    /**
    * The alias of the lightning node
    * @returns {string}
    */
    get alias() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_key(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * The alias of the lightning node
    * @param {string} arg0
    */
    set alias(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_key(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * The color of the current node in hex code format
    * @returns {string}
    */
    get color() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_iv(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * The color of the current node in hex code format
    * @param {string} arg0
    */
    set color(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_iv(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Lightning Node's public key
    * @returns {string}
    */
    get pubkey() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_getinforesponseresult_pubkey(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Lightning Node's public key
    * @param {string} arg0
    */
    set pubkey(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_getinforesponseresult_pubkey(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Active network
    * @returns {string}
    */
    get network() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_getinforesponseresult_network(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Active network
    * @param {string} arg0
    */
    set network(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_getinforesponseresult_network(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Current block height
    * @returns {number}
    */
    get block_height() {
        const ret = wasm.__wbg_get_getinforesponseresult_block_height(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
    * Current block height
    * @param {number} arg0
    */
    set block_height(arg0) {
        wasm.__wbg_set_getinforesponseresult_block_height(this.__wbg_ptr, arg0);
    }
    /**
    * Most Recent Block Hash
    * @returns {string}
    */
    get block_hash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_getinforesponseresult_block_hash(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Most Recent Block Hash
    * @param {string} arg0
    */
    set block_hash(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_getinforesponseresult_block_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Available methods for this connection
    * @returns {(string)[]}
    */
    get methods() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_getinforesponseresult_methods(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Available methods for this connection
    * @param {(string)[]} arg0
    */
    set methods(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_getinforesponseresult_methods(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.GetInfoResponseResult = GetInfoResponseResult;

const HttpDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_httpdata_free(ptr >>> 0));
/**
*/
class HttpData {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        HttpDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_httpdata_free(ptr);
    }
    /**
    * @param {string} url
    * @param {HttpMethod} method
    */
    constructor(url, method) {
        const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.httpdata_new(ptr0, len0, method);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @returns {string}
    */
    get urls() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.httpdata_urls(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {HttpMethod}
    */
    get method() {
        const ret = wasm.httpdata_method(this.__wbg_ptr);
        return ret;
    }
    /**
    * @returns {string | undefined}
    */
    get payload() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.httpdata_payload(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.HttpData = HttpData;

const ImageFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_image_free(ptr >>> 0));
/**
*/
class Image {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Image.prototype);
        obj.__wbg_ptr = ptr;
        ImageFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ImageFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_image_free(ptr);
    }
    /**
    * @returns {string}
    */
    get url() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_image_url(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} arg0
    */
    set url(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_image_url(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {ImageDimensions | undefined}
    */
    get dimensions() {
        const ret = wasm.__wbg_get_image_dimensions(this.__wbg_ptr);
        return ret === 0 ? undefined : ImageDimensions.__wrap(ret);
    }
    /**
    * @param {ImageDimensions | undefined} [arg0]
    */
    set dimensions(arg0) {
        let ptr0 = 0;
        if (!isLikeNone(arg0)) {
            _assertClass(arg0, ImageDimensions);
            ptr0 = arg0.__destroy_into_raw();
        }
        wasm.__wbg_set_image_dimensions(this.__wbg_ptr, ptr0);
    }
    /**
    * @param {string} url
    * @param {ImageDimensions | undefined} [dimensions]
    */
    constructor(url, dimensions) {
        const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        let ptr1 = 0;
        if (!isLikeNone(dimensions)) {
            _assertClass(dimensions, ImageDimensions);
            ptr1 = dimensions.__destroy_into_raw();
        }
        const ret = wasm.image_new(ptr0, len0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
}
module.exports.Image = Image;

const ImageDimensionsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_imagedimensions_free(ptr >>> 0));
/**
*/
class ImageDimensions {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ImageDimensions.prototype);
        obj.__wbg_ptr = ptr;
        ImageDimensionsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ImageDimensionsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_imagedimensions_free(ptr);
    }
    /**
    * @returns {bigint}
    */
    get width() {
        const ret = wasm.__wbg_get_getbalanceresponseresult_balance(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {bigint} arg0
    */
    set width(arg0) {
        wasm.__wbg_set_getbalanceresponseresult_balance(this.__wbg_ptr, arg0);
    }
    /**
    * @returns {bigint}
    */
    get height() {
        const ret = wasm.__wbg_get_imagedimensions_height(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {bigint} arg0
    */
    set height(arg0) {
        wasm.__wbg_set_imagedimensions_height(this.__wbg_ptr, arg0);
    }
}
module.exports.ImageDimensions = ImageDimensions;

const InterestsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_interests_free(ptr >>> 0));
/**
* Topics a user may be interested in and pointers
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
class Interests {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        InterestsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_interests_free(ptr);
    }
    /**
    * @returns {(string)[]}
    */
    get hashtags() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_interests_hashtags(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(string)[]} arg0
    */
    set hashtags(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_interests_hashtags(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(Coordinate)[]}
    */
    get coordinate() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_bookmarks_coordinate(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(Coordinate)[]} arg0
    */
    set coordinate(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_bookmarks_coordinate(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.Interests = Interests;

const KeysFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_keys_free(ptr >>> 0));
/**
*/
class Keys {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Keys.prototype);
        obj.__wbg_ptr = ptr;
        KeysFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        KeysFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_keys_free(ptr);
    }
    /**
    * Initialize from secret key.
    * @param {SecretKey} secret_key
    */
    constructor(secret_key) {
        _assertClass(secret_key, SecretKey);
        const ret = wasm.keys_new(secret_key.__wbg_ptr);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Try to parse keys from **secret key** `hex` or `bech32`
    * @param {string} secret_key
    * @returns {Keys}
    */
    static parse(secret_key) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(secret_key, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.keys_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Keys.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Initialize with public key only (no secret key).
    * @param {PublicKey} public_key
    * @returns {Keys}
    */
    static fromPublicKey(public_key) {
        _assertClass(public_key, PublicKey);
        const ret = wasm.keys_fromPublicKey(public_key.__wbg_ptr);
        return Keys.__wrap(ret);
    }
    /**
    * Generate new random keys
    * @returns {Keys}
    */
    static generate() {
        const ret = wasm.keys_generate();
        return Keys.__wrap(ret);
    }
    /**
    * @param {(string)[]} prefixes
    * @param {boolean} bech32
    * @param {number} num_cores
    * @returns {Keys}
    */
    static vanity(prefixes, bech32, num_cores) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArrayJsValueToWasm0(prefixes, wasm.__wbindgen_export_0);
            const len0 = WASM_VECTOR_LEN;
            wasm.keys_vanity(retptr, ptr0, len0, bech32, num_cores);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Keys.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Derive keys from BIP-39 mnemonics (ENGLISH wordlist).
    *
    * <https://github.com/nostr-protocol/nips/blob/master/06.md>
    * @param {string} mnemonic
    * @param {string | undefined} [passphrase]
    * @param {number | undefined} [account]
    * @param {number | undefined} [typ]
    * @param {number | undefined} [index]
    * @returns {Keys}
    */
    static fromMnemonic(mnemonic, passphrase, account, typ, index) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(mnemonic, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            var ptr1 = isLikeNone(passphrase) ? 0 : passStringToWasm0(passphrase, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            var len1 = WASM_VECTOR_LEN;
            wasm.keys_fromMnemonic(retptr, ptr0, len0, ptr1, len1, !isLikeNone(account), isLikeNone(account) ? 0 : account, !isLikeNone(typ), isLikeNone(typ) ? 0 : typ, !isLikeNone(index), isLikeNone(index) ? 0 : index);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Keys.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Get public key
    * @returns {PublicKey}
    */
    get publicKey() {
        const ret = wasm.keys_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * Get secret key
    * @returns {SecretKey}
    */
    get secretKey() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.keys_secretKey(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SecretKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Keys = Keys;

const KeysendTLVRecordFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_keysendtlvrecord_free(ptr >>> 0));
/**
* TLVs to be added to the keysend payment
*/
class KeysendTLVRecord {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(KeysendTLVRecord.prototype);
        obj.__wbg_ptr = ptr;
        KeysendTLVRecordFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof KeysendTLVRecord)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        KeysendTLVRecordFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_keysendtlvrecord_free(ptr);
    }
    /**
    * TLV type
    * @returns {bigint}
    */
    get tlv_type() {
        const ret = wasm.__wbg_get_getbalanceresponseresult_balance(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * TLV type
    * @param {bigint} arg0
    */
    set tlv_type(arg0) {
        wasm.__wbg_set_getbalanceresponseresult_balance(this.__wbg_ptr, arg0);
    }
    /**
    * TLV value
    * @returns {string}
    */
    get value() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_keysendtlvrecord_value(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * TLV value
    * @param {string} arg0
    */
    set value(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_keysendtlvrecord_value(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.KeysendTLVRecord = KeysendTLVRecord;

const ListTransactionsRequestParamsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_listtransactionsrequestparams_free(ptr >>> 0));
/**
* List Invoice Request Params
*/
class ListTransactionsRequestParams {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ListTransactionsRequestParamsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_listtransactionsrequestparams_free(ptr);
    }
    /**
    * Starting timestamp in seconds since epoch
    * @returns {bigint | undefined}
    */
    get from() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_listtransactionsrequestparams_from(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Starting timestamp in seconds since epoch
    * @param {bigint | undefined} [arg0]
    */
    set from(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_from(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
    * Ending timestamp in seconds since epoch
    * @returns {bigint | undefined}
    */
    get until() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_listtransactionsrequestparams_until(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Ending timestamp in seconds since epoch
    * @param {bigint | undefined} [arg0]
    */
    set until(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_until(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
    * Number of invoices to return
    * @returns {bigint | undefined}
    */
    get limit() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_listtransactionsrequestparams_limit(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Number of invoices to return
    * @param {bigint | undefined} [arg0]
    */
    set limit(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_limit(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
    * Offset of the first invoice to return
    * @returns {bigint | undefined}
    */
    get offset() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_listtransactionsrequestparams_offset(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Offset of the first invoice to return
    * @param {bigint | undefined} [arg0]
    */
    set offset(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_offset(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
    * If true, include unpaid invoices
    * @returns {boolean | undefined}
    */
    get unpaid() {
        const ret = wasm.__wbg_get_listtransactionsrequestparams_unpaid(this.__wbg_ptr);
        return ret === 0xFFFFFF ? undefined : ret !== 0;
    }
    /**
    * If true, include unpaid invoices
    * @param {boolean | undefined} [arg0]
    */
    set unpaid(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_unpaid(this.__wbg_ptr, isLikeNone(arg0) ? 0xFFFFFF : arg0 ? 1 : 0);
    }
    /**
    * [`TransactionType::Incoming`] for invoices, [`TransactionType::Outgoing`] for payments, [`None`] for both
    * @returns {TransactionType | undefined}
    */
    get transaction_type() {
        const ret = wasm.__wbg_get_listtransactionsrequestparams_transaction_type(this.__wbg_ptr);
        return ret === 2 ? undefined : ret;
    }
    /**
    * [`TransactionType::Incoming`] for invoices, [`TransactionType::Outgoing`] for payments, [`None`] for both
    * @param {TransactionType | undefined} [arg0]
    */
    set transaction_type(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_transaction_type(this.__wbg_ptr, isLikeNone(arg0) ? 2 : arg0);
    }
}
module.exports.ListTransactionsRequestParams = ListTransactionsRequestParams;

const LiveEventFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_liveevent_free(ptr >>> 0));
/**
*/
class LiveEvent {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LiveEventFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_liveevent_free(ptr);
    }
    /**
    * @returns {string}
    */
    get id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_id(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get title() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_title(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get summary() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_summary(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Image | undefined}
    */
    get image() {
        const ret = wasm.liveevent_image(this.__wbg_ptr);
        return ret === 0 ? undefined : Image.__wrap(ret);
    }
    /**
    * @returns {(string)[]}
    */
    get hashtags() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_hashtags(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get streaming() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_streaming(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get recording() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_recording(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {number | undefined}
    */
    get starts() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_starts(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getFloat64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {number | undefined}
    */
    get ends() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_ends(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getFloat64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {LiveEventStatus | undefined}
    */
    get status() {
        const ret = wasm.liveevent_status(this.__wbg_ptr);
        return ret === 0 ? undefined : LiveEventStatus.__wrap(ret);
    }
    /**
    * @returns {number | undefined}
    */
    get currentPartecipants() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_currentPartecipants(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getFloat64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {number | undefined}
    */
    get totalPartecipants() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_totalPartecipants(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getFloat64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {(string)[]}
    */
    get relays() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_relays(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {LiveEventHost | undefined}
    */
    get host() {
        const ret = wasm.liveevent_host(this.__wbg_ptr);
        return ret === 0 ? undefined : LiveEventHost.__wrap(ret);
    }
    /**
    * @returns {(User)[]}
    */
    get speakers() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_speakers(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {(User)[]}
    */
    get participants() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_participants(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.LiveEvent = LiveEvent;

const LiveEventHostFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_liveeventhost_free(ptr >>> 0));
/**
*/
class LiveEventHost {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LiveEventHost.prototype);
        obj.__wbg_ptr = ptr;
        LiveEventHostFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LiveEventHostFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_liveeventhost_free(ptr);
    }
    /**
    * @returns {PublicKey}
    */
    get publicKey() {
        const ret = wasm.liveeventhost_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {string | undefined}
    */
    get relayUrl() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveeventhost_relayUrl(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get proof() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveeventhost_proof(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.LiveEventHost = LiveEventHost;

const LiveEventStatusFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_liveeventstatus_free(ptr >>> 0));
/**
*/
class LiveEventStatus {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LiveEventStatus.prototype);
        obj.__wbg_ptr = ptr;
        LiveEventStatusFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LiveEventStatusFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_liveeventstatus_free(ptr);
    }
    /**
    * @returns {LiveEventStatus}
    */
    static planned() {
        const ret = wasm.liveeventstatus_planned();
        return LiveEventStatus.__wrap(ret);
    }
    /**
    * @returns {LiveEventStatus}
    */
    static live() {
        const ret = wasm.liveeventstatus_live();
        return LiveEventStatus.__wrap(ret);
    }
    /**
    * @returns {LiveEventStatus}
    */
    static ended() {
        const ret = wasm.liveeventstatus_ended();
        return LiveEventStatus.__wrap(ret);
    }
    /**
    * @param {string} string
    * @returns {LiveEventStatus}
    */
    static custom(string) {
        const ptr0 = passStringToWasm0(string, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.liveeventstatus_custom(ptr0, len0);
        return LiveEventStatus.__wrap(ret);
    }
}
module.exports.LiveEventStatus = LiveEventStatus;

const LogLevelFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_loglevel_free(ptr >>> 0));
/**
*/
class LogLevel {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LogLevel.prototype);
        obj.__wbg_ptr = ptr;
        LogLevelFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LogLevelFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_loglevel_free(ptr);
    }
    /**
    * @returns {LogLevel}
    */
    static trace() {
        const ret = wasm.loglevel_trace();
        return LogLevel.__wrap(ret);
    }
    /**
    * @returns {LogLevel}
    */
    static debug() {
        const ret = wasm.loglevel_debug();
        return LogLevel.__wrap(ret);
    }
    /**
    * @returns {LogLevel}
    */
    static info() {
        const ret = wasm.loglevel_info();
        return LogLevel.__wrap(ret);
    }
    /**
    * @returns {LogLevel}
    */
    static warn() {
        const ret = wasm.loglevel_warn();
        return LogLevel.__wrap(ret);
    }
    /**
    * @returns {LogLevel}
    */
    static error() {
        const ret = wasm.loglevel_error();
        return LogLevel.__wrap(ret);
    }
}
module.exports.LogLevel = LogLevel;

const LookupInvoiceRequestParamsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_lookupinvoicerequestparams_free(ptr >>> 0));
/**
* Lookup Invoice Request Params
*/
class LookupInvoiceRequestParams {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LookupInvoiceRequestParamsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_lookupinvoicerequestparams_free(ptr);
    }
    /**
    * Payment hash of invoice
    * @returns {string | undefined}
    */
    get payment_hash() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoicerequestparams_payment_hash(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Payment hash of invoice
    * @param {string | undefined} [arg0]
    */
    set payment_hash(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoicerequestparams_payment_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Bolt11 invoice
    * @returns {string | undefined}
    */
    get invoice() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoicerequestparams_invoice(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Bolt11 invoice
    * @param {string | undefined} [arg0]
    */
    set invoice(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoicerequestparams_invoice(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.LookupInvoiceRequestParams = LookupInvoiceRequestParams;

const LookupInvoiceResponseResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_lookupinvoiceresponseresult_free(ptr >>> 0));
/**
*/
class LookupInvoiceResponseResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LookupInvoiceResponseResult.prototype);
        obj.__wbg_ptr = ptr;
        LookupInvoiceResponseResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LookupInvoiceResponseResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_lookupinvoiceresponseresult_free(ptr);
    }
    /**
    * Transaction type
    * @returns {TransactionType | undefined}
    */
    get transaction_type() {
        const ret = wasm.__wbg_get_lookupinvoiceresponseresult_transaction_type(this.__wbg_ptr);
        return ret === 2 ? undefined : ret;
    }
    /**
    * Transaction type
    * @param {TransactionType | undefined} [arg0]
    */
    set transaction_type(arg0) {
        wasm.__wbg_set_lookupinvoiceresponseresult_transaction_type(this.__wbg_ptr, isLikeNone(arg0) ? 2 : arg0);
    }
    /**
    * Bolt11 invoice
    * @returns {string | undefined}
    */
    get invoice() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoiceresponseresult_invoice(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Bolt11 invoice
    * @param {string | undefined} [arg0]
    */
    set invoice(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoiceresponseresult_invoice(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Invoice's description
    * @returns {string | undefined}
    */
    get description() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoiceresponseresult_description(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Invoice's description
    * @param {string | undefined} [arg0]
    */
    set description(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoiceresponseresult_description(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Invoice's description hash
    * @returns {string | undefined}
    */
    get description_hash() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoiceresponseresult_description_hash(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Invoice's description hash
    * @param {string | undefined} [arg0]
    */
    set description_hash(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoiceresponseresult_description_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Payment preimage
    * @returns {string | undefined}
    */
    get preimage() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoiceresponseresult_preimage(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Payment preimage
    * @param {string | undefined} [arg0]
    */
    set preimage(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoiceresponseresult_preimage(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Payment hash
    * @returns {string}
    */
    get payment_hash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoiceresponseresult_payment_hash(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Payment hash
    * @param {string} arg0
    */
    set payment_hash(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoiceresponseresult_payment_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Amount in millisatoshis
    * @returns {bigint}
    */
    get amount() {
        const ret = wasm.__wbg_get_lookupinvoiceresponseresult_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * Amount in millisatoshis
    * @param {bigint} arg0
    */
    set amount(arg0) {
        wasm.__wbg_set_lookupinvoiceresponseresult_amount(this.__wbg_ptr, arg0);
    }
    /**
    * Fees paid in millisatoshis
    * @returns {bigint}
    */
    get fees_paid() {
        const ret = wasm.__wbg_get_lookupinvoiceresponseresult_fees_paid(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * Fees paid in millisatoshis
    * @param {bigint} arg0
    */
    set fees_paid(arg0) {
        wasm.__wbg_set_lookupinvoiceresponseresult_fees_paid(this.__wbg_ptr, arg0);
    }
    /**
    * Creation timestamp in seconds since epoch
    * @returns {bigint}
    */
    get created_at() {
        const ret = wasm.__wbg_get_lookupinvoiceresponseresult_created_at(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * Creation timestamp in seconds since epoch
    * @param {bigint} arg0
    */
    set created_at(arg0) {
        wasm.__wbg_set_lookupinvoiceresponseresult_created_at(this.__wbg_ptr, arg0);
    }
    /**
    * Expiration timestamp in seconds since epoch
    * @returns {bigint}
    */
    get expires_at() {
        const ret = wasm.__wbg_get_lookupinvoiceresponseresult_expires_at(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * Expiration timestamp in seconds since epoch
    * @param {bigint} arg0
    */
    set expires_at(arg0) {
        wasm.__wbg_set_lookupinvoiceresponseresult_expires_at(this.__wbg_ptr, arg0);
    }
    /**
    * Settled timestamp in seconds since epoch
    * @returns {bigint | undefined}
    */
    get settled_at() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_listtransactionsrequestparams_from(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Settled timestamp in seconds since epoch
    * @param {bigint | undefined} [arg0]
    */
    set settled_at(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_from(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
    * Optional metadata about the payment
    * @returns {string}
    */
    get metadata() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoiceresponseresult_metadata(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Optional metadata about the payment
    * @param {string} arg0
    */
    set metadata(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoiceresponseresult_metadata(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.LookupInvoiceResponseResult = LookupInvoiceResponseResult;

const MakeInvoiceRequestParamsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_makeinvoicerequestparams_free(ptr >>> 0));
/**
* Make Invoice Request Params
*/
class MakeInvoiceRequestParams {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MakeInvoiceRequestParamsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_makeinvoicerequestparams_free(ptr);
    }
    /**
    * Amount in millisatoshis
    * @returns {bigint}
    */
    get amount() {
        const ret = wasm.__wbg_get_lookupinvoiceresponseresult_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * Amount in millisatoshis
    * @param {bigint} arg0
    */
    set amount(arg0) {
        wasm.__wbg_set_lookupinvoiceresponseresult_amount(this.__wbg_ptr, arg0);
    }
    /**
    * Invoice description
    * @returns {string | undefined}
    */
    get description() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_makeinvoicerequestparams_description(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Invoice description
    * @param {string | undefined} [arg0]
    */
    set description(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_makeinvoicerequestparams_description(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Invoice description hash
    * @returns {string | undefined}
    */
    get description_hash() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_makeinvoicerequestparams_description_hash(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Invoice description hash
    * @param {string | undefined} [arg0]
    */
    set description_hash(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_makeinvoicerequestparams_description_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Invoice expiry in seconds
    * @returns {bigint | undefined}
    */
    get expiry() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_listtransactionsrequestparams_from(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Invoice expiry in seconds
    * @param {bigint | undefined} [arg0]
    */
    set expiry(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_from(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
}
module.exports.MakeInvoiceRequestParams = MakeInvoiceRequestParams;

const MakeInvoiceResponseResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_makeinvoiceresponseresult_free(ptr >>> 0));
/**
*/
class MakeInvoiceResponseResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(MakeInvoiceResponseResult.prototype);
        obj.__wbg_ptr = ptr;
        MakeInvoiceResponseResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MakeInvoiceResponseResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_makeinvoiceresponseresult_free(ptr);
    }
    /**
    * Bolt 11 invoice
    * @returns {string}
    */
    get invoice() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_key(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Bolt 11 invoice
    * @param {string} arg0
    */
    set invoice(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_key(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Invoice's payment hash
    * @returns {string}
    */
    get payment_hash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_iv(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Invoice's payment hash
    * @param {string} arg0
    */
    set payment_hash(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_iv(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.MakeInvoiceResponseResult = MakeInvoiceResponseResult;

const MetadataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_metadata_free(ptr >>> 0));
/**
*/
class Metadata {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Metadata.prototype);
        obj.__wbg_ptr = ptr;
        MetadataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_metadata_free(ptr);
    }
    /**
    */
    constructor() {
        const ret = wasm.metadata_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @param {string} json
    * @returns {Metadata}
    */
    static fromJson(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.metadata_fromJson(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Metadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    asJson() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.metadata_asJson(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} name
    * @returns {Metadata}
    */
    name(name) {
        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.metadata_name(this.__wbg_ptr, ptr0, len0);
        return Metadata.__wrap(ret);
    }
    /**
    * @param {string} display_name
    * @returns {Metadata}
    */
    displayName(display_name) {
        const ptr0 = passStringToWasm0(display_name, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.metadata_displayName(this.__wbg_ptr, ptr0, len0);
        return Metadata.__wrap(ret);
    }
    /**
    * @param {string} about
    * @returns {Metadata}
    */
    about(about) {
        const ptr0 = passStringToWasm0(about, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.metadata_about(this.__wbg_ptr, ptr0, len0);
        return Metadata.__wrap(ret);
    }
    /**
    * @param {string} url
    * @returns {Metadata}
    */
    website(url) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.metadata_website(retptr, this.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Metadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} url
    * @returns {Metadata}
    */
    picture(url) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.metadata_picture(retptr, this.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Metadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} url
    * @returns {Metadata}
    */
    banner(url) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.metadata_banner(retptr, this.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Metadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} nip05
    * @returns {Metadata}
    */
    nip05(nip05) {
        const ptr0 = passStringToWasm0(nip05, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.metadata_nip05(this.__wbg_ptr, ptr0, len0);
        return Metadata.__wrap(ret);
    }
    /**
    * @param {string} lud06
    * @returns {Metadata}
    */
    lud06(lud06) {
        const ptr0 = passStringToWasm0(lud06, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.metadata_lud06(this.__wbg_ptr, ptr0, len0);
        return Metadata.__wrap(ret);
    }
    /**
    * @param {string} lud16
    * @returns {Metadata}
    */
    lud16(lud16) {
        const ptr0 = passStringToWasm0(lud16, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.metadata_lud16(this.__wbg_ptr, ptr0, len0);
        return Metadata.__wrap(ret);
    }
}
module.exports.Metadata = Metadata;

const MultiPayInvoiceRequestParamsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_multipayinvoicerequestparams_free(ptr >>> 0));
/**
* Multi Pay Invoice Request Params
*/
class MultiPayInvoiceRequestParams {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MultiPayInvoiceRequestParamsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_multipayinvoicerequestparams_free(ptr);
    }
    /**
    * Invoices to pay
    * @returns {(PayInvoiceRequestParams)[]}
    */
    get invoices() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_multipayinvoicerequestparams_invoices(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Invoices to pay
    * @param {(PayInvoiceRequestParams)[]} arg0
    */
    set invoices(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_multipayinvoicerequestparams_invoices(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.MultiPayInvoiceRequestParams = MultiPayInvoiceRequestParams;

const MultiPayKeysendRequestParamsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_multipaykeysendrequestparams_free(ptr >>> 0));
/**
* Multi Pay Keysend Request Params
*/
class MultiPayKeysendRequestParams {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MultiPayKeysendRequestParamsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_multipaykeysendrequestparams_free(ptr);
    }
    /**
    * Keysends
    * @returns {(PayKeysendRequestParams)[]}
    */
    get keysends() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_multipaykeysendrequestparams_keysends(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Keysends
    * @param {(PayKeysendRequestParams)[]} arg0
    */
    set keysends(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_multipaykeysendrequestparams_keysends(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.MultiPayKeysendRequestParams = MultiPayKeysendRequestParams;

const MuteListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_mutelist_free(ptr >>> 0));
/**
* Things the user doesn't want to see in their feeds
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
class MuteList {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MuteListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mutelist_free(ptr);
    }
    /**
    * @returns {(PublicKey)[]}
    */
    get public_keys() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_mutelist_public_keys(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(PublicKey)[]} arg0
    */
    set public_keys(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_mutelist_public_keys(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(string)[]}
    */
    get hashtags() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_mutelist_hashtags(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(string)[]} arg0
    */
    set hashtags(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_mutelist_hashtags(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(EventId)[]}
    */
    get event_ids() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_mutelist_event_ids(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(EventId)[]} arg0
    */
    set event_ids(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_mutelist_event_ids(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(string)[]}
    */
    get words() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_bookmarks_urls(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(string)[]} arg0
    */
    set words(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_bookmarks_urls(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.MuteList = MuteList;

const NWCFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nwc_free(ptr >>> 0));
/**
* Nostr Wallet Connect client
*/
class NWC {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NWC.prototype);
        obj.__wbg_ptr = ptr;
        NWCFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NWCFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nwc_free(ptr);
    }
    /**
    * Compose new `NWC` client
    * @param {NostrWalletConnectURI} uri
    */
    constructor(uri) {
        _assertClass(uri, NostrWalletConnectURI);
        const ret = wasm.nwc_new(uri.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Compose new `NWC` client with `NostrWalletConnectOptions`
    * @param {NostrWalletConnectURI} uri
    * @param {NostrWalletConnectOptions} opts
    * @returns {Promise<NWC>}
    */
    static withOpts(uri, opts) {
        _assertClass(uri, NostrWalletConnectURI);
        _assertClass(opts, NostrWalletConnectOptions);
        const ret = wasm.nwc_withOpts(uri.__wbg_ptr, opts.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Pay invoice
    * @param {string} invoice
    * @returns {Promise<string>}
    */
    payInvoice(invoice) {
        const ptr0 = passStringToWasm0(invoice, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nwc_payInvoice(this.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Pay keysend
    * @param {PayKeysendRequestParams} params
    * @returns {Promise<PayKeysendResponseResult>}
    */
    payKeysend(params) {
        _assertClass(params, PayKeysendRequestParams);
        const ret = wasm.nwc_payKeysend(this.__wbg_ptr, params.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Create invoice
    * @param {MakeInvoiceRequestParams} params
    * @returns {Promise<MakeInvoiceResponseResult>}
    */
    makeInvoice(params) {
        _assertClass(params, MakeInvoiceRequestParams);
        const ret = wasm.nwc_makeInvoice(this.__wbg_ptr, params.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Lookup invoice
    * @param {LookupInvoiceRequestParams} params
    * @returns {Promise<LookupInvoiceResponseResult>}
    */
    lookupInvoice(params) {
        _assertClass(params, LookupInvoiceRequestParams);
        const ret = wasm.nwc_lookupInvoice(this.__wbg_ptr, params.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * List transactions
    * @param {ListTransactionsRequestParams} params
    * @returns {Promise<LookupInvoiceResponseResult[]>}
    */
    listTransactions(params) {
        _assertClass(params, ListTransactionsRequestParams);
        const ret = wasm.nwc_listTransactions(this.__wbg_ptr, params.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Get balance
    * @returns {Promise<bigint>}
    */
    getBalance() {
        const ret = wasm.nwc_getBalance(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Get info
    * @returns {Promise<GetInfoResponseResult>}
    */
    getInfo() {
        const ret = wasm.nwc_getInfo(this.__wbg_ptr);
        return takeObject(ret);
    }
}
module.exports.NWC = NWC;

const NegentropyOptionsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_negentropyoptions_free(ptr >>> 0));
/**
*/
class NegentropyOptions {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NegentropyOptions.prototype);
        obj.__wbg_ptr = ptr;
        NegentropyOptionsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NegentropyOptionsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_negentropyoptions_free(ptr);
    }
    /**
    * New default options
    */
    constructor() {
        const ret = wasm.negentropyoptions_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Timeout to check if negentropy it's supported (default: 10 secs)
    * @param {Duration} timeout
    * @returns {NegentropyOptions}
    */
    initialTimeout(timeout) {
        const ptr = this.__destroy_into_raw();
        _assertClass(timeout, Duration);
        var ptr0 = timeout.__destroy_into_raw();
        const ret = wasm.negentropyoptions_initialTimeout(ptr, ptr0);
        return NegentropyOptions.__wrap(ret);
    }
    /**
    * Negentropy Sync direction (default: down)
    * @param {NegentropyDirection} direction
    * @returns {NegentropyOptions}
    */
    direction(direction) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.negentropyoptions_direction(ptr, direction);
        return NegentropyOptions.__wrap(ret);
    }
}
module.exports.NegentropyOptions = NegentropyOptions;

const Nip07SignerFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nip07signer_free(ptr >>> 0));
/**
* NIP07 Signer for interaction with browser extensions (ex. Alby)
*
* <https://github.com/aljazceru/awesome-nostr#nip-07-browser-extensions>
*/
class Nip07Signer {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Nip07SignerFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nip07signer_free(ptr);
    }
    /**
    */
    constructor() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nip07signer_new(retptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            this.__wbg_ptr = r0 >>> 0;
            return this;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Promise<PublicKey>}
    */
    getPublicKey() {
        const ret = wasm.nip07signer_getPublicKey(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @param {UnsignedEvent} unsigned
    * @returns {Promise<Event>}
    */
    signEvent(unsigned) {
        _assertClass(unsigned, UnsignedEvent);
        var ptr0 = unsigned.__destroy_into_raw();
        const ret = wasm.nip07signer_signEvent(this.__wbg_ptr, ptr0);
        return takeObject(ret);
    }
    /**
    * @param {PublicKey} public_key
    * @param {string} plaintext
    * @returns {Promise<string>}
    */
    nip04Encrypt(public_key, plaintext) {
        _assertClass(public_key, PublicKey);
        const ptr0 = passStringToWasm0(plaintext, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nip07signer_nip04Encrypt(this.__wbg_ptr, public_key.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * @param {PublicKey} public_key
    * @param {string} ciphertext
    * @returns {Promise<string>}
    */
    nip04Decrypt(public_key, ciphertext) {
        _assertClass(public_key, PublicKey);
        const ptr0 = passStringToWasm0(ciphertext, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nip07signer_nip04Decrypt(this.__wbg_ptr, public_key.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * @param {PublicKey} public_key
    * @param {string} plaintext
    * @returns {Promise<string>}
    */
    nip44Encrypt(public_key, plaintext) {
        _assertClass(public_key, PublicKey);
        const ptr0 = passStringToWasm0(plaintext, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nip07signer_nip44Encrypt(this.__wbg_ptr, public_key.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * @param {PublicKey} public_key
    * @param {string} ciphertext
    * @returns {Promise<string>}
    */
    nip44Decrypt(public_key, ciphertext) {
        _assertClass(public_key, PublicKey);
        const ptr0 = passStringToWasm0(ciphertext, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nip07signer_nip44Decrypt(this.__wbg_ptr, public_key.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
}
module.exports.Nip07Signer = Nip07Signer;

const Nip19EventFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nip19event_free(ptr >>> 0));
/**
*/
class Nip19Event {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Nip19Event.prototype);
        obj.__wbg_ptr = ptr;
        Nip19EventFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Nip19EventFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nip19event_free(ptr);
    }
    /**
    * @param {EventId} event_id
    * @param {PublicKey | undefined} author
    * @param {(string)[]} relays
    */
    constructor(event_id, author, relays) {
        _assertClass(event_id, EventId);
        let ptr0 = 0;
        if (!isLikeNone(author)) {
            _assertClass(author, PublicKey);
            ptr0 = author.__destroy_into_raw();
        }
        const ptr1 = passArrayJsValueToWasm0(relays, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.nip19event_new(event_id.__wbg_ptr, ptr0, ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @param {string} bech32
    * @returns {Nip19Event}
    */
    static fromBech32(bech32) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.nip19event_fromBech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Nip19Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} uri
    * @returns {Nip19Event}
    */
    static fromNostrUri(uri) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.nip19event_fromNostrUri(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Nip19Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    toBech32() {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nip19event_toBech32(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred2_0, deferred2_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    toNostrUri() {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nip19event_toNostrUri(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred2_0, deferred2_1, 1);
        }
    }
    /**
    * @returns {EventId}
    */
    eventId() {
        const ret = wasm.nip19event_eventId(this.__wbg_ptr);
        return EventId.__wrap(ret);
    }
    /**
    * @returns {PublicKey | undefined}
    */
    author() {
        const ret = wasm.nip19event_author(this.__wbg_ptr);
        return ret === 0 ? undefined : PublicKey.__wrap(ret);
    }
    /**
    * @returns {(string)[]}
    */
    relays() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nip19event_relays(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Nip19Event = Nip19Event;

const Nip19ProfileFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nip19profile_free(ptr >>> 0));
/**
*/
class Nip19Profile {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Nip19Profile.prototype);
        obj.__wbg_ptr = ptr;
        Nip19ProfileFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Nip19ProfileFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nip19profile_free(ptr);
    }
    /**
    * New NIP19 profile
    * @param {PublicKey} public_key
    * @param {(string)[]} relays
    */
    constructor(public_key, relays) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(public_key, PublicKey);
            const ptr0 = passArrayJsValueToWasm0(relays, wasm.__wbindgen_export_0);
            const len0 = WASM_VECTOR_LEN;
            wasm.nip19profile_new(retptr, public_key.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            this.__wbg_ptr = r0 >>> 0;
            return this;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} bech32
    * @returns {Nip19Profile}
    */
    static fromBech32(bech32) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.nip19profile_fromBech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Nip19Profile.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} uri
    * @returns {Nip19Profile}
    */
    static fromNostrUri(uri) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.nip19profile_fromNostrUri(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Nip19Profile.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    toBech32() {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nip19profile_toBech32(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred2_0, deferred2_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    toNostrUri() {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nip19profile_toNostrUri(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred2_0, deferred2_1, 1);
        }
    }
    /**
    * @returns {PublicKey}
    */
    publicKey() {
        const ret = wasm.liveeventhost_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {(string)[]}
    */
    relays() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nip19profile_relays(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Nip19Profile = Nip19Profile;

const Nip46SignerFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nip46signer_free(ptr >>> 0));
/**
*/
class Nip46Signer {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Nip46Signer.prototype);
        obj.__wbg_ptr = ptr;
        Nip46SignerFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Nip46SignerFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nip46signer_free(ptr);
    }
    /**
    * New NIP46 remote signer
    * @param {NostrConnectURI} uri
    * @param {Keys} app_keys
    * @param {Duration} timeout
    */
    constructor(uri, app_keys, timeout) {
        _assertClass(uri, NostrConnectURI);
        _assertClass(app_keys, Keys);
        _assertClass(timeout, Duration);
        const ret = wasm.nip46signer_new(uri.__wbg_ptr, app_keys.__wbg_ptr, timeout.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Get signer relays
    * @returns {Promise<string[]>}
    */
    relays() {
        const ret = wasm.nip46signer_relays(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Get signer public key
    * @returns {PublicKey}
    */
    signerPublicKey() {
        const ret = wasm.nip46signer_signerPublicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * Get Nostr Connect URI in **bunker** format.
    * @returns {Promise<NostrConnectURI>}
    */
    nostrConnectUri() {
        const ret = wasm.nip46signer_nostrConnectUri(this.__wbg_ptr);
        return takeObject(ret);
    }
}
module.exports.Nip46Signer = Nip46Signer;

const NostrConnectMetadataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nostrconnectmetadata_free(ptr >>> 0));
/**
*/
class NostrConnectMetadata {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NostrConnectMetadata.prototype);
        obj.__wbg_ptr = ptr;
        NostrConnectMetadataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NostrConnectMetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nostrconnectmetadata_free(ptr);
    }
    /**
    * New Nostr Connect Metadata
    * @param {string} name
    */
    constructor(name) {
        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nostrconnectmetadata_new(ptr0, len0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * URL of the website requesting the connection
    * @param {string} url
    * @returns {NostrConnectMetadata}
    */
    url(url) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.nostrconnectmetadata_url(retptr, ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NostrConnectMetadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Description of the `App`
    * @param {string} description
    * @returns {NostrConnectMetadata}
    */
    description(description) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passStringToWasm0(description, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nostrconnectmetadata_description(ptr, ptr0, len0);
        return NostrConnectMetadata.__wrap(ret);
    }
    /**
    * List of URLs for icons of the `App`
    * @param {(string)[]} icons
    * @returns {NostrConnectMetadata}
    */
    icons(icons) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(icons, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nostrconnectmetadata_icons(ptr, ptr0, len0);
        return NostrConnectMetadata.__wrap(ret);
    }
    /**
    * Serialize as JSON string
    * @returns {string}
    */
    as_json() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nostrconnectmetadata_as_json(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.NostrConnectMetadata = NostrConnectMetadata;

const NostrConnectURIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nostrconnecturi_free(ptr >>> 0));
/**
*/
class NostrConnectURI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NostrConnectURI.prototype);
        obj.__wbg_ptr = ptr;
        NostrConnectURIFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NostrConnectURIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nostrconnecturi_free(ptr);
    }
    /**
    * @param {string} uri
    * @returns {NostrConnectURI}
    */
    static parse(uri) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.nostrconnecturi_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NostrConnectURI.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    asString() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nostrconnecturi_asString(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.NostrConnectURI = NostrConnectURI;

const NostrDatabaseFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nostrdatabase_free(ptr >>> 0));
/**
* Nostr Database
*/
class NostrDatabase {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NostrDatabase.prototype);
        obj.__wbg_ptr = ptr;
        NostrDatabaseFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NostrDatabaseFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nostrdatabase_free(ptr);
    }
    /**
    * Open IndexedDB database
    *
    * If not exists, create it.
    * @param {string} name
    * @returns {Promise<NostrDatabase>}
    */
    static indexeddb(name) {
        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nostrdatabase_indexeddb(ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Save `Event` into store
    *
    * Return `true` if event was successfully saved into database.
    *
    * **This method assume that `Event` was already verified**
    * @param {Event} event
    * @returns {Promise<boolean>}
    */
    save_event(event) {
        _assertClass(event, Event);
        const ret = wasm.nostrdatabase_save_event(this.__wbg_ptr, event.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Get list of relays that have seen the [`EventId`]
    * @param {EventId} event_id
    * @returns {Promise<string[] | undefined>}
    */
    eventSeenOnRelays(event_id) {
        _assertClass(event_id, EventId);
        const ret = wasm.nostrdatabase_eventSeenOnRelays(this.__wbg_ptr, event_id.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Get [`Event`] by [`EventId`]
    * @param {EventId} event_id
    * @returns {Promise<Event>}
    */
    eventById(event_id) {
        _assertClass(event_id, EventId);
        const ret = wasm.nostrdatabase_eventById(this.__wbg_ptr, event_id.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @param {(Filter)[]} filters
    * @returns {Promise<bigint>}
    */
    count(filters) {
        const ptr0 = passArrayJsValueToWasm0(filters, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nostrdatabase_count(this.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * @param {(Filter)[]} filters
    * @returns {Promise<Event[]>}
    */
    query(filters) {
        const ptr0 = passArrayJsValueToWasm0(filters, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nostrdatabase_query(this.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Wipe all data
    * @returns {Promise<void>}
    */
    wipe() {
        const ret = wasm.nostrdatabase_wipe(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @param {PublicKey} public_key
    * @returns {Promise<Profile>}
    */
    profile(public_key) {
        _assertClass(public_key, PublicKey);
        const ret = wasm.nostrdatabase_profile(this.__wbg_ptr, public_key.__wbg_ptr);
        return takeObject(ret);
    }
}
module.exports.NostrDatabase = NostrDatabase;

const NostrLibraryFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nostrlibrary_free(ptr >>> 0));
/**
*/
class NostrLibrary {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NostrLibraryFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nostrlibrary_free(ptr);
    }
    /**
    */
    constructor() {
        const ret = wasm.nostrlibrary_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @returns {string | undefined}
    */
    gitHashVersion() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nostrlibrary_gitHashVersion(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.NostrLibrary = NostrLibrary;

const NostrSignerFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nostrsigner_free(ptr >>> 0));
/**
*/
class NostrSigner {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NostrSigner.prototype);
        obj.__wbg_ptr = ptr;
        NostrSignerFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NostrSignerFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nostrsigner_free(ptr);
    }
    /**
    * Private keys
    * @param {Keys} keys
    * @returns {NostrSigner}
    */
    static keys(keys) {
        _assertClass(keys, Keys);
        const ret = wasm.nostrsigner_keys(keys.__wbg_ptr);
        return NostrSigner.__wrap(ret);
    }
    /**
    * NIP07
    * @param {Nip07Signer} signer
    * @returns {NostrSigner}
    */
    static nip07(signer) {
        _assertClass(signer, Nip07Signer);
        const ret = wasm.nostrsigner_nip07(signer.__wbg_ptr);
        return NostrSigner.__wrap(ret);
    }
    /**
    * NIP46
    * @param {Nip46Signer} signer
    * @returns {NostrSigner}
    */
    static nip46(signer) {
        _assertClass(signer, Nip46Signer);
        const ret = wasm.nostrsigner_nip46(signer.__wbg_ptr);
        return NostrSigner.__wrap(ret);
    }
    /**
    * Get signer public key
    * @returns {Promise<PublicKey>}
    */
    publicKey() {
        const ret = wasm.nostrsigner_publicKey(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @param {EventBuilder} builder
    * @returns {Promise<Event>}
    */
    signEventBuilder(builder) {
        _assertClass(builder, EventBuilder);
        const ret = wasm.nostrsigner_signEventBuilder(this.__wbg_ptr, builder.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @param {UnsignedEvent} unsigned
    * @returns {Promise<Event>}
    */
    signEvent(unsigned) {
        _assertClass(unsigned, UnsignedEvent);
        const ret = wasm.nostrsigner_signEvent(this.__wbg_ptr, unsigned.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @param {PublicKey} public_key
    * @param {string} content
    * @returns {Promise<string>}
    */
    nip04Encrypt(public_key, content) {
        _assertClass(public_key, PublicKey);
        const ptr0 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nostrsigner_nip04Encrypt(this.__wbg_ptr, public_key.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * @param {PublicKey} public_key
    * @param {string} encrypted_content
    * @returns {Promise<string>}
    */
    nip04Decrypt(public_key, encrypted_content) {
        _assertClass(public_key, PublicKey);
        const ptr0 = passStringToWasm0(encrypted_content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nostrsigner_nip04Decrypt(this.__wbg_ptr, public_key.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * @param {PublicKey} public_key
    * @param {string} content
    * @returns {Promise<string>}
    */
    nip44Encrypt(public_key, content) {
        _assertClass(public_key, PublicKey);
        const ptr0 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nostrsigner_nip44Encrypt(this.__wbg_ptr, public_key.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * @param {PublicKey} public_key
    * @param {string} content
    * @returns {Promise<string>}
    */
    nip44Decrypt(public_key, content) {
        _assertClass(public_key, PublicKey);
        const ptr0 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nostrsigner_nip44Decrypt(this.__wbg_ptr, public_key.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
}
module.exports.NostrSigner = NostrSigner;

const NostrWalletConnectOptionsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nostrwalletconnectoptions_free(ptr >>> 0));
/**
* NWC options
*/
class NostrWalletConnectOptions {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NostrWalletConnectOptions.prototype);
        obj.__wbg_ptr = ptr;
        NostrWalletConnectOptionsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NostrWalletConnectOptionsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nostrwalletconnectoptions_free(ptr);
    }
    /**
    * New default NWC options
    */
    constructor() {
        const ret = wasm.nostrwalletconnectoptions_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Set NWC requests timeout (default: 10 secs)
    * @param {Duration} timeout
    * @returns {NostrWalletConnectOptions}
    */
    timeout(timeout) {
        const ptr = this.__destroy_into_raw();
        _assertClass(timeout, Duration);
        const ret = wasm.nostrwalletconnectoptions_timeout(ptr, timeout.__wbg_ptr);
        return NostrWalletConnectOptions.__wrap(ret);
    }
}
module.exports.NostrWalletConnectOptions = NostrWalletConnectOptions;

const NostrWalletConnectURIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nostrwalletconnecturi_free(ptr >>> 0));
/**
*/
class NostrWalletConnectURI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NostrWalletConnectURI.prototype);
        obj.__wbg_ptr = ptr;
        NostrWalletConnectURIFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NostrWalletConnectURIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nostrwalletconnecturi_free(ptr);
    }
    /**
    * Create new Nostr Wallet Connect URI
    * @param {PublicKey} public_key
    * @param {string} relay_url
    * @param {SecretKey} random_secret_key
    * @param {string | undefined} [lud16]
    */
    constructor(public_key, relay_url, random_secret_key, lud16) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(public_key, PublicKey);
            const ptr0 = passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            _assertClass(random_secret_key, SecretKey);
            var ptr1 = isLikeNone(lud16) ? 0 : passStringToWasm0(lud16, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            var len1 = WASM_VECTOR_LEN;
            wasm.nostrwalletconnecturi_new(retptr, public_key.__wbg_ptr, ptr0, len0, random_secret_key.__wbg_ptr, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            this.__wbg_ptr = r0 >>> 0;
            return this;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Parse
    * @param {string} uri
    * @returns {NostrWalletConnectURI}
    */
    static parse(uri) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.nostrwalletconnecturi_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NostrWalletConnectURI.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * App Pubkey
    * @returns {PublicKey}
    */
    publicKey() {
        const ret = wasm.nostrwalletconnecturi_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * URL of the relay of choice where the `App` is connected and the `Signer` must send and listen for messages.
    * @returns {string}
    */
    relayUrl() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nostrwalletconnecturi_relayUrl(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * 32-byte randomly generated hex encoded string
    * @returns {SecretKey}
    */
    secret() {
        const ret = wasm.nostrwalletconnecturi_secret(this.__wbg_ptr);
        return SecretKey.__wrap(ret);
    }
    /**
    * A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured.
    * @returns {string | undefined}
    */
    lud16() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nostrwalletconnecturi_lud16(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    asString() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nostrwalletconnecturi_asString(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.NostrWalletConnectURI = NostrWalletConnectURI;

const NostrZapperFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nostrzapper_free(ptr >>> 0));
/**
* Nostr Zapper
*/
class NostrZapper {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NostrZapper.prototype);
        obj.__wbg_ptr = ptr;
        NostrZapperFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NostrZapperFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nostrzapper_free(ptr);
    }
    /**
    * Create new `WebLN` instance and compose `NostrZapper`
    * @returns {Promise<NostrZapper>}
    */
    static webln() {
        const ret = wasm.nostrzapper_webln();
        return takeObject(ret);
    }
    /**
    * @param {NostrWalletConnectURI} uri
    * @returns {Promise<NostrZapper>}
    */
    static nwc(uri) {
        _assertClass(uri, NostrWalletConnectURI);
        const ret = wasm.nostrzapper_nwc(uri.__wbg_ptr);
        return takeObject(ret);
    }
}
module.exports.NostrZapper = NostrZapper;

const OptionsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_options_free(ptr >>> 0));
/**
*/
class Options {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Options.prototype);
        obj.__wbg_ptr = ptr;
        OptionsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        OptionsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_options_free(ptr);
    }
    /**
    */
    constructor() {
        const ret = wasm.options_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @param {boolean} wait
    * @returns {Options}
    */
    waitForSend(wait) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.options_waitForSend(ptr, wait);
        return Options.__wrap(ret);
    }
    /**
    * @param {boolean} wait
    * @returns {Options}
    */
    waitForSubscription(wait) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.options_waitForSubscription(ptr, wait);
        return Options.__wrap(ret);
    }
    /**
    * @param {number} difficulty
    * @returns {Options}
    */
    difficulty(difficulty) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.options_difficulty(ptr, difficulty);
        return Options.__wrap(ret);
    }
    /**
    * Minimum POW difficulty for received events
    * @param {number} difficulty
    * @returns {Options}
    */
    minPow(difficulty) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.options_minPow(ptr, difficulty);
        return Options.__wrap(ret);
    }
    /**
    * @param {number} req_filters_chunk_size
    * @returns {Options}
    */
    reqFiltersChunkSize(req_filters_chunk_size) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.options_reqFiltersChunkSize(ptr, req_filters_chunk_size);
        return Options.__wrap(ret);
    }
    /**
    * @param {boolean} skip
    * @returns {Options}
    */
    skipDisconnectedRelays(skip) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.options_skipDisconnectedRelays(ptr, skip);
        return Options.__wrap(ret);
    }
    /**
    * @param {Duration} timeout
    * @returns {Options}
    */
    timeout(timeout) {
        const ptr = this.__destroy_into_raw();
        _assertClass(timeout, Duration);
        const ret = wasm.options_timeout(ptr, timeout.__wbg_ptr);
        return Options.__wrap(ret);
    }
    /**
    * Connection timeout (default: None)
    *
    * If set to `None`, the client will try to connect to the relays without waiting.
    * @param {Duration | undefined} [connection_timeout]
    * @returns {Options}
    */
    connectionTimeout(connection_timeout) {
        const ptr = this.__destroy_into_raw();
        let ptr0 = 0;
        if (!isLikeNone(connection_timeout)) {
            _assertClass(connection_timeout, Duration);
            ptr0 = connection_timeout.__destroy_into_raw();
        }
        const ret = wasm.options_connectionTimeout(ptr, ptr0);
        return Options.__wrap(ret);
    }
    /**
    * @param {Duration | undefined} [send_timeout]
    * @returns {Options}
    */
    sendTimeout(send_timeout) {
        const ptr = this.__destroy_into_raw();
        let ptr0 = 0;
        if (!isLikeNone(send_timeout)) {
            _assertClass(send_timeout, Duration);
            ptr0 = send_timeout.__destroy_into_raw();
        }
        const ret = wasm.options_sendTimeout(ptr, ptr0);
        return Options.__wrap(ret);
    }
    /**
    * Set custom relay limits
    * @param {RelayLimits} limits
    * @returns {Options}
    */
    relayLimits(limits) {
        const ptr = this.__destroy_into_raw();
        _assertClass(limits, RelayLimits);
        const ret = wasm.options_relayLimits(ptr, limits.__wbg_ptr);
        return Options.__wrap(ret);
    }
}
module.exports.Options = Options;

const PayInvoiceRequestParamsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_payinvoicerequestparams_free(ptr >>> 0));
/**
* Pay Invoice Request Params
*/
class PayInvoiceRequestParams {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PayInvoiceRequestParams.prototype);
        obj.__wbg_ptr = ptr;
        PayInvoiceRequestParamsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof PayInvoiceRequestParams)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PayInvoiceRequestParamsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_payinvoicerequestparams_free(ptr);
    }
    /**
    * Optional id
    * @returns {string | undefined}
    */
    get id() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_payinvoicerequestparams_id(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Optional id
    * @param {string | undefined} [arg0]
    */
    set id(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_payinvoicerequestparams_id(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Request invoice
    * @returns {string}
    */
    get invoice() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_payinvoicerequestparams_invoice(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Request invoice
    * @param {string} arg0
    */
    set invoice(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_payinvoicerequestparams_invoice(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Optional amount in millisatoshis
    * @returns {bigint | undefined}
    */
    get amount() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_listtransactionsrequestparams_from(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Optional amount in millisatoshis
    * @param {bigint | undefined} [arg0]
    */
    set amount(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_from(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
}
module.exports.PayInvoiceRequestParams = PayInvoiceRequestParams;

const PayInvoiceResponseResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_payinvoiceresponseresult_free(ptr >>> 0));
/**
*/
class PayInvoiceResponseResult {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PayInvoiceResponseResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_payinvoiceresponseresult_free(ptr);
    }
    /**
    * Response preimage
    * @returns {string}
    */
    get preimage() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_key(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Response preimage
    * @param {string} arg0
    */
    set preimage(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_key(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.PayInvoiceResponseResult = PayInvoiceResponseResult;

const PayKeysendRequestParamsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_paykeysendrequestparams_free(ptr >>> 0));
/**
* Pay Invoice Request Params
*/
class PayKeysendRequestParams {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PayKeysendRequestParams.prototype);
        obj.__wbg_ptr = ptr;
        PayKeysendRequestParamsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof PayKeysendRequestParams)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PayKeysendRequestParamsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_paykeysendrequestparams_free(ptr);
    }
    /**
    * Optional id
    * @returns {string | undefined}
    */
    get id() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_paykeysendrequestparams_id(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Optional id
    * @param {string | undefined} [arg0]
    */
    set id(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_paykeysendrequestparams_id(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Amount in millisatoshis
    * @returns {bigint}
    */
    get amount() {
        const ret = wasm.__wbg_get_getbalanceresponseresult_balance(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * Amount in millisatoshis
    * @param {bigint} arg0
    */
    set amount(arg0) {
        wasm.__wbg_set_getbalanceresponseresult_balance(this.__wbg_ptr, arg0);
    }
    /**
    * Receiver's node id
    * @returns {string}
    */
    get pubkey() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_keysendtlvrecord_value(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Receiver's node id
    * @param {string} arg0
    */
    set pubkey(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_keysendtlvrecord_value(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Optional preimage
    * @returns {string | undefined}
    */
    get preimage() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_paykeysendrequestparams_preimage(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Optional preimage
    * @param {string | undefined} [arg0]
    */
    set preimage(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_paykeysendrequestparams_preimage(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Optional TLVs to be added to the keysend payment
    * @returns {(KeysendTLVRecord)[]}
    */
    get tlv_records() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_paykeysendrequestparams_tlv_records(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Optional TLVs to be added to the keysend payment
    * @param {(KeysendTLVRecord)[]} arg0
    */
    set tlv_records(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_paykeysendrequestparams_tlv_records(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.PayKeysendRequestParams = PayKeysendRequestParams;

const PayKeysendResponseResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_paykeysendresponseresult_free(ptr >>> 0));
/**
*/
class PayKeysendResponseResult {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PayKeysendResponseResult.prototype);
        obj.__wbg_ptr = ptr;
        PayKeysendResponseResultFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PayKeysendResponseResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_paykeysendresponseresult_free(ptr);
    }
    /**
    * Response preimage
    * @returns {string}
    */
    get preimage() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_key(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Response preimage
    * @param {string} arg0
    */
    set preimage(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_key(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.PayKeysendResponseResult = PayKeysendResponseResult;

const ProductDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_productdata_free(ptr >>> 0));
/**
*/
class ProductData {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProductDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_productdata_free(ptr);
    }
    /**
    * @param {string} id
    * @param {string} stall_id
    * @param {string} name
    * @param {string} currency
    */
    constructor(id, stall_id, name, currency) {
        const ptr0 = passStringToWasm0(id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(stall_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passStringToWasm0(name, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len2 = WASM_VECTOR_LEN;
        const ptr3 = passStringToWasm0(currency, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len3 = WASM_VECTOR_LEN;
        const ret = wasm.productdata_new(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @returns {string}
    */
    get id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_id(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    get stallId() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_stallId(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    get name() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_name(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get description() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_description(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {(string)[] | undefined}
    */
    get images() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_images(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getArrayJsValueFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    get currency() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_currency(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {number}
    */
    get price() {
        const ret = wasm.productdata_price(this.__wbg_ptr);
        return ret;
    }
    /**
    * @returns {number}
    */
    get quantity() {
        const ret = wasm.productdata_quantity(this.__wbg_ptr);
        return ret;
    }
    /**
    * @returns {(string[])[] | undefined}
    */
    get specs() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_specs(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getArrayJsValueFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {(ShippingCost)[]}
    */
    get shipping() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_shipping(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {(string)[] | undefined}
    */
    get categories() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_categories(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getArrayJsValueFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.ProductData = ProductData;

const ProfileFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_profile_free(ptr >>> 0));
/**
*/
class Profile {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Profile.prototype);
        obj.__wbg_ptr = ptr;
        ProfileFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProfileFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_profile_free(ptr);
    }
    /**
    * Compose new profile
    * @param {PublicKey} public_key
    * @param {Metadata} metadata
    */
    constructor(public_key, metadata) {
        _assertClass(public_key, PublicKey);
        _assertClass(metadata, Metadata);
        const ret = wasm.profile_new(public_key.__wbg_ptr, metadata.__wbg_ptr);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Get profile public key
    * @returns {PublicKey}
    */
    public_key() {
        const ret = wasm.profile_public_key(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * Get profile metadata
    * @returns {Metadata}
    */
    metadata() {
        const ret = wasm.profile_metadata(this.__wbg_ptr);
        return Metadata.__wrap(ret);
    }
    /**
    * Get profile name
    *
    * Steps (go to next step if field is `None` or `empty`):
    * * Check `display_name` field
    * * Check `name` field
    * * Return cutted public key (ex. `00000000:00000002`)
    * @returns {string}
    */
    name() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.profile_name(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.Profile = Profile;

const PublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_publickey_free(ptr >>> 0));
/**
*/
class PublicKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PublicKey.prototype);
        obj.__wbg_ptr = ptr;
        PublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof PublicKey)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_publickey_free(ptr);
    }
    /**
    * Try to parse public key from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
    * @param {string} public_key
    * @returns {PublicKey}
    */
    static parse(public_key) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(public_key, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.publickey_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PublicKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} hex
    * @returns {PublicKey}
    */
    static fromHex(hex) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.publickey_fromHex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PublicKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} bech32
    * @returns {PublicKey}
    */
    static fromBech32(bech32) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.publickey_fromBech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PublicKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Get in hex format
    * @returns {string}
    */
    toHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.publickey_toHex(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Get in bech32 format
    * @returns {string}
    */
    toBech32() {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.publickey_toBech32(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred2_0, deferred2_1, 1);
        }
    }
}
module.exports.PublicKey = PublicKey;

const RelayFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_relay_free(ptr >>> 0));
/**
*/
class Relay {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Relay.prototype);
        obj.__wbg_ptr = ptr;
        RelayFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RelayFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_relay_free(ptr);
    }
    /**
    * Get relay url
    * @returns {string}
    */
    url() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relay_url(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {Promise<RelayStatus>}
    */
    status() {
        const ret = wasm.relay_status(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Get Relay Service Flags
    * @returns {AtomicRelayServiceFlags}
    */
    flags() {
        const ret = wasm.relay_flags(this.__wbg_ptr);
        return AtomicRelayServiceFlags.__wrap(ret);
    }
    /**
    * Check if relay is connected
    * @returns {Promise<boolean>}
    */
    isConnected() {
        const ret = wasm.relay_isConnected(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * Get `RelayInformationDocument`
    * @returns {Promise<RelayInformationDocument>}
    */
    document() {
        const ret = wasm.relay_document(this.__wbg_ptr);
        return takeObject(ret);
    }
}
module.exports.Relay = Relay;

const RelayInformationDocumentFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_relayinformationdocument_free(ptr >>> 0));
/**
*/
class RelayInformationDocument {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RelayInformationDocument.prototype);
        obj.__wbg_ptr = ptr;
        RelayInformationDocumentFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RelayInformationDocumentFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_relayinformationdocument_free(ptr);
    }
    /**
    */
    constructor() {
        const ret = wasm.relayinformationdocument_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @param {string} url
    * @returns {Promise<RelayInformationDocument>}
    */
    static get(url) {
        const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relayinformationdocument_get(ptr0, len0);
        return takeObject(ret);
    }
    /**
    * @returns {string | undefined}
    */
    get name() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relayinformationdocument_name(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get description() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relayinformationdocument_description(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get pubkey() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relayinformationdocument_pubkey(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get contact() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relayinformationdocument_contact(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint16Array | undefined}
    */
    get supported_nips() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relayinformationdocument_supported_nips(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getArrayU16FromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 2, 2);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get software() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relayinformationdocument_software(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get version() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relayinformationdocument_version(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.RelayInformationDocument = RelayInformationDocument;

const RelayLimitsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_relaylimits_free(ptr >>> 0));
/**
* Relay Limits
*/
class RelayLimits {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RelayLimits.prototype);
        obj.__wbg_ptr = ptr;
        RelayLimitsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RelayLimitsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_relaylimits_free(ptr);
    }
    /**
    * Construct with default limits
    */
    constructor() {
        const ret = wasm.relaylimits_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Disable all limits
    * @returns {RelayLimits}
    */
    static disable() {
        const ret = wasm.relaylimits_disable();
        return RelayLimits.__wrap(ret);
    }
    /**
    * Maximum size of normalised JSON, in bytes (default: 5_250_000)
    * @param {number | undefined} [max_size]
    * @returns {RelayLimits}
    */
    messageMaxSize(max_size) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.relaylimits_messageMaxSize(ptr, !isLikeNone(max_size), isLikeNone(max_size) ? 0 : max_size);
        return RelayLimits.__wrap(ret);
    }
    /**
    * Maximum size of normalised JSON, in bytes (default: 70_000)
    * @param {number | undefined} [max_size]
    * @returns {RelayLimits}
    */
    eventMaxSize(max_size) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.relaylimits_eventMaxSize(ptr, !isLikeNone(max_size), isLikeNone(max_size) ? 0 : max_size);
        return RelayLimits.__wrap(ret);
    }
    /**
    * Maximum number of tags allowed (default: 2_000)
    * @param {number | undefined} [max_num_tags]
    * @returns {RelayLimits}
    */
    eventMaxNumTags(max_num_tags) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.relaylimits_eventMaxNumTags(ptr, isLikeNone(max_num_tags) ? 0xFFFFFF : max_num_tags);
        return RelayLimits.__wrap(ret);
    }
}
module.exports.RelayLimits = RelayLimits;

const RelayListItemFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_relaylistitem_free(ptr >>> 0));
/**
*/
class RelayListItem {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RelayListItem.prototype);
        obj.__wbg_ptr = ptr;
        RelayListItemFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof RelayListItem)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RelayListItemFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_relaylistitem_free(ptr);
    }
    /**
    * @returns {string}
    */
    get url() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_key(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} arg0
    */
    set url(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_key(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {RelayMetadata | undefined}
    */
    get metadata() {
        const ret = wasm.__wbg_get_relaylistitem_metadata(this.__wbg_ptr);
        return ret === 2 ? undefined : ret;
    }
    /**
    * @param {RelayMetadata | undefined} [arg0]
    */
    set metadata(arg0) {
        wasm.__wbg_set_relaylistitem_metadata(this.__wbg_ptr, isLikeNone(arg0) ? 2 : arg0);
    }
    /**
    * @param {string} url
    * @param {RelayMetadata | undefined} [metadata]
    */
    constructor(url, metadata) {
        const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relaylistitem_new(ptr0, len0, isLikeNone(metadata) ? 2 : metadata);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
}
module.exports.RelayListItem = RelayListItem;

const RelayMessageFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_relaymessage_free(ptr >>> 0));
/**
*/
class RelayMessage {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RelayMessage.prototype);
        obj.__wbg_ptr = ptr;
        RelayMessageFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RelayMessageFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_relaymessage_free(ptr);
    }
    /**
    * Create new `EVENT` message
    * @param {string} subscription_id
    * @param {Event} event
    * @returns {RelayMessage}
    */
    static event(subscription_id, event) {
        const ptr0 = passStringToWasm0(subscription_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(event, Event);
        const ret = wasm.relaymessage_event(ptr0, len0, event.__wbg_ptr);
        return RelayMessage.__wrap(ret);
    }
    /**
    * Create new `NOTICE` message
    * @param {string} message
    * @returns {RelayMessage}
    */
    static notice(message) {
        const ptr0 = passStringToWasm0(message, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relaymessage_notice(ptr0, len0);
        return RelayMessage.__wrap(ret);
    }
    /**
    * Create new `CLOSED` message
    * @param {string} subscription_id
    * @param {string} message
    * @returns {RelayMessage}
    */
    static closed(subscription_id, message) {
        const ptr0 = passStringToWasm0(subscription_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(message, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.relaymessage_closed(ptr0, len0, ptr1, len1);
        return RelayMessage.__wrap(ret);
    }
    /**
    * Create new `EOSE` message
    * @param {string} subscription_id
    * @returns {RelayMessage}
    */
    static eose(subscription_id) {
        const ptr0 = passStringToWasm0(subscription_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relaymessage_eose(ptr0, len0);
        return RelayMessage.__wrap(ret);
    }
    /**
    * Create new `OK` message
    * @param {EventId} event_id
    * @param {boolean} status
    * @param {string} message
    * @returns {RelayMessage}
    */
    static ok(event_id, status, message) {
        _assertClass(event_id, EventId);
        const ptr0 = passStringToWasm0(message, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relaymessage_ok(event_id.__wbg_ptr, status, ptr0, len0);
        return RelayMessage.__wrap(ret);
    }
    /**
    * Create new `AUTH` message
    * @param {string} challenge
    * @returns {RelayMessage}
    */
    static auth(challenge) {
        const ptr0 = passStringToWasm0(challenge, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relaymessage_auth(ptr0, len0);
        return RelayMessage.__wrap(ret);
    }
    /**
    * Create new `EVENT` message
    * @param {string} subscription_id
    * @param {number} count
    * @returns {RelayMessage}
    */
    static count(subscription_id, count) {
        const ptr0 = passStringToWasm0(subscription_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relaymessage_count(ptr0, len0, count);
        return RelayMessage.__wrap(ret);
    }
    /**
    * Deserialize `RelayMessage` from JSON string
    *
    * **This method NOT verify the event signature!**
    * @param {string} json
    * @returns {RelayMessage}
    */
    static fromJson(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.relaymessage_fromJson(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return RelayMessage.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    asJson() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relaymessage_asJson(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.RelayMessage = RelayMessage;

const RelayServiceFlagsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_relayserviceflags_free(ptr >>> 0));
/**
*/
class RelayServiceFlags {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RelayServiceFlags.prototype);
        obj.__wbg_ptr = ptr;
        RelayServiceFlagsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RelayServiceFlagsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_relayserviceflags_free(ptr);
    }
    /**
    */
    constructor() {
        const ret = wasm.relayserviceflags_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Default flags: `READ`, `WRITE` and `PING`
    * @returns {RelayServiceFlags}
    */
    static default() {
        const ret = wasm.relayserviceflags_default();
        return RelayServiceFlags.__wrap(ret);
    }
    /**
    * @returns {RelayServiceFlags}
    */
    static read() {
        const ret = wasm.relayserviceflags_read();
        return RelayServiceFlags.__wrap(ret);
    }
    /**
    * @returns {RelayServiceFlags}
    */
    static write() {
        const ret = wasm.relayserviceflags_write();
        return RelayServiceFlags.__wrap(ret);
    }
    /**
    * @returns {RelayServiceFlags}
    */
    static ping() {
        const ret = wasm.relayserviceflags_ping();
        return RelayServiceFlags.__wrap(ret);
    }
    /**
    * Add `RelayServiceFlags` together.
    * @param {RelayServiceFlags} other
    * @returns {RelayServiceFlags}
    */
    add(other) {
        _assertClass(other, RelayServiceFlags);
        const ret = wasm.relayserviceflags_add(this.__wbg_ptr, other.__wbg_ptr);
        return RelayServiceFlags.__wrap(ret);
    }
    /**
    * Remove `RelayServiceFlags` from this.
    * @param {RelayServiceFlags} other
    * @returns {RelayServiceFlags}
    */
    remove(other) {
        _assertClass(other, RelayServiceFlags);
        const ret = wasm.relayserviceflags_remove(this.__wbg_ptr, other.__wbg_ptr);
        return RelayServiceFlags.__wrap(ret);
    }
}
module.exports.RelayServiceFlags = RelayServiceFlags;

const SecretKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_secretkey_free(ptr >>> 0));
/**
*/
class SecretKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SecretKey.prototype);
        obj.__wbg_ptr = ptr;
        SecretKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SecretKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_secretkey_free(ptr);
    }
    /**
    * Try to parse secret key from `hex` or `bech32`
    * @param {string} secret_key
    * @returns {SecretKey}
    */
    static parse(secret_key) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(secret_key, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.secretkey_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SecretKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} hex
    * @returns {SecretKey}
    */
    static fromHex(hex) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.secretkey_fromHex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SecretKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} bech32
    * @returns {SecretKey}
    */
    static fromBech32(bech32) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.secretkey_fromBech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SecretKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    toHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.secretkey_toHex(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    toBech32() {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.secretkey_toBech32(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred2_0, deferred2_1, 1);
        }
    }
    /**
    * Encrypt secret key
    *
    * By default `LOG_N` is set to `16` and `KeySecurity` to `Unknown`.
    * To use custom values check `EncryptedSecretKey` constructor.
    * @param {string} password
    * @returns {EncryptedSecretKey}
    */
    encrypt(password) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(password, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.secretkey_encrypt(retptr, this.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EncryptedSecretKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.SecretKey = SecretKey;

const ShippingCostFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_shippingcost_free(ptr >>> 0));
/**
*/
class ShippingCost {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ShippingCost.prototype);
        obj.__wbg_ptr = ptr;
        ShippingCostFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ShippingCostFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_shippingcost_free(ptr);
    }
    /**
    * @returns {string}
    */
    get id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.shippingcost_id(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {number}
    */
    get cost() {
        const ret = wasm.productdata_price(this.__wbg_ptr);
        return ret;
    }
}
module.exports.ShippingCost = ShippingCost;

const ShippingMethodFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_shippingmethod_free(ptr >>> 0));
/**
*/
class ShippingMethod {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ShippingMethod.prototype);
        obj.__wbg_ptr = ptr;
        ShippingMethodFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ShippingMethodFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_shippingmethod_free(ptr);
    }
    /**
    * @param {string} id
    * @param {number} cost
    */
    constructor(id, cost) {
        const ptr0 = passStringToWasm0(id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.shippingmethod_new(ptr0, len0, cost);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @returns {ShippingCost}
    */
    getShippingCost() {
        const ret = wasm.shippingmethod_getShippingCost(this.__wbg_ptr);
        return ShippingCost.__wrap(ret);
    }
    /**
    * @returns {string}
    */
    get id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.shippingcost_id(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get name() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.shippingmethod_name(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {number}
    */
    get cost() {
        const ret = wasm.productdata_price(this.__wbg_ptr);
        return ret;
    }
    /**
    * @returns {(string)[]}
    */
    get regions() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.shippingmethod_regions(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.ShippingMethod = ShippingMethod;

const SingleLetterTagFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_singlelettertag_free(ptr >>> 0));
/**
*/
class SingleLetterTag {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SingleLetterTag.prototype);
        obj.__wbg_ptr = ptr;
        SingleLetterTagFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SingleLetterTagFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_singlelettertag_free(ptr);
    }
    /**
    * @param {Alphabet} character
    * @returns {SingleLetterTag}
    */
    static lowercase(character) {
        const ret = wasm.singlelettertag_lowercase(character);
        return SingleLetterTag.__wrap(ret);
    }
    /**
    * @param {Alphabet} character
    * @returns {SingleLetterTag}
    */
    static uppercase(character) {
        const ret = wasm.singlelettertag_uppercase(character);
        return SingleLetterTag.__wrap(ret);
    }
    /**
    * @returns {boolean}
    */
    isLowercase() {
        const ret = wasm.singlelettertag_isLowercase(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * @returns {boolean}
    */
    isUppercase() {
        const ret = wasm.singlelettertag_isUppercase(this.__wbg_ptr);
        return ret !== 0;
    }
}
module.exports.SingleLetterTag = SingleLetterTag;

const StallDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_stalldata_free(ptr >>> 0));
/**
*/
class StallData {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StallDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stalldata_free(ptr);
    }
    /**
    * @param {string} id
    * @param {string} name
    * @param {string} currency
    */
    constructor(id, name, currency) {
        const ptr0 = passStringToWasm0(id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(name, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passStringToWasm0(currency, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len2 = WASM_VECTOR_LEN;
        const ret = wasm.stalldata_new(ptr0, len0, ptr1, len1, ptr2, len2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @returns {string}
    */
    get id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stalldata_id(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    get name() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stalldata_name(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get description() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stalldata_description(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    get currency() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stalldata_currency(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {(ShippingMethod)[]}
    */
    get shipping() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stalldata_shipping(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.StallData = StallData;

const SubscribeAutoCloseOptionsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_subscribeautocloseoptions_free(ptr >>> 0));
/**
* Auto-closing subscribe options
*/
class SubscribeAutoCloseOptions {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SubscribeAutoCloseOptions.prototype);
        obj.__wbg_ptr = ptr;
        SubscribeAutoCloseOptionsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SubscribeAutoCloseOptionsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_subscribeautocloseoptions_free(ptr);
    }
    /**
    */
    constructor() {
        const ret = wasm.subscribeautocloseoptions_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Close subscription when `FilterOptions` is satisfied
    * @param {FilterOptions} filter
    * @returns {SubscribeAutoCloseOptions}
    */
    filter(filter) {
        const ptr = this.__destroy_into_raw();
        _assertClass(filter, FilterOptions);
        var ptr0 = filter.__destroy_into_raw();
        const ret = wasm.subscribeautocloseoptions_filter(ptr, ptr0);
        return SubscribeAutoCloseOptions.__wrap(ret);
    }
    /**
    * Automatically close subscription after `Duration`
    * @param {Duration | undefined} [timeout]
    * @returns {SubscribeAutoCloseOptions}
    */
    timeout(timeout) {
        const ptr = this.__destroy_into_raw();
        let ptr0 = 0;
        if (!isLikeNone(timeout)) {
            _assertClass(timeout, Duration);
            ptr0 = timeout.__destroy_into_raw();
        }
        const ret = wasm.subscribeautocloseoptions_timeout(ptr, ptr0);
        return SubscribeAutoCloseOptions.__wrap(ret);
    }
}
module.exports.SubscribeAutoCloseOptions = SubscribeAutoCloseOptions;

const SubscribeOptionsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_subscribeoptions_free(ptr >>> 0));
/**
* Subscribe options
*/
class SubscribeOptions {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SubscribeOptions.prototype);
        obj.__wbg_ptr = ptr;
        SubscribeOptionsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SubscribeOptionsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_subscribeoptions_free(ptr);
    }
    /**
    */
    constructor() {
        const ret = wasm.subscribeoptions_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Set auto-close conditions
    * @param {SubscribeAutoCloseOptions | undefined} [opts]
    * @returns {SubscribeOptions}
    */
    close_on(opts) {
        const ptr = this.__destroy_into_raw();
        let ptr0 = 0;
        if (!isLikeNone(opts)) {
            _assertClass(opts, SubscribeAutoCloseOptions);
            ptr0 = opts.__destroy_into_raw();
        }
        const ret = wasm.subscribeoptions_close_on(ptr, ptr0);
        return SubscribeOptions.__wrap(ret);
    }
}
module.exports.SubscribeOptions = SubscribeOptions;

const SubscriptionIdFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_subscriptionid_free(ptr >>> 0));
/**
*/
class SubscriptionId {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SubscriptionId.prototype);
        obj.__wbg_ptr = ptr;
        SubscriptionIdFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SubscriptionIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_subscriptionid_free(ptr);
    }
    /**
    * @param {string} id
    */
    constructor(id) {
        const ptr0 = passStringToWasm0(id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.subscriptionid_new(ptr0, len0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Generate new random [`SubscriptionId`]
    * @returns {SubscriptionId}
    */
    static generate() {
        const ret = wasm.subscriptionid_generate();
        return SubscriptionId.__wrap(ret);
    }
    /**
    * @returns {string}
    */
    get() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.subscriptionid_get(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.SubscriptionId = SubscriptionId;

const TagFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tag_free(ptr >>> 0));
/**
*/
class Tag {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Tag.prototype);
        obj.__wbg_ptr = ptr;
        TagFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof Tag)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TagFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tag_free(ptr);
    }
    /**
    * @param {(string)[]} tag
    * @returns {Tag}
    */
    static parse(tag) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArrayJsValueToWasm0(tag, wasm.__wbindgen_export_0);
            const len0 = WASM_VECTOR_LEN;
            wasm.tag_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Tag.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Compose `["e", "<event-id>"]` tag
    * @param {EventId} event_id
    * @returns {Tag}
    */
    static event(event_id) {
        _assertClass(event_id, EventId);
        const ret = wasm.tag_event(event_id.__wbg_ptr);
        return Tag.__wrap(ret);
    }
    /**
    * Compose `["p", "<public-key>"]` tag
    * @param {PublicKey} public_key
    * @returns {Tag}
    */
    static public_key(public_key) {
        _assertClass(public_key, PublicKey);
        const ret = wasm.tag_public_key(public_key.__wbg_ptr);
        return Tag.__wrap(ret);
    }
    /**
    * Check if `Tag` is an event `reply`
    * @returns {boolean}
    */
    is_reply() {
        const ret = wasm.tag_is_reply(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * @returns {string}
    */
    kind() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.tag_kind(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Get tag as vector of string
    *
    * Internally clone tag and convert it to `Vec<String>`. To avoid tag clone, use `toVec()`.
    * @returns {(string)[]}
    */
    asVec() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.tag_asVec(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Consume the tag and return vector of string
    * @returns {(string)[]}
    */
    toVec() {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.tag_toVec(retptr, ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Tag = Tag;

const ThumbnailsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_thumbnails_free(ptr >>> 0));
/**
*/
class Thumbnails {

    static __unwrap(jsValue) {
        if (!(jsValue instanceof Thumbnails)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ThumbnailsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_thumbnails_free(ptr);
    }
    /**
    * @returns {string}
    */
    get url() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_image_url(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} arg0
    */
    set url(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_image_url(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {ImageDimensions | undefined}
    */
    get dimensions() {
        const ret = wasm.__wbg_get_image_dimensions(this.__wbg_ptr);
        return ret === 0 ? undefined : ImageDimensions.__wrap(ret);
    }
    /**
    * @param {ImageDimensions | undefined} [arg0]
    */
    set dimensions(arg0) {
        let ptr0 = 0;
        if (!isLikeNone(arg0)) {
            _assertClass(arg0, ImageDimensions);
            ptr0 = arg0.__destroy_into_raw();
        }
        wasm.__wbg_set_image_dimensions(this.__wbg_ptr, ptr0);
    }
    /**
    * @param {string} url
    * @param {ImageDimensions | undefined} [dimensions]
    */
    constructor(url, dimensions) {
        const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        let ptr1 = 0;
        if (!isLikeNone(dimensions)) {
            _assertClass(dimensions, ImageDimensions);
            ptr1 = dimensions.__destroy_into_raw();
        }
        const ret = wasm.image_new(ptr0, len0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
}
module.exports.Thumbnails = Thumbnails;

const TimestampFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_timestamp_free(ptr >>> 0));
/**
*/
class Timestamp {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Timestamp.prototype);
        obj.__wbg_ptr = ptr;
        TimestampFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TimestampFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_timestamp_free(ptr);
    }
    /**
    * Get UNIX timestamp (seconds)
    * @returns {Timestamp}
    */
    static now() {
        const ret = wasm.timestamp_now();
        return Timestamp.__wrap(ret);
    }
    /**
    * @param {number} secs
    * @returns {Timestamp}
    */
    static fromSecs(secs) {
        const ret = wasm.timestamp_fromSecs(secs);
        return Timestamp.__wrap(ret);
    }
    /**
    * Get timestamp as seconds
    * @returns {number}
    */
    asSecs() {
        const ret = wasm.timestamp_asSecs(this.__wbg_ptr);
        return ret;
    }
    /**
    * Convert `Timestamp` to human datetime
    * @returns {string}
    */
    toHumanDatetime() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.timestamp_toHumanDatetime(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.Timestamp = Timestamp;

const UnsignedEventFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_unsignedevent_free(ptr >>> 0));
/**
*/
class UnsignedEvent {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(UnsignedEvent.prototype);
        obj.__wbg_ptr = ptr;
        UnsignedEventFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UnsignedEventFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_unsignedevent_free(ptr);
    }
    /**
    * @returns {EventId | undefined}
    */
    get id() {
        const ret = wasm.unsignedevent_id(this.__wbg_ptr);
        return ret === 0 ? undefined : EventId.__wrap(ret);
    }
    /**
    * @returns {PublicKey}
    */
    get pubkey() {
        const ret = wasm.coordinate_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {Timestamp}
    */
    get createdAt() {
        const ret = wasm.unsignedevent_createdAt(this.__wbg_ptr);
        return Timestamp.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    get kind() {
        const ret = wasm.coordinate_kind(this.__wbg_ptr);
        return ret;
    }
    /**
    * @returns {(Tag)[]}
    */
    get tags() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.unsignedevent_tags(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    get content() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_currency(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} json
    * @returns {UnsignedEvent}
    */
    static fromJson(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.unsignedevent_fromJson(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UnsignedEvent.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    asJson() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.unsignedevent_asJson(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Sign an unsigned event
    *
    * Internally: calculate event ID (if not set), sign it, compose and verify event.
    * @param {Keys} keys
    * @returns {Event}
    */
    sign(keys) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(keys, Keys);
            wasm.unsignedevent_sign(retptr, ptr, keys.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Add signature to unsigned event
    *
    * Internally verify the event.
    * @param {string} sig
    * @returns {Event}
    */
    addSignature(sig) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(sig, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.unsignedevent_addSignature(retptr, ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.UnsignedEvent = UnsignedEvent;

const UnwrappedGiftFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_unwrappedgift_free(ptr >>> 0));
/**
* Unwrapped Gift Wrap
*
* <https://github.com/nostr-protocol/nips/blob/master/59.md>
*/
class UnwrappedGift {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(UnwrappedGift.prototype);
        obj.__wbg_ptr = ptr;
        UnwrappedGiftFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UnwrappedGiftFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_unwrappedgift_free(ptr);
    }
    /**
    * Unwrap Gift Wrap event
    *
    * Internally verify the `seal` event
    * @param {Keys} receiver_keys
    * @param {Event} gift_wrap
    * @returns {UnwrappedGift}
    */
    static fromGiftWrap(receiver_keys, gift_wrap) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(receiver_keys, Keys);
            _assertClass(gift_wrap, Event);
            wasm.unwrappedgift_fromGiftWrap(retptr, receiver_keys.__wbg_ptr, gift_wrap.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UnwrappedGift.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Get sender public key
    * @returns {PublicKey}
    */
    get sender() {
        const ret = wasm.coordinate_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * Get rumor
    * @returns {UnsignedEvent}
    */
    get rumor() {
        const ret = wasm.unwrappedgift_rumor(this.__wbg_ptr);
        return UnsignedEvent.__wrap(ret);
    }
}
module.exports.UnwrappedGift = UnwrappedGift;

const UserFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_user_free(ptr >>> 0));
/**
*/
class User {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(User.prototype);
        obj.__wbg_ptr = ptr;
        UserFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UserFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_user_free(ptr);
    }
    /**
    * @returns {PublicKey}
    */
    get publicKey() {
        const ret = wasm.__wbg_get_user_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @param {PublicKey} arg0
    */
    set publicKey(arg0) {
        _assertClass(arg0, PublicKey);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_user_publicKey(this.__wbg_ptr, ptr0);
    }
    /**
    * @returns {string | undefined}
    */
    get url() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoicerequestparams_payment_hash(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string | undefined} [arg0]
    */
    set url(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoicerequestparams_payment_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @param {PublicKey} public_key
    * @param {string | undefined} [url]
    */
    constructor(public_key, url) {
        _assertClass(public_key, PublicKey);
        var ptr0 = public_key.__destroy_into_raw();
        var ptr1 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len1 = WASM_VECTOR_LEN;
        const ret = wasm.user_new(ptr0, ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
}
module.exports.User = User;

const ZapDetailsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_zapdetails_free(ptr >>> 0));
/**
* Zap Details
*/
class ZapDetails {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ZapDetails.prototype);
        obj.__wbg_ptr = ptr;
        ZapDetailsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ZapDetailsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_zapdetails_free(ptr);
    }
    /**
    * Create new Zap Details
    *
    * **Note: `private` zaps are not currently supported here!**
    * @param {ZapType} zap_type
    */
    constructor(zap_type) {
        const ret = wasm.zapdetails_new(zap_type);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Add message
    * @param {string} message
    * @returns {ZapDetails}
    */
    message(message) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passStringToWasm0(message, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.zapdetails_message(ptr, ptr0, len0);
        return ZapDetails.__wrap(ret);
    }
}
module.exports.ZapDetails = ZapDetails;

const ZapEntityFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_zapentity_free(ptr >>> 0));
/**
* Zap entity
*/
class ZapEntity {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ZapEntity.prototype);
        obj.__wbg_ptr = ptr;
        ZapEntityFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ZapEntityFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_zapentity_free(ptr);
    }
    /**
    * @param {EventId} event_id
    * @returns {ZapEntity}
    */
    static event(event_id) {
        _assertClass(event_id, EventId);
        const ret = wasm.zapentity_event(event_id.__wbg_ptr);
        return ZapEntity.__wrap(ret);
    }
    /**
    * @param {PublicKey} public_key
    * @returns {ZapEntity}
    */
    static publicKey(public_key) {
        _assertClass(public_key, PublicKey);
        const ret = wasm.zapentity_publicKey(public_key.__wbg_ptr);
        return ZapEntity.__wrap(ret);
    }
}
module.exports.ZapEntity = ZapEntity;

const ZapRequestDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_zaprequestdata_free(ptr >>> 0));
/**
*/
class ZapRequestData {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ZapRequestDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_zaprequestdata_free(ptr);
    }
    /**
    * @param {PublicKey} public_key
    * @param {(string)[]} relays
    * @param {string} message
    * @param {number | undefined} [amount]
    * @param {string | undefined} [lnurl]
    * @param {EventId | undefined} [event_id]
    * @param {Coordinate | undefined} [event_coordinate]
    */
    constructor(public_key, relays, message, amount, lnurl, event_id, event_coordinate) {
        _assertClass(public_key, PublicKey);
        const ptr0 = passArrayJsValueToWasm0(relays, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(message, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        var ptr2 = isLikeNone(lnurl) ? 0 : passStringToWasm0(lnurl, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len2 = WASM_VECTOR_LEN;
        let ptr3 = 0;
        if (!isLikeNone(event_id)) {
            _assertClass(event_id, EventId);
            ptr3 = event_id.__destroy_into_raw();
        }
        let ptr4 = 0;
        if (!isLikeNone(event_coordinate)) {
            _assertClass(event_coordinate, Coordinate);
            ptr4 = event_coordinate.__destroy_into_raw();
        }
        const ret = wasm.zaprequestdata_new(public_key.__wbg_ptr, ptr0, len0, ptr1, len1, !isLikeNone(amount), isLikeNone(amount) ? 0 : amount, ptr2, len2, ptr3, ptr4);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @returns {PublicKey}
    */
    get publicKey() {
        const ret = wasm.zaprequestdata_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {(string)[]}
    */
    get relays() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.zaprequestdata_relays(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_10(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    get message() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.zaprequestdata_message(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {number | undefined}
    */
    get amount() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.zaprequestdata_amount(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getFloat64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get lnurl() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.zaprequestdata_lnurl(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_10(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {EventId | undefined}
    */
    get eventID() {
        const ret = wasm.zaprequestdata_eventID(this.__wbg_ptr);
        return ret === 0 ? undefined : EventId.__wrap(ret);
    }
    /**
    * @returns {Coordinate | undefined}
    */
    get eventCoordinate() {
        const ret = wasm.zaprequestdata_eventCoordinate(this.__wbg_ptr);
        return ret === 0 ? undefined : Coordinate.__wrap(ret);
    }
}
module.exports.ZapRequestData = ZapRequestData;

module.exports.__wbindgen_number_new = function(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
};

module.exports.__wbg_profile_new = function(arg0) {
    const ret = Profile.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_nip46signer_new = function(arg0) {
    const ret = Nip46Signer.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_nostrzapper_new = function(arg0) {
    const ret = NostrZapper.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_relay_new = function(arg0) {
    const ret = Relay.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_nwc_new = function(arg0) {
    const ret = NWC.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_nostrdatabase_new = function(arg0) {
    const ret = NostrDatabase.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_nostrsigner_new = function(arg0) {
    const ret = NostrSigner.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
};

module.exports.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof(obj) === 'string' ? obj : undefined;
    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    var len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
};

module.exports.__wbg_handleEvent_41d2742cd412fbae = function(arg0, arg1, arg2, arg3, arg4, arg5) {
    let deferred0_0;
    let deferred0_1;
    let deferred1_0;
    let deferred1_1;
    try {
        deferred0_0 = arg1;
        deferred0_1 = arg2;
        deferred1_0 = arg3;
        deferred1_1 = arg4;
        const ret = getObject(arg0).handleEvent(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4), Event.__wrap(arg5));
        return addHeapObject(ret);
    } finally {
        wasm.__wbindgen_export_10(deferred0_0, deferred0_1, 1);
        wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
    }
};

module.exports.__wbindgen_boolean_get = function(arg0) {
    const v = getObject(arg0);
    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;
    return ret;
};

module.exports.__wbg_handleMsg_ee58324c225bb394 = function(arg0, arg1, arg2, arg3) {
    let deferred0_0;
    let deferred0_1;
    try {
        deferred0_0 = arg1;
        deferred0_1 = arg2;
        const ret = getObject(arg0).handleMsg(getStringFromWasm0(arg1, arg2), RelayMessage.__wrap(arg3));
        return addHeapObject(ret);
    } finally {
        wasm.__wbindgen_export_10(deferred0_0, deferred0_1, 1);
    }
};

module.exports.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
};

module.exports.__wbindgen_bigint_from_u64 = function(arg0) {
    const ret = BigInt.asUintN(64, arg0);
    return addHeapObject(ret);
};

module.exports.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_mark_6a57fc1e16d4719b = function(arg0, arg1) {
    performance.mark(getStringFromWasm0(arg0, arg1));
};

module.exports.__wbg_measure_2dc9f5a6ee2e18e3 = function() { return handleError(function (arg0, arg1, arg2, arg3) {
    let deferred0_0;
    let deferred0_1;
    let deferred1_0;
    let deferred1_1;
    try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        deferred1_0 = arg2;
        deferred1_1 = arg3;
        performance.measure(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3));
    } finally {
        wasm.__wbindgen_export_10(deferred0_0, deferred0_1, 1);
        wasm.__wbindgen_export_10(deferred1_0, deferred1_1, 1);
    }
}, arguments) };

module.exports.__wbg_log_0321e93428caedc2 = function(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        console.log(getStringFromWasm0(arg0, arg1));
    } finally {
        wasm.__wbindgen_export_10(deferred0_0, deferred0_1, 1);
    }
};

module.exports.__wbg_log_7ab16a8f70a10778 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
    let deferred0_0;
    let deferred0_1;
    try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        console.log(getStringFromWasm0(arg0, arg1), getStringFromWasm0(arg2, arg3), getStringFromWasm0(arg4, arg5), getStringFromWasm0(arg6, arg7));
    } finally {
        wasm.__wbindgen_export_10(deferred0_0, deferred0_1, 1);
    }
};

module.exports.__wbindgen_cb_drop = function(arg0) {
    const obj = takeObject(arg0).original;
    if (obj.cnt-- == 1) {
        obj.a = 0;
        return true;
    }
    const ret = false;
    return ret;
};

module.exports.__wbindgen_is_string = function(arg0) {
    const ret = typeof(getObject(arg0)) === 'string';
    return ret;
};

module.exports.__wbg_Window_4c97c099b03994c2 = function(arg0) {
    const ret = getObject(arg0).Window;
    return addHeapObject(ret);
};

module.exports.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject(arg0) === undefined;
    return ret;
};

module.exports.__wbg_WorkerGlobalScope_b87d69ab991859f6 = function(arg0) {
    const ret = getObject(arg0).WorkerGlobalScope;
    return addHeapObject(ret);
};

module.exports.__wbg_global_c22c39d5b60f622c = function(arg0) {
    const ret = getObject(arg0).global;
    return addHeapObject(ret);
};

module.exports.__wbg_indexedDB_f50e4ba5302a87c6 = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).indexedDB;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
}, arguments) };

module.exports.__wbg_clearTimeout_76877dbc010e786d = function(arg0) {
    const ret = clearTimeout(takeObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_setTimeout_75cb9b6991a4031d = function() { return handleError(function (arg0, arg1) {
    const ret = setTimeout(getObject(arg0), arg1);
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_coordinate_new = function(arg0) {
    const ret = Coordinate.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_makeinvoiceresponseresult_new = function(arg0) {
    const ret = MakeInvoiceResponseResult.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_relaylistitem_new = function(arg0) {
    const ret = RelayListItem.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_paykeysendrequestparams_new = function(arg0) {
    const ret = PayKeysendRequestParams.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_keysendtlvrecord_new = function(arg0) {
    const ret = KeysendTLVRecord.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_publickey_new = function(arg0) {
    const ret = PublicKey.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_tag_new = function(arg0) {
    const ret = Tag.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_getinforesponseresult_new = function(arg0) {
    const ret = GetInfoResponseResult.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_emojiinfo_new = function(arg0) {
    const ret = EmojiInfo.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_lookupinvoiceresponseresult_new = function(arg0) {
    const ret = LookupInvoiceResponseResult.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_payinvoicerequestparams_new = function(arg0) {
    const ret = PayInvoiceRequestParams.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_paykeysendresponseresult_new = function(arg0) {
    const ret = PayKeysendResponseResult.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_nostrconnecturi_new = function(arg0) {
    const ret = NostrConnectURI.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_shippingcost_new = function(arg0) {
    const ret = ShippingCost.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_shippingmethod_new = function(arg0) {
    const ret = ShippingMethod.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_event_new = function(arg0) {
    const ret = Event.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_relayinformationdocument_new = function(arg0) {
    const ret = RelayInformationDocument.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_user_new = function(arg0) {
    const ret = User.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_eventid_new = function(arg0) {
    const ret = EventId.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_eventid_unwrap = function(arg0) {
    const ret = EventId.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_thumbnails_unwrap = function(arg0) {
    const ret = Thumbnails.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_tag_unwrap = function(arg0) {
    const ret = Tag.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_event_unwrap = function(arg0) {
    const ret = Event.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_publickey_unwrap = function(arg0) {
    const ret = PublicKey.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_coordinate_unwrap = function(arg0) {
    const ret = Coordinate.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_payinvoicerequestparams_unwrap = function(arg0) {
    const ret = PayInvoiceRequestParams.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_keysendtlvrecord_unwrap = function(arg0) {
    const ret = KeysendTLVRecord.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_paykeysendrequestparams_unwrap = function(arg0) {
    const ret = PayKeysendRequestParams.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_emojiinfo_unwrap = function(arg0) {
    const ret = EmojiInfo.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_relaylistitem_unwrap = function(arg0) {
    const ret = RelayListItem.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_contact_unwrap = function(arg0) {
    const ret = Contact.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_filter_unwrap = function(arg0) {
    const ret = Filter.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_new_abda76e883ba8a5f = function() {
    const ret = new Error();
    return addHeapObject(ret);
};

module.exports.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
};

module.exports.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        console.error(getStringFromWasm0(arg0, arg1));
    } finally {
        wasm.__wbindgen_export_10(deferred0_0, deferred0_1, 1);
    }
};

module.exports.__wbg_fetch_226e3dfaba0d2a21 = function(arg0) {
    const ret = fetch(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_queueMicrotask_adae4bc085237231 = function(arg0) {
    const ret = getObject(arg0).queueMicrotask;
    return addHeapObject(ret);
};

module.exports.__wbindgen_is_function = function(arg0) {
    const ret = typeof(getObject(arg0)) === 'function';
    return ret;
};

module.exports.__wbg_queueMicrotask_4d890031a6a5a50c = function(arg0) {
    queueMicrotask(getObject(arg0));
};

module.exports.__wbg_instanceof_Window_3e5cd1f48c152d01 = function(arg0) {
    let result;
    try {
        result = getObject(arg0) instanceof Window;
    } catch (_) {
        result = false;
    }
    const ret = result;
    return ret;
};

module.exports.__wbg_signal_3c701f5f40a5f08d = function(arg0) {
    const ret = getObject(arg0).signal;
    return addHeapObject(ret);
};

module.exports.__wbg_new_0ae46f44b7485bb2 = function() { return handleError(function () {
    const ret = new AbortController();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_abort_2c4fb490d878d2b2 = function(arg0) {
    getObject(arg0).abort();
};

module.exports.__wbg_instanceof_Blob_c7124075b9fe8788 = function(arg0) {
    let result;
    try {
        result = getObject(arg0) instanceof Blob;
    } catch (_) {
        result = false;
    }
    const ret = result;
    return ret;
};

module.exports.__wbg_wasClean_1efd9561c5671b45 = function(arg0) {
    const ret = getObject(arg0).wasClean;
    return ret;
};

module.exports.__wbg_code_72a380a2ce61a242 = function(arg0) {
    const ret = getObject(arg0).code;
    return ret;
};

module.exports.__wbg_reason_ad453a16ee68a1b9 = function(arg0, arg1) {
    const ret = getObject(arg1).reason;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
};

module.exports.__wbg_name_663328ac10533100 = function(arg0, arg1) {
    const ret = getObject(arg1).name;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
};

module.exports.__wbg_message_3915f683795a43d9 = function(arg0, arg1) {
    const ret = getObject(arg1).message;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
};

module.exports.__wbg_code_76caf5c3096de69d = function(arg0) {
    const ret = getObject(arg0).code;
    return ret;
};

module.exports.__wbg_newwithmessage_d37c6efe7ac42d0b = function() { return handleError(function (arg0, arg1) {
    const ret = new DOMException(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_item_87d3fd156c244c54 = function(arg0, arg1, arg2) {
    const ret = getObject(arg1).item(arg2 >>> 0);
    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    var len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
};

module.exports.__wbg_target_52ddf6955f636bf5 = function(arg0) {
    const ret = getObject(arg0).target;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
};

module.exports.__wbg_new_7a20246daa6eec7e = function() { return handleError(function () {
    const ret = new Headers();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_append_aa3f462f9e2b5ff2 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {
    getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
}, arguments) };

module.exports.__wbg_name_a965e127103fc2ed = function(arg0, arg1) {
    const ret = getObject(arg1).name;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
};

module.exports.__wbg_version_ae54f804950054e5 = function(arg0) {
    const ret = getObject(arg0).version;
    return ret;
};

module.exports.__wbg_objectStoreNames_71c3096b04c76bcd = function(arg0) {
    const ret = getObject(arg0).objectStoreNames;
    return addHeapObject(ret);
};

module.exports.__wbg_setonversionchange_141a13607ed5b1bb = function(arg0, arg1) {
    getObject(arg0).onversionchange = getObject(arg1);
};

module.exports.__wbg_close_9830b4b2c785845c = function(arg0) {
    getObject(arg0).close();
};

module.exports.__wbg_createObjectStore_dc44cdc239d1b114 = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).createObjectStore(getStringFromWasm0(arg1, arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_deleteObjectStore_517effefcf018434 = function() { return handleError(function (arg0, arg1, arg2) {
    getObject(arg0).deleteObjectStore(getStringFromWasm0(arg1, arg2));
}, arguments) };

module.exports.__wbg_transaction_60ace538ccd4ba90 = function() { return handleError(function (arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).transaction(getStringFromWasm0(arg1, arg2), takeObject(arg3));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_transaction_632c349fd48458fb = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).transaction(getObject(arg1), takeObject(arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_open_65e0826fa9c7929c = function() { return handleError(function (arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).open(getStringFromWasm0(arg1, arg2), arg3 >>> 0);
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_open_7cc5c5a15ff86a65 = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).open(getStringFromWasm0(arg1, arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_clear_b0d271d23c9b0b9a = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).clear();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_delete_e8e3bfaf1ea215be = function() { return handleError(function (arg0, arg1) {
    const ret = getObject(arg0).delete(getObject(arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_get_b1f3efa7f2a2f7d1 = function() { return handleError(function (arg0, arg1) {
    const ret = getObject(arg0).get(getObject(arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_getAll_80971526d798cec8 = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).getAll();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_put_f50a8dd6e4a8a13a = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).put(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_setonblocked_e890763945ffff13 = function(arg0, arg1) {
    getObject(arg0).onblocked = getObject(arg1);
};

module.exports.__wbg_setonupgradeneeded_73793bc200a4f7b8 = function(arg0, arg1) {
    getObject(arg0).onupgradeneeded = getObject(arg1);
};

module.exports.__wbg_result_915d75a0bb0397a1 = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).result;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_error_a093a4b69c2260a3 = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).error;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
}, arguments) };

module.exports.__wbg_readyState_248e1b90027f25a0 = function(arg0) {
    const ret = getObject(arg0).readyState;
    return addHeapObject(ret);
};

module.exports.__wbg_setonsuccess_a04d5d5a703ed886 = function(arg0, arg1) {
    getObject(arg0).onsuccess = getObject(arg1);
};

module.exports.__wbg_setonerror_80c9bac4e4864adf = function(arg0, arg1) {
    getObject(arg0).onerror = getObject(arg1);
};

module.exports.__wbg_setonabort_568145f0fa09b9be = function(arg0, arg1) {
    getObject(arg0).onabort = getObject(arg1);
};

module.exports.__wbg_setoncomplete_e9993a45b7bfaec4 = function(arg0, arg1) {
    getObject(arg0).oncomplete = getObject(arg1);
};

module.exports.__wbg_setonerror_d17408c3482b10eb = function(arg0, arg1) {
    getObject(arg0).onerror = getObject(arg1);
};

module.exports.__wbg_objectStore_b0e52dee7e737df7 = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).objectStore(getStringFromWasm0(arg1, arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_oldVersion_76f230a942168111 = function(arg0) {
    const ret = getObject(arg0).oldVersion;
    return ret;
};

module.exports.__wbg_data_ba3ea616b5392abf = function(arg0) {
    const ret = getObject(arg0).data;
    return addHeapObject(ret);
};

module.exports.__wbg_newwithstrandinit_f581dff0d19a8b03 = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_instanceof_Response_4c3b1446206114d1 = function(arg0) {
    let result;
    try {
        result = getObject(arg0) instanceof Response;
    } catch (_) {
        result = false;
    }
    const ret = result;
    return ret;
};

module.exports.__wbg_url_83a6a4f65f7a2b38 = function(arg0, arg1) {
    const ret = getObject(arg1).url;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
};

module.exports.__wbg_status_d6d47ad2837621eb = function(arg0) {
    const ret = getObject(arg0).status;
    return ret;
};

module.exports.__wbg_headers_24def508a7518df9 = function(arg0) {
    const ret = getObject(arg0).headers;
    return addHeapObject(ret);
};

module.exports.__wbg_arrayBuffer_5b2688e3dd873fed = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).arrayBuffer();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_text_668782292b0bc561 = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).text();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_url_b48fdb1aaed4710e = function(arg0, arg1) {
    const ret = getObject(arg1).url;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
};

module.exports.__wbg_readyState_c8f9a5deaec3bb41 = function(arg0) {
    const ret = getObject(arg0).readyState;
    return ret;
};

module.exports.__wbg_setonopen_1264714f7bce70f8 = function(arg0, arg1) {
    getObject(arg0).onopen = getObject(arg1);
};

module.exports.__wbg_setonerror_927113bb9ac197fe = function(arg0, arg1) {
    getObject(arg0).onerror = getObject(arg1);
};

module.exports.__wbg_setonclose_b2fc3455ef8818f4 = function(arg0, arg1) {
    getObject(arg0).onclose = getObject(arg1);
};

module.exports.__wbg_setonmessage_46f324ad82067922 = function(arg0, arg1) {
    getObject(arg0).onmessage = getObject(arg1);
};

module.exports.__wbg_setbinaryType_68fc3c6feda7310c = function(arg0, arg1) {
    getObject(arg0).binaryType = takeObject(arg1);
};

module.exports.__wbg_new_2575c598b4006174 = function() { return handleError(function (arg0, arg1) {
    const ret = new WebSocket(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_close_328b8b803521cbdd = function() { return handleError(function (arg0) {
    getObject(arg0).close();
}, arguments) };

module.exports.__wbg_send_5bf3f962e9ffe0f6 = function() { return handleError(function (arg0, arg1, arg2) {
    getObject(arg0).send(getStringFromWasm0(arg1, arg2));
}, arguments) };

module.exports.__wbg_send_2ba7d32fcb03b9a4 = function() { return handleError(function (arg0, arg1, arg2) {
    getObject(arg0).send(getArrayU8FromWasm0(arg1, arg2));
}, arguments) };

module.exports.__wbg_indexedDB_e14899cea32cf3f3 = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).indexedDB;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
}, arguments) };

module.exports.__wbg_indexedDB_3fc079a9617132a2 = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).indexedDB;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
}, arguments) };

module.exports.__wbg_fetch_693453ca3f88c055 = function(arg0, arg1) {
    const ret = getObject(arg0).fetch(getObject(arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_crypto_d05b68a3572bb8ca = function(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
};

module.exports.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    const ret = typeof(val) === 'object' && val !== null;
    return ret;
};

module.exports.__wbg_process_b02b3570280d0366 = function(arg0) {
    const ret = getObject(arg0).process;
    return addHeapObject(ret);
};

module.exports.__wbg_versions_c1cb42213cedf0f5 = function(arg0) {
    const ret = getObject(arg0).versions;
    return addHeapObject(ret);
};

module.exports.__wbg_node_43b1089f407e4ec2 = function(arg0) {
    const ret = getObject(arg0).node;
    return addHeapObject(ret);
};

module.exports.__wbg_require_9a7e0f667ead4995 = function() { return handleError(function () {
    const ret = module.require;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_msCrypto_10fc94afee92bd76 = function(arg0) {
    const ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
};

module.exports.__wbg_randomFillSync_b70ccbdf4926a99d = function() { return handleError(function (arg0, arg1) {
    getObject(arg0).randomFillSync(takeObject(arg1));
}, arguments) };

module.exports.__wbg_getRandomValues_7e42b4fb8779dc6d = function() { return handleError(function (arg0, arg1) {
    getObject(arg0).getRandomValues(getObject(arg1));
}, arguments) };

module.exports.__wbg_self_ce0dbfc45cf2f5be = function() { return handleError(function () {
    const ret = self.self;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_window_c6fb939a7f436783 = function() { return handleError(function () {
    const ret = window.window;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_globalThis_d1e6af4856ba331b = function() { return handleError(function () {
    const ret = globalThis.globalThis;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_global_207b558942527489 = function() { return handleError(function () {
    const ret = global.global;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_newnoargs_e258087cd0daa0ea = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_call_27c0f87801dedf93 = function() { return handleError(function (arg0, arg1) {
    const ret = getObject(arg0).call(getObject(arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_get_bd8e338fbd5f5cc8 = function(arg0, arg1) {
    const ret = getObject(arg0)[arg1 >>> 0];
    return addHeapObject(ret);
};

module.exports.__wbg_length_cd7af8117672b8b8 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
};

module.exports.__wbg_new_16b304a2cfa7ff4a = function() {
    const ret = new Array();
    return addHeapObject(ret);
};

module.exports.__wbg_next_40fc327bfc8770e6 = function(arg0) {
    const ret = getObject(arg0).next;
    return addHeapObject(ret);
};

module.exports.__wbg_next_196c84450b364254 = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).next();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_done_298b57d23c0fc80c = function(arg0) {
    const ret = getObject(arg0).done;
    return ret;
};

module.exports.__wbg_value_d93c65011f51a456 = function(arg0) {
    const ret = getObject(arg0).value;
    return addHeapObject(ret);
};

module.exports.__wbg_iterator_2cee6dadfd956dfa = function() {
    const ret = Symbol.iterator;
    return addHeapObject(ret);
};

module.exports.__wbg_get_e3c254076557e348 = function() { return handleError(function (arg0, arg1) {
    const ret = Reflect.get(getObject(arg0), getObject(arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_new_72fb9a18b5ae2624 = function() {
    const ret = new Object();
    return addHeapObject(ret);
};

module.exports.__wbg_push_a5b05aedc7234f9f = function(arg0, arg1) {
    const ret = getObject(arg0).push(getObject(arg1));
    return ret;
};

module.exports.__wbg_instanceof_ArrayBuffer_836825be07d4c9d2 = function(arg0) {
    let result;
    try {
        result = getObject(arg0) instanceof ArrayBuffer;
    } catch (_) {
        result = false;
    }
    const ret = result;
    return ret;
};

module.exports.__wbg_call_b3ca7c6051f9bec1 = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_call_8e7cb608789c2528 = function() { return handleError(function (arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_now_3014639a94423537 = function() {
    const ret = Date.now();
    return ret;
};

module.exports.__wbg_instanceof_Object_71ca3c0a59266746 = function(arg0) {
    let result;
    try {
        result = getObject(arg0) instanceof Object;
    } catch (_) {
        result = false;
    }
    const ret = result;
    return ret;
};

module.exports.__wbg_has_0af94d20077affa2 = function() { return handleError(function (arg0, arg1) {
    const ret = Reflect.has(getObject(arg0), getObject(arg1));
    return ret;
}, arguments) };

module.exports.__wbg_set_1f9b04f170055d33 = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));
    return ret;
}, arguments) };

module.exports.__wbg_buffer_12d079cc21e14bdb = function(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
};

module.exports.__wbg_stringify_8887fe74e1c50d81 = function() { return handleError(function (arg0) {
    const ret = JSON.stringify(getObject(arg0));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_new_81740750da40724f = function(arg0, arg1) {
    try {
        var state0 = {a: arg0, b: arg1};
        var cb0 = (arg0, arg1) => {
            const a = state0.a;
            state0.a = 0;
            try {
                return __wbg_adapter_986(a, state0.b, arg0, arg1);
            } finally {
                state0.a = a;
            }
        };
        const ret = new Promise(cb0);
        return addHeapObject(ret);
    } finally {
        state0.a = state0.b = 0;
    }
};

module.exports.__wbg_resolve_b0083a7967828ec8 = function(arg0) {
    const ret = Promise.resolve(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_then_0c86a60e8fcfe9f6 = function(arg0, arg1) {
    const ret = getObject(arg0).then(getObject(arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_then_a73caa9a87991566 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
};

module.exports.__wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb = function(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
};

module.exports.__wbg_new_63b92bc8671ed464 = function(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_set_a47bac70306a19a7 = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
};

module.exports.__wbg_length_c20a40f15020d68a = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
};

module.exports.__wbg_newwithlength_e9b4878cebadb3d3 = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject(ret);
};

module.exports.__wbg_subarray_a1f73cd4b5b42fe1 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
};

module.exports.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString(getObject(arg1));
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
};

module.exports.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
};

module.exports.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return addHeapObject(ret);
};

module.exports.__wbindgen_closure_wrapper423 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 16, __wbg_adapter_32);
    return addHeapObject(ret);
};

module.exports.__wbindgen_closure_wrapper425 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 16, __wbg_adapter_35);
    return addHeapObject(ret);
};

module.exports.__wbindgen_closure_wrapper3090 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 985, __wbg_adapter_38);
    return addHeapObject(ret);
};

module.exports.__wbindgen_closure_wrapper3366 = function(arg0, arg1, arg2) {
    const ret = makeClosure(arg0, arg1, 1096, __wbg_adapter_41);
    return addHeapObject(ret);
};

module.exports.__wbindgen_closure_wrapper3368 = function(arg0, arg1, arg2) {
    const ret = makeClosure(arg0, arg1, 1096, __wbg_adapter_44);
    return addHeapObject(ret);
};

module.exports.__wbindgen_closure_wrapper4088 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 1222, __wbg_adapter_47);
    return addHeapObject(ret);
};

module.exports.__wbindgen_closure_wrapper7571 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 1535, __wbg_adapter_50);
    return addHeapObject(ret);
};

let WebSocketClass;

// Check if WebSocket is available in the current environment
if (typeof WebSocket !== 'undefined') {
  // Native WebSocket available in the browser
  WebSocketClass = WebSocket;
} else {
  // Import 'ws' for Node.js environment
  WebSocketClass = require('ws');
}

WebSocket = WebSocketClass;

let inited = false;
module.exports.loadWasmSync = function () {
    if (inited) {
        return;
    }
    if (initPromise) {
        throw new Error("Asynchronous initialisation already in progress: cannot initialise synchronously");
    }
    const bytes = unbase64(require("./nostr_sdk_js_bg.wasm.js"));
    const mod = new WebAssembly.Module(bytes);
    const instance = new WebAssembly.Instance(mod, imports);
    wasm = instance.exports;
    wasm.__wbindgen_start();
    inited = true;
};

let initPromise = null;

/**
 * Load the WebAssembly module in the background, if it has not already been loaded.
 *
 * Returns a promise which will resolve once the other methods are ready.
 *
 * @returns {Promise<void>}
 */
module.exports.loadWasmAsync = function () {
    if (inited) {
        return Promise.resolve();
    }
    if (!initPromise) {
        initPromise = Promise.resolve()
            .then(() => require("./nostr_sdk_js_bg.wasm.js"))
            .then((b64) => WebAssembly.instantiate(unbase64(b64), imports))
            .then((result) => {
                wasm = result.instance.exports;
                wasm.__wbindgen_start();
                inited = true;
            });
    }
    return initPromise;
};

const b64lookup = new Uint8Array([
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 62, 0, 62, 0, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
    8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 63, 0, 26, 27, 28, 29, 30, 31, 32,
    33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
]);

// base64 decoder, based on the code at https://developer.mozilla.org/en-US/docs/Glossary/Base64#solution_2_%E2%80%93_rewriting_atob_and_btoa_using_typedarrays_and_utf-8
function unbase64(sBase64) {
    const sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, "");
    const nInLen = sB64Enc.length;
    const nOutLen = (nInLen * 3 + 1) >> 2;
    const taBytes = new Uint8Array(nOutLen);

    let nMod3;
    let nMod4;
    let nUint24 = 0;
    let nOutIdx = 0;
    for (let nInIdx = 0; nInIdx < nInLen; nInIdx++) {
        nMod4 = nInIdx & 3;
        nUint24 |= b64lookup[sB64Enc.charCodeAt(nInIdx)] << (6 * (3 - nMod4));
        if (nMod4 === 3 || nInLen - nInIdx === 1) {
            nMod3 = 0;
            while (nMod3 < 3 && nOutIdx < nOutLen) {
                taBytes[nOutIdx] = (nUint24 >>> ((16 >>> nMod3) & 24)) & 255;
                nMod3++;
                nOutIdx++;
            }
            nUint24 = 0;
        }
    }

    return taBytes;
}