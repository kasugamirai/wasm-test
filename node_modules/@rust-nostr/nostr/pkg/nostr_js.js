let imports = {};
imports['__wbindgen_placeholder__'] = module.exports;
let wasm;

const heap = new Array(128).fill(undefined);

heap.push(undefined, null, true, false);

let heap_next = heap.length;

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

let cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

let cachedUint8Memory0 = null;

function getUint8Memory0() {
    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

function getObject(idx) { return heap[idx]; }

function dropObject(idx) {
    if (idx < 132) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

let WASM_VECTOR_LEN = 0;

let cachedTextEncoder = new TextEncoder('utf-8');

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length, 1) >>> 0;
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len, 1) >>> 0;

    const mem = getUint8Memory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

let cachedInt32Memory0 = null;

function getInt32Memory0() {
    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
}

function debugString(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' && name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString(val[0]);
        }
        for(let i = 1; i < length; i++) {
            debug += ', ' + debugString(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}

const CLOSURE_DTORS = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(state => {
    wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b)
});

function makeMutClosure(arg0, arg1, dtor, f) {
    const state = { a: arg0, b: arg1, cnt: 1, dtor };
    const real = (...args) => {
        // First up with a closure we increment the internal reference
        // count. This ensures that the Rust closure environment won't
        // be deallocated while we're invoking it.
        state.cnt++;
        const a = state.a;
        state.a = 0;
        try {
            return f(a, state.b, ...args);
        } finally {
            if (--state.cnt === 0) {
                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);
                CLOSURE_DTORS.unregister(state);
            } else {
                state.a = a;
            }
        }
    };
    real.original = state;
    CLOSURE_DTORS.register(real, state, state);
    return real;
}
function __wbg_adapter_28(arg0, arg1, arg2) {
    wasm.__wbindgen_export_3(arg0, arg1, addHeapObject(arg2));
}

let cachedUint32Memory0 = null;

function getUint32Memory0() {
    if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {
        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);
    }
    return cachedUint32Memory0;
}

function passArrayJsValueToWasm0(array, malloc) {
    const ptr = malloc(array.length * 4, 4) >>> 0;
    const mem = getUint32Memory0();
    for (let i = 0; i < array.length; i++) {
        mem[ptr / 4 + i] = addHeapObject(array[i]);
    }
    WASM_VECTOR_LEN = array.length;
    return ptr;
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
}

function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1, 1) >>> 0;
    getUint8Memory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}

function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}

function getArrayJsValueFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    const mem = getUint32Memory0();
    const slice = mem.subarray(ptr / 4, ptr / 4 + len);
    const result = [];
    for (let i = 0; i < slice.length; i++) {
        result.push(takeObject(slice[i]));
    }
    return result;
}
/**
* Encrypt (NIP04)
* @param {SecretKey} sk
* @param {PublicKey} pk
* @param {string} text
* @returns {string}
*/
module.exports.nip04Encrypt = function(sk, pk, text) {
    let deferred3_0;
    let deferred3_1;
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(sk, SecretKey);
        _assertClass(pk, PublicKey);
        const ptr0 = passStringToWasm0(text, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.nip04Encrypt(retptr, sk.__wbg_ptr, pk.__wbg_ptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
            ptr2 = 0; len2 = 0;
            throw takeObject(r2);
        }
        deferred3_0 = ptr2;
        deferred3_1 = len2;
        return getStringFromWasm0(ptr2, len2);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_4(deferred3_0, deferred3_1, 1);
    }
};

/**
* Decrypt (NIP04)
* @param {SecretKey} sk
* @param {PublicKey} pk
* @param {string} encrypted_content
* @returns {string}
*/
module.exports.nip04Decrypt = function(sk, pk, encrypted_content) {
    let deferred3_0;
    let deferred3_1;
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(sk, SecretKey);
        _assertClass(pk, PublicKey);
        const ptr0 = passStringToWasm0(encrypted_content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.nip04Decrypt(retptr, sk.__wbg_ptr, pk.__wbg_ptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
            ptr2 = 0; len2 = 0;
            throw takeObject(r2);
        }
        deferred3_0 = ptr2;
        deferred3_1 = len2;
        return getStringFromWasm0(ptr2, len2);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_4(deferred3_0, deferred3_1, 1);
    }
};

/**
* Verify NIP05
* @param {PublicKey} public_key
* @param {string} nip05
* @returns {Promise<void>}
*/
module.exports.verifyNip05 = function(public_key, nip05) {
    _assertClass(public_key, PublicKey);
    var ptr0 = public_key.__destroy_into_raw();
    const ptr1 = passStringToWasm0(nip05, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    const ret = wasm.verifyNip05(ptr0, ptr1, len1);
    return takeObject(ret);
};

let cachedUint16Memory0 = null;

function getUint16Memory0() {
    if (cachedUint16Memory0 === null || cachedUint16Memory0.byteLength === 0) {
        cachedUint16Memory0 = new Uint16Array(wasm.memory.buffer);
    }
    return cachedUint16Memory0;
}

function getArrayU16FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint16Memory0().subarray(ptr / 2, ptr / 2 + len);
}
/**
* Create a NIP-26 delegation tag (including the signature).
* See also validate_delegation_tag().
* @param {Keys} delegator_keys
* @param {PublicKey} delegatee_pubkey
* @param {string} conditions
* @returns {string}
*/
module.exports.createDelegationTag = function(delegator_keys, delegatee_pubkey, conditions) {
    let deferred3_0;
    let deferred3_1;
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(delegator_keys, Keys);
        _assertClass(delegatee_pubkey, PublicKey);
        const ptr0 = passStringToWasm0(conditions, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.createDelegationTag(retptr, delegator_keys.__wbg_ptr, delegatee_pubkey.__wbg_ptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
            ptr2 = 0; len2 = 0;
            throw takeObject(r2);
        }
        deferred3_0 = ptr2;
        deferred3_1 = len2;
        return getStringFromWasm0(ptr2, len2);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_4(deferred3_0, deferred3_1, 1);
    }
};

/**
* Validate a NIP-26 delegation tag, check signature and conditions.
* @param {string} delegation_tag
* @param {PublicKey} delegatee_pubkey
* @param {number} event_kind
* @param {Timestamp} created_at
* @returns {boolean}
*/
module.exports.validateDelegationTag = function(delegation_tag, delegatee_pubkey, event_kind, created_at) {
    const ptr0 = passStringToWasm0(delegation_tag, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len0 = WASM_VECTOR_LEN;
    _assertClass(delegatee_pubkey, PublicKey);
    _assertClass(created_at, Timestamp);
    const ret = wasm.validateDelegationTag(ptr0, len0, delegatee_pubkey.__wbg_ptr, event_kind, created_at.__wbg_ptr);
    return ret !== 0;
};

/**
* Sign delegation (NIP26)
* @param {Keys} keys
* @param {PublicKey} delegatee_pk
* @param {string} conditions
* @returns {string}
*/
module.exports.signDelegation = function(keys, delegatee_pk, conditions) {
    let deferred3_0;
    let deferred3_1;
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(keys, Keys);
        _assertClass(delegatee_pk, PublicKey);
        const ptr0 = passStringToWasm0(conditions, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.signDelegation(retptr, keys.__wbg_ptr, delegatee_pk.__wbg_ptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
            ptr2 = 0; len2 = 0;
            throw takeObject(r2);
        }
        deferred3_0 = ptr2;
        deferred3_1 = len2;
        return getStringFromWasm0(ptr2, len2);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_4(deferred3_0, deferred3_1, 1);
    }
};

/**
* Verify delegation signature (NIP26)
* @param {PublicKey} delegator_public_key
* @param {PublicKey} delegatee_public_key
* @param {string} conditions
* @param {string} signature
* @returns {boolean}
*/
module.exports.verifyDelegationSignature = function(delegator_public_key, delegatee_public_key, conditions, signature) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(delegator_public_key, PublicKey);
        _assertClass(delegatee_public_key, PublicKey);
        const ptr0 = passStringToWasm0(conditions, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(signature, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        wasm.verifyDelegationSignature(retptr, delegator_public_key.__wbg_ptr, delegatee_public_key.__wbg_ptr, ptr0, len0, ptr1, len1);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return r0 !== 0;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
};

/**
* Encrypt (NIP44)
* @param {SecretKey} sk
* @param {PublicKey} pk
* @param {string} content
* @param {NIP44Version} version
* @returns {string}
*/
module.exports.nip44Encrypt = function(sk, pk, content, version) {
    let deferred3_0;
    let deferred3_1;
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(sk, SecretKey);
        _assertClass(pk, PublicKey);
        const ptr0 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.nip44Encrypt(retptr, sk.__wbg_ptr, pk.__wbg_ptr, ptr0, len0, version);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
            ptr2 = 0; len2 = 0;
            throw takeObject(r2);
        }
        deferred3_0 = ptr2;
        deferred3_1 = len2;
        return getStringFromWasm0(ptr2, len2);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_4(deferred3_0, deferred3_1, 1);
    }
};

/**
* Decrypt (NIP44)
* @param {SecretKey} sk
* @param {PublicKey} pk
* @param {string} payload
* @returns {string}
*/
module.exports.nip44Decrypt = function(sk, pk, payload) {
    let deferred3_0;
    let deferred3_1;
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(sk, SecretKey);
        _assertClass(pk, PublicKey);
        const ptr0 = passStringToWasm0(payload, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.nip44Decrypt(retptr, sk.__wbg_ptr, pk.__wbg_ptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
            ptr2 = 0; len2 = 0;
            throw takeObject(r2);
        }
        deferred3_0 = ptr2;
        deferred3_1 = len2;
        return getStringFromWasm0(ptr2, len2);
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_export_4(deferred3_0, deferred3_1, 1);
    }
};

let cachedBigInt64Memory0 = null;

function getBigInt64Memory0() {
    if (cachedBigInt64Memory0 === null || cachedBigInt64Memory0.byteLength === 0) {
        cachedBigInt64Memory0 = new BigInt64Array(wasm.memory.buffer);
    }
    return cachedBigInt64Memory0;
}

let cachedFloat64Memory0 = null;

function getFloat64Memory0() {
    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {
        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);
    }
    return cachedFloat64Memory0;
}
/**
* @param {Event} event
* @returns {(RelayListItem)[]}
*/
module.exports.extractRelayList = function(event) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        _assertClass(event, Event);
        wasm.extractRelayList(retptr, event.__wbg_ptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_4(r0, r1 * 4, 4);
        return v1;
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
};

function passArrayF64ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 8, 8) >>> 0;
    getFloat64Memory0().set(arg, ptr / 8);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
/**
* Run some stuff when the Wasm module is instantiated.
*
* Right now, it does the following:
*
* * Redirect Rust panics to JavaScript console.
*/
module.exports.start = function() {
    wasm.start();
};

function handleError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        wasm.__wbindgen_export_5(addHeapObject(e));
    }
}
function __wbg_adapter_650(arg0, arg1, arg2, arg3) {
    wasm.__wbindgen_export_6(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));
}

/**
*/
module.exports.DataVendingMachineStatus = Object.freeze({ PaymentRequired:0,"0":"PaymentRequired",Processing:1,"1":"Processing",Error:2,"2":"Error",Success:3,"3":"Success",Partial:4,"4":"Partial", });
/**
* Encrypted Secret Key version (NIP49)
*/
module.exports.EncryptedSecretKeyVersion = Object.freeze({ V2:0,"0":"V2", });
/**
* NIP47 Response Error codes
*/
module.exports.Nip47ErrorCode = Object.freeze({
/**
*  The client is sending commands too fast.
*/
RateLimited:0,"0":"RateLimited",
/**
* The command is not known of is intentionally not implemented
*/
NotImplemented:1,"1":"NotImplemented",
/**
* The wallet does not have enough funds to cover a fee reserve or the payment amount
*/
InsufficientBalance:2,"2":"InsufficientBalance",
/**
* The payment failed. This may be due to a timeout, exhausting all routes, insufficient capacity or similar.
*/
PaymentFailed:3,"3":"PaymentFailed",
/**
* The invoice could not be found by the given parameters.
*/
NotFound:4,"4":"NotFound",
/**
* The wallet has exceeded its spending quota
*/
QuotaExceeded:5,"5":"QuotaExceeded",
/**
* This public key is not allowed to do this operation
*/
Restricted:6,"6":"Restricted",
/**
* This public key has no wallet connected
*/
Unauthorized:7,"7":"Unauthorized",
/**
* An internal error
*/
Internal:8,"8":"Internal",
/**
* Other error
*/
Other:9,"9":"Other", });
/**
* Transaction Type
*/
module.exports.TransactionType = Object.freeze({
/**
* Incoming payments
*/
Incoming:0,"0":"Incoming",
/**
* Outgoing payments
*/
Outgoing:1,"1":"Outgoing", });
/**
* Key security
*/
module.exports.KeySecurity = Object.freeze({
/**
* The key has been known to have been handled insecurely (stored unencrypted, cut and paste unencrypted, etc)
*/
Weak:0,"0":"Weak",
/**
* The key has NOT been known to have been handled insecurely (stored encrypted, cut and paste encrypted, etc)
*/
Medium:1,"1":"Medium",
/**
* The client does not track this data
*/
Unknown:2,"2":"Unknown", });
/**
*/
module.exports.ZapType = Object.freeze({
/**
* Public
*/
Public:0,"0":"Public",
/**
* Private
*/
Private:1,"1":"Private",
/**
* Anonymous
*/
Anonymous:2,"2":"Anonymous", });
/**
*/
module.exports.HttpMethod = Object.freeze({ GET:0,"0":"GET",POST:1,"1":"POST",PUT:2,"2":"PUT",PATCH:3,"3":"PATCH", });
/**
*/
module.exports.Alphabet = Object.freeze({ A:0,"0":"A",B:1,"1":"B",C:2,"2":"C",D:3,"3":"D",E:4,"4":"E",F:5,"5":"F",G:6,"6":"G",H:7,"7":"H",I:8,"8":"I",J:9,"9":"J",K:10,"10":"K",L:11,"11":"L",M:12,"12":"M",N:13,"13":"N",O:14,"14":"O",P:15,"15":"P",Q:16,"16":"Q",R:17,"17":"R",S:18,"18":"S",T:19,"19":"T",U:20,"20":"U",V:21,"21":"V",W:22,"22":"W",X:23,"23":"X",Y:24,"24":"Y",Z:25,"25":"Z", });
/**
*/
module.exports.NIP44Version = Object.freeze({
/**
* V1 - Deprecated
*/
Deprecated:1,"1":"Deprecated",V2:2,"2":"V2", });
/**
*/
module.exports.RelayMetadata = Object.freeze({ Read:0,"0":"Read",Write:1,"1":"Write", });

const Aes256GcmFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_aes256gcm_free(ptr >>> 0));
/**
*/
class Aes256Gcm {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Aes256Gcm.prototype);
        obj.__wbg_ptr = ptr;
        Aes256GcmFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Aes256GcmFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_aes256gcm_free(ptr);
    }
    /**
    * @returns {string}
    */
    get key() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_key(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} arg0
    */
    set key(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_key(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {string}
    */
    get iv() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_iv(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} arg0
    */
    set iv(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_iv(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @param {string} key
    * @param {string} iv
    */
    constructor(key, iv) {
        const ptr0 = passStringToWasm0(key, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(iv, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.aes256gcm_new(ptr0, len0, ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
}
module.exports.Aes256Gcm = Aes256Gcm;

const ArticlesCurationFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_articlescuration_free(ptr >>> 0));
/**
* Groups of articles picked by users as interesting and/or belonging to the same category
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
class ArticlesCuration {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ArticlesCurationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_articlescuration_free(ptr);
    }
    /**
    * @returns {(Coordinate)[]}
    */
    get coordinate() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_articlescuration_coordinate(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(Coordinate)[]} arg0
    */
    set coordinate(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_articlescuration_coordinate(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(EventId)[]}
    */
    get event_ids() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_articlescuration_event_ids(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(EventId)[]} arg0
    */
    set event_ids(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_articlescuration_event_ids(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.ArticlesCuration = ArticlesCuration;

const BookmarksFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_bookmarks_free(ptr >>> 0));
/**
* Uncategorized, "global" list of things a user wants to save
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
class Bookmarks {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BookmarksFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_bookmarks_free(ptr);
    }
    /**
    * @returns {(EventId)[]}
    */
    get event_ids() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_bookmarks_event_ids(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(EventId)[]} arg0
    */
    set event_ids(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_bookmarks_event_ids(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(Coordinate)[]}
    */
    get coordinate() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_bookmarks_coordinate(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(Coordinate)[]} arg0
    */
    set coordinate(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_bookmarks_coordinate(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(string)[]}
    */
    get hashtags() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_bookmarks_hashtags(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(string)[]} arg0
    */
    set hashtags(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_bookmarks_hashtags(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(string)[]}
    */
    get urls() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_bookmarks_urls(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(string)[]} arg0
    */
    set urls(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_bookmarks_urls(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.Bookmarks = Bookmarks;

const ClientMessageFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_clientmessage_free(ptr >>> 0));
/**
*/
class ClientMessage {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ClientMessage.prototype);
        obj.__wbg_ptr = ptr;
        ClientMessageFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ClientMessageFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_clientmessage_free(ptr);
    }
    /**
    * Create new `EVENT` message
    * @param {Event} event
    * @returns {ClientMessage}
    */
    static event(event) {
        _assertClass(event, Event);
        const ret = wasm.clientmessage_event(event.__wbg_ptr);
        return ClientMessage.__wrap(ret);
    }
    /**
    * Create new `REQ` message
    * @param {string} subscription_id
    * @param {(Filter)[]} filters
    * @returns {ClientMessage}
    */
    static req(subscription_id, filters) {
        const ptr0 = passStringToWasm0(subscription_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(filters, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.clientmessage_req(ptr0, len0, ptr1, len1);
        return ClientMessage.__wrap(ret);
    }
    /**
    * Create new `COUNT` message
    * @param {string} subscription_id
    * @param {(Filter)[]} filters
    * @returns {ClientMessage}
    */
    static count(subscription_id, filters) {
        const ptr0 = passStringToWasm0(subscription_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(filters, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.clientmessage_count(ptr0, len0, ptr1, len1);
        return ClientMessage.__wrap(ret);
    }
    /**
    * Create new `CLOSE` message
    * @param {string} subscription_id
    * @returns {ClientMessage}
    */
    static close(subscription_id) {
        const ptr0 = passStringToWasm0(subscription_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.clientmessage_close(ptr0, len0);
        return ClientMessage.__wrap(ret);
    }
    /**
    * Create new `AUTH` message
    * @param {Event} event
    * @returns {ClientMessage}
    */
    static auth(event) {
        _assertClass(event, Event);
        const ret = wasm.clientmessage_auth(event.__wbg_ptr);
        return ClientMessage.__wrap(ret);
    }
    /**
    * Deserialize `ClientMessage` from JSON string
    *
    * **This method NOT verify the event signature!**
    * @param {string} json
    * @returns {ClientMessage}
    */
    static fromJson(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.clientmessage_fromJson(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ClientMessage.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    asJson() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.clientmessage_asJson(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.ClientMessage = ClientMessage;

const ContactFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_contact_free(ptr >>> 0));
/**
*/
class Contact {

    static __unwrap(jsValue) {
        if (!(jsValue instanceof Contact)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ContactFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_contact_free(ptr);
    }
    /**
    * @param {PublicKey} public_key
    * @param {string | undefined} [relay_url]
    * @param {string | undefined} [alias]
    */
    constructor(public_key, relay_url, alias) {
        _assertClass(public_key, PublicKey);
        var ptr0 = isLikeNone(relay_url) ? 0 : passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(alias) ? 0 : passStringToWasm0(alias, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len1 = WASM_VECTOR_LEN;
        const ret = wasm.contact_new(public_key.__wbg_ptr, ptr0, len0, ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
}
module.exports.Contact = Contact;

const CoordinateFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_coordinate_free(ptr >>> 0));
/**
*/
class Coordinate {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Coordinate.prototype);
        obj.__wbg_ptr = ptr;
        CoordinateFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof Coordinate)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CoordinateFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_coordinate_free(ptr);
    }
    /**
    * @param {number} kind
    * @param {PublicKey} public_key
    * @param {string | undefined} [identifier]
    * @param {(string)[] | undefined} [relays]
    */
    constructor(kind, public_key, identifier, relays) {
        _assertClass(public_key, PublicKey);
        var ptr0 = isLikeNone(identifier) ? 0 : passStringToWasm0(identifier, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(relays) ? 0 : passArrayJsValueToWasm0(relays, wasm.__wbindgen_export_0);
        var len1 = WASM_VECTOR_LEN;
        const ret = wasm.coordinate_new(kind, public_key.__wbg_ptr, ptr0, len0, ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @returns {number}
    */
    get kind() {
        const ret = wasm.coordinate_kind(this.__wbg_ptr);
        return ret;
    }
    /**
    * @returns {PublicKey}
    */
    get publicKey() {
        const ret = wasm.coordinate_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {string}
    */
    get identifier() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.coordinate_identifier(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {(string)[]}
    */
    get relays() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.coordinate_relays(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Coordinate = Coordinate;

const EmojiInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_emojiinfo_free(ptr >>> 0));
/**
* Emoji
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
class EmojiInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(EmojiInfo.prototype);
        obj.__wbg_ptr = ptr;
        EmojiInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof EmojiInfo)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EmojiInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_emojiinfo_free(ptr);
    }
    /**
    * @returns {string}
    */
    get shortcode() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_key(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} arg0
    */
    set shortcode(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_key(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {string}
    */
    get url() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_iv(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} arg0
    */
    set url(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_iv(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.EmojiInfo = EmojiInfo;

const EmojisFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_emojis_free(ptr >>> 0));
/**
* User preferred emojis and pointers to emoji sets
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
class Emojis {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EmojisFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_emojis_free(ptr);
    }
    /**
    * @returns {(EmojiInfo)[]}
    */
    get emojis() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_emojis_emojis(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(EmojiInfo)[]} arg0
    */
    set emojis(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_emojis_emojis(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(Coordinate)[]}
    */
    get coordinate() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_bookmarks_coordinate(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(Coordinate)[]} arg0
    */
    set coordinate(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_bookmarks_coordinate(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.Emojis = Emojis;

const EncryptedSecretKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_encryptedsecretkey_free(ptr >>> 0));
/**
* Encrypted Secret Key
*/
class EncryptedSecretKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(EncryptedSecretKey.prototype);
        obj.__wbg_ptr = ptr;
        EncryptedSecretKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EncryptedSecretKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_encryptedsecretkey_free(ptr);
    }
    /**
    * Encrypt secret key
    * @param {SecretKey} secret_key
    * @param {string} password
    * @param {number} log_n
    * @param {KeySecurity} key_security
    */
    constructor(secret_key, password, log_n, key_security) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(secret_key, SecretKey);
            const ptr0 = passStringToWasm0(password, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.encryptedsecretkey_new(retptr, secret_key.__wbg_ptr, ptr0, len0, log_n, key_security);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            this.__wbg_ptr = r0 >>> 0;
            return this;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} bech32
    * @returns {EncryptedSecretKey}
    */
    static fromBech32(bech32) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.encryptedsecretkey_fromBech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EncryptedSecretKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Get encrypted secret key version
    * @returns {EncryptedSecretKeyVersion}
    */
    version() {
        const ret = wasm.encryptedsecretkey_version(this.__wbg_ptr);
        return ret;
    }
    /**
    * Get encrypted secret key security
    * @returns {KeySecurity}
    */
    keySecurity() {
        const ret = wasm.encryptedsecretkey_keySecurity(this.__wbg_ptr);
        return ret;
    }
    /**
    * Consume `EncryptedSecretKey` and return `SecretKey`
    * @param {string} password
    * @returns {SecretKey}
    */
    toSecretKey(password) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(password, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.encryptedsecretkey_toSecretKey(retptr, ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SecretKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Decrypt to `SecretKey`
    * @param {string} password
    * @returns {SecretKey}
    */
    asSecretKey(password) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(password, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.encryptedsecretkey_asSecretKey(retptr, this.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SecretKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    toBech32() {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.encryptedsecretkey_toBech32(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred2_0, deferred2_1, 1);
        }
    }
}
module.exports.EncryptedSecretKey = EncryptedSecretKey;

const EventFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_event_free(ptr >>> 0));
/**
*/
class Event {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Event.prototype);
        obj.__wbg_ptr = ptr;
        EventFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof Event)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EventFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_event_free(ptr);
    }
    /**
    * @returns {EventId}
    */
    get id() {
        const ret = wasm.event_id(this.__wbg_ptr);
        return EventId.__wrap(ret);
    }
    /**
    * Get event author (`pubkey` field)
    * @returns {PublicKey}
    */
    get author() {
        const ret = wasm.coordinate_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {Timestamp}
    */
    get createdAt() {
        const ret = wasm.event_createdAt(this.__wbg_ptr);
        return Timestamp.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    get kind() {
        const ret = wasm.event_kind(this.__wbg_ptr);
        return ret;
    }
    /**
    * @returns {(Tag)[]}
    */
    get tags() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.event_tags(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    get content() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.event_content(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    get signature() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.event_signature(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {boolean}
    */
    verify() {
        const ret = wasm.event_verify(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * @param {string} json
    * @returns {Event}
    */
    static fromJson(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.event_fromJson(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    asJson() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.event_asJson(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.Event = Event;

const EventBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_eventbuilder_free(ptr >>> 0));
/**
*/
class EventBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(EventBuilder.prototype);
        obj.__wbg_ptr = ptr;
        EventBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EventBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_eventbuilder_free(ptr);
    }
    /**
    * @param {number} kind
    * @param {string} content
    * @param {(Tag)[]} tags
    */
    constructor(kind, content, tags) {
        const ptr0 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(tags, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_new(kind, ptr0, len0, ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Set a custom `created_at` UNIX timestamp
    * @param {Timestamp} created_at
    * @returns {EventBuilder}
    */
    customCreatedAt(created_at) {
        const ptr = this.__destroy_into_raw();
        _assertClass(created_at, Timestamp);
        var ptr0 = created_at.__destroy_into_raw();
        const ret = wasm.eventbuilder_customCreatedAt(ptr, ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Build `Event`
    *
    * **This method consume the builder, so it will no longer be usable!**
    * @param {Keys} keys
    * @returns {Event}
    */
    toEvent(keys) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(keys, Keys);
            wasm.eventbuilder_toEvent(retptr, ptr, keys.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Build `UnsignedEvent`
    *
    * **This method consume the builder, so it will no longer be usable!**
    * @param {PublicKey} public_key
    * @returns {UnsignedEvent}
    */
    toUnsignedEvent(public_key) {
        const ptr = this.__destroy_into_raw();
        _assertClass(public_key, PublicKey);
        const ret = wasm.eventbuilder_toUnsignedEvent(ptr, public_key.__wbg_ptr);
        return UnsignedEvent.__wrap(ret);
    }
    /**
    * Build POW `Event`
    *
    * **This method consume the builder, so it will no longer be usable!**
    * @param {Keys} keys
    * @param {number} difficulty
    * @returns {Event}
    */
    toPowEvent(keys, difficulty) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(keys, Keys);
            wasm.eventbuilder_toPowEvent(retptr, ptr, keys.__wbg_ptr, difficulty);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Build Unisgned POW Event
    *
    * **This method consume the builder, so it will no longer be usable!**
    * @param {PublicKey} public_key
    * @param {number} difficulty
    * @returns {UnsignedEvent}
    */
    toUnsignedPowEvent(public_key, difficulty) {
        const ptr = this.__destroy_into_raw();
        _assertClass(public_key, PublicKey);
        const ret = wasm.eventbuilder_toUnsignedPowEvent(ptr, public_key.__wbg_ptr, difficulty);
        return UnsignedEvent.__wrap(ret);
    }
    /**
    * @param {Metadata} metadata
    * @returns {EventBuilder}
    */
    static metadata(metadata) {
        _assertClass(metadata, Metadata);
        const ret = wasm.eventbuilder_metadata(metadata.__wbg_ptr);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {(RelayListItem)[]} relays
    * @returns {EventBuilder}
    */
    static relayList(relays) {
        const ptr0 = passArrayJsValueToWasm0(relays, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_relayList(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {string} content
    * @param {(Tag)[]} tags
    * @returns {EventBuilder}
    */
    static textNote(content, tags) {
        const ptr0 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(tags, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_textNote(ptr0, len0, ptr1, len1);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Text note reply
    *
    * If no `root` is passed, the `rely_to` will be used for root `e` tag.
    *
    * <https://github.com/nostr-protocol/nips/blob/master/10.md>
    * @param {string} content
    * @param {Event} reply_to
    * @param {Event | undefined} [root]
    * @param {string | undefined} [relay_url]
    * @returns {EventBuilder}
    */
    static textNoteReply(content, reply_to, root, relay_url) {
        const ptr0 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(reply_to, Event);
        let ptr1 = 0;
        if (!isLikeNone(root)) {
            _assertClass(root, Event);
            ptr1 = root.__destroy_into_raw();
        }
        var ptr2 = isLikeNone(relay_url) ? 0 : passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len2 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_textNoteReply(ptr0, len0, reply_to.__wbg_ptr, ptr1, ptr2, len2);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {string} content
    * @param {(Tag)[]} tags
    * @returns {EventBuilder}
    */
    static longFormTextNote(content, tags) {
        const ptr0 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(tags, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_longFormTextNote(ptr0, len0, ptr1, len1);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {(Contact)[]} list
    * @returns {EventBuilder}
    */
    static contactList(list) {
        const ptr0 = passArrayJsValueToWasm0(list, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_contactList(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {Keys} sender_keys
    * @param {PublicKey} receiver_pubkey
    * @param {string} content
    * @param {EventId | undefined} [reply_to]
    * @returns {EventBuilder}
    */
    static encryptedDirectMsg(sender_keys, receiver_pubkey, content, reply_to) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(sender_keys, Keys);
            _assertClass(receiver_pubkey, PublicKey);
            const ptr0 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            let ptr1 = 0;
            if (!isLikeNone(reply_to)) {
                _assertClass(reply_to, EventId);
                ptr1 = reply_to.__destroy_into_raw();
            }
            wasm.eventbuilder_encryptedDirectMsg(retptr, sender_keys.__wbg_ptr, receiver_pubkey.__wbg_ptr, ptr0, len0, ptr1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Repost
    * @param {Event} event
    * @param {string | undefined} [relay_url]
    * @returns {EventBuilder}
    */
    static repost(event, relay_url) {
        _assertClass(event, Event);
        var ptr0 = isLikeNone(relay_url) ? 0 : passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_repost(event.__wbg_ptr, ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {(EventId)[]} ids
    * @param {string | undefined} [reason]
    * @returns {EventBuilder}
    */
    static delete(ids, reason) {
        const ptr0 = passArrayJsValueToWasm0(ids, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(reason) ? 0 : passStringToWasm0(reason, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len1 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_delete(ptr0, len0, ptr1, len1);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Add reaction (like/upvote, dislike/downvote or emoji) to an event
    * @param {Event} event
    * @param {string} reaction
    * @returns {EventBuilder}
    */
    static reaction(event, reaction) {
        _assertClass(event, Event);
        const ptr0 = passStringToWasm0(reaction, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_reaction(event.__wbg_ptr, ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Add reaction (like/upvote, dislike/downvote or emoji) to an event
    * @param {EventId} event_id
    * @param {PublicKey} public_key
    * @param {number} kind
    * @param {string} reaction
    * @returns {EventBuilder}
    */
    static reactionExtended(event_id, public_key, kind, reaction) {
        _assertClass(event_id, EventId);
        _assertClass(public_key, PublicKey);
        const ptr0 = passStringToWasm0(reaction, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_reactionExtended(event_id.__wbg_ptr, public_key.__wbg_ptr, kind, ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {Metadata} metadata
    * @returns {EventBuilder}
    */
    static channel(metadata) {
        _assertClass(metadata, Metadata);
        const ret = wasm.eventbuilder_channel(metadata.__wbg_ptr);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {EventId} channel_id
    * @param {string | undefined} relay_url
    * @param {Metadata} metadata
    * @returns {EventBuilder}
    */
    static channelMetadata(channel_id, relay_url, metadata) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(channel_id, EventId);
            var ptr0 = isLikeNone(relay_url) ? 0 : passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            var len0 = WASM_VECTOR_LEN;
            _assertClass(metadata, Metadata);
            wasm.eventbuilder_channelMetadata(retptr, channel_id.__wbg_ptr, ptr0, len0, metadata.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {EventId} channel_id
    * @param {string} relay_url
    * @param {string} content
    * @returns {EventBuilder}
    */
    static channelMsg(channel_id, relay_url, content) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(channel_id, EventId);
            const ptr0 = passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len1 = WASM_VECTOR_LEN;
            wasm.eventbuilder_channelMsg(retptr, channel_id.__wbg_ptr, ptr0, len0, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {EventId} message_id
    * @param {string | undefined} [reason]
    * @returns {EventBuilder}
    */
    static hideChannelMsg(message_id, reason) {
        _assertClass(message_id, EventId);
        var ptr0 = isLikeNone(reason) ? 0 : passStringToWasm0(reason, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_hideChannelMsg(message_id.__wbg_ptr, ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {PublicKey} pubkey
    * @param {string | undefined} [reason]
    * @returns {EventBuilder}
    */
    static muteChannelUser(pubkey, reason) {
        _assertClass(pubkey, PublicKey);
        var ptr0 = isLikeNone(reason) ? 0 : passStringToWasm0(reason, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_muteChannelUser(pubkey.__wbg_ptr, ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {string} challenge
    * @param {string} relay
    * @returns {EventBuilder}
    */
    static auth(challenge, relay) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(challenge, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passStringToWasm0(relay, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len1 = WASM_VECTOR_LEN;
            wasm.eventbuilder_auth(retptr, ptr0, len0, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {LiveEvent} live_event
    * @returns {EventBuilder}
    */
    static liveEvent(live_event) {
        _assertClass(live_event, LiveEvent);
        var ptr0 = live_event.__destroy_into_raw();
        const ret = wasm.eventbuilder_liveEvent(ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {string} live_event_id
    * @param {PublicKey} live_event_host
    * @param {string} content
    * @param {string | undefined} relay_url
    * @param {(Tag)[]} tags
    * @returns {EventBuilder}
    */
    static liveEventMsg(live_event_id, live_event_host, content, relay_url, tags) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(live_event_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            _assertClass(live_event_host, PublicKey);
            var ptr1 = live_event_host.__destroy_into_raw();
            const ptr2 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len2 = WASM_VECTOR_LEN;
            var ptr3 = isLikeNone(relay_url) ? 0 : passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            var len3 = WASM_VECTOR_LEN;
            const ptr4 = passArrayJsValueToWasm0(tags, wasm.__wbindgen_export_0);
            const len4 = WASM_VECTOR_LEN;
            wasm.eventbuilder_liveEventMsg(retptr, ptr0, len0, ptr1, ptr2, len2, ptr3, len3, ptr4, len4);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(Tag)[]} tags
    * @param {string} content
    * @returns {EventBuilder}
    */
    static report(tags, content) {
        const ptr0 = passArrayJsValueToWasm0(tags, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_report(ptr0, len0, ptr1, len1);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {ZapRequestData} data
    * @returns {EventBuilder}
    */
    static publicZapRequest(data) {
        _assertClass(data, ZapRequestData);
        var ptr0 = data.__destroy_into_raw();
        const ret = wasm.eventbuilder_publicZapRequest(ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {string} bolt11
    * @param {string | undefined} preimage
    * @param {Event} zap_request
    * @returns {EventBuilder}
    */
    static zapReceipt(bolt11, preimage, zap_request) {
        const ptr0 = passStringToWasm0(bolt11, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(preimage) ? 0 : passStringToWasm0(preimage, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len1 = WASM_VECTOR_LEN;
        _assertClass(zap_request, Event);
        var ptr2 = zap_request.__destroy_into_raw();
        const ret = wasm.eventbuilder_zapReceipt(ptr0, len0, ptr1, len1, ptr2);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {string} badge_id
    * @param {string | undefined} name
    * @param {string | undefined} description
    * @param {string | undefined} image
    * @param {ImageDimensions | undefined} image_dimensions
    * @param {(Thumbnails)[]} thumbnails
    * @returns {EventBuilder}
    */
    static defineBadge(badge_id, name, description, image, image_dimensions, thumbnails) {
        const ptr0 = passStringToWasm0(badge_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(name) ? 0 : passStringToWasm0(name, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len1 = WASM_VECTOR_LEN;
        var ptr2 = isLikeNone(description) ? 0 : passStringToWasm0(description, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len2 = WASM_VECTOR_LEN;
        var ptr3 = isLikeNone(image) ? 0 : passStringToWasm0(image, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len3 = WASM_VECTOR_LEN;
        let ptr4 = 0;
        if (!isLikeNone(image_dimensions)) {
            _assertClass(image_dimensions, ImageDimensions);
            ptr4 = image_dimensions.__destroy_into_raw();
        }
        const ptr5 = passArrayJsValueToWasm0(thumbnails, wasm.__wbindgen_export_0);
        const len5 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_defineBadge(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, ptr4, ptr5, len5);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {Event} badge_definition
    * @param {(Tag)[]} awarded_pubkeys
    * @returns {EventBuilder}
    */
    static awardBadge(badge_definition, awarded_pubkeys) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(badge_definition, Event);
            const ptr0 = passArrayJsValueToWasm0(awarded_pubkeys, wasm.__wbindgen_export_0);
            const len0 = WASM_VECTOR_LEN;
            wasm.eventbuilder_awardBadge(retptr, badge_definition.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(Event)[]} badge_definitions
    * @param {(Event)[]} badge_awards
    * @param {PublicKey} pubkey_awarded
    * @returns {EventBuilder}
    */
    static profileBadges(badge_definitions, badge_awards, pubkey_awarded) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArrayJsValueToWasm0(badge_definitions, wasm.__wbindgen_export_0);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passArrayJsValueToWasm0(badge_awards, wasm.__wbindgen_export_0);
            const len1 = WASM_VECTOR_LEN;
            _assertClass(pubkey_awarded, PublicKey);
            wasm.eventbuilder_profileBadges(retptr, ptr0, len0, ptr1, len1, pubkey_awarded.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {number} kind
    * @param {(Tag)[]} tags
    * @returns {EventBuilder}
    */
    static jobRequest(kind, tags) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArrayJsValueToWasm0(tags, wasm.__wbindgen_export_0);
            const len0 = WASM_VECTOR_LEN;
            wasm.eventbuilder_jobRequest(retptr, kind, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Event} job_request
    * @param {number} amount_millisats
    * @param {string | undefined} [bolt11]
    * @returns {EventBuilder}
    */
    static jobResult(job_request, amount_millisats, bolt11) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(job_request, Event);
            var ptr0 = isLikeNone(bolt11) ? 0 : passStringToWasm0(bolt11, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            var len0 = WASM_VECTOR_LEN;
            wasm.eventbuilder_jobResult(retptr, job_request.__wbg_ptr, amount_millisats, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Event} job_request
    * @param {DataVendingMachineStatus} status
    * @param {string | undefined} extra_info
    * @param {bigint} amount_millisats
    * @param {string | undefined} [bolt11]
    * @param {string | undefined} [payload]
    * @returns {EventBuilder}
    */
    static jobFeedback(job_request, status, extra_info, amount_millisats, bolt11, payload) {
        _assertClass(job_request, Event);
        var ptr0 = isLikeNone(extra_info) ? 0 : passStringToWasm0(extra_info, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(bolt11) ? 0 : passStringToWasm0(bolt11, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len1 = WASM_VECTOR_LEN;
        var ptr2 = isLikeNone(payload) ? 0 : passStringToWasm0(payload, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len2 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_jobFeedback(job_request.__wbg_ptr, status, ptr0, len0, amount_millisats, ptr1, len1, ptr2, len2);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {string} description
    * @param {FileMetadata} metadata
    * @returns {EventBuilder}
    */
    static fileMetadata(description, metadata) {
        const ptr0 = passStringToWasm0(description, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(metadata, FileMetadata);
        var ptr1 = metadata.__destroy_into_raw();
        const ret = wasm.eventbuilder_fileMetadata(ptr0, len0, ptr1);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {HttpData} data
    * @returns {EventBuilder}
    */
    static httpAuth(data) {
        _assertClass(data, HttpData);
        var ptr0 = data.__destroy_into_raw();
        const ret = wasm.eventbuilder_httpAuth(ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {StallData} data
    * @returns {EventBuilder}
    */
    static stallData(data) {
        _assertClass(data, StallData);
        const ret = wasm.eventbuilder_stallData(data.__wbg_ptr);
        return EventBuilder.__wrap(ret);
    }
    /**
    * @param {ProductData} data
    * @returns {EventBuilder}
    */
    static productData(data) {
        _assertClass(data, ProductData);
        var ptr0 = data.__destroy_into_raw();
        const ret = wasm.eventbuilder_productData(ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Gift Wrap from seal
    *
    * <https://github.com/nostr-protocol/nips/blob/master/59.md>
    * @param {PublicKey} receiver
    * @param {Event} seal
    * @param {Timestamp | undefined} [expiration]
    * @returns {Event}
    */
    static giftWrapFromSeal(receiver, seal, expiration) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(receiver, PublicKey);
            _assertClass(seal, Event);
            let ptr0 = 0;
            if (!isLikeNone(expiration)) {
                _assertClass(expiration, Timestamp);
                ptr0 = expiration.__destroy_into_raw();
            }
            wasm.eventbuilder_giftWrapFromSeal(retptr, receiver.__wbg_ptr, seal.__wbg_ptr, ptr0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Gift Wrap
    *
    * <https://github.com/nostr-protocol/nips/blob/master/59.md>
    * @param {Keys} sender_keys
    * @param {PublicKey} receiver
    * @param {UnsignedEvent} rumor
    * @param {Timestamp | undefined} [expiration]
    * @returns {Event}
    */
    static giftWrap(sender_keys, receiver, rumor, expiration) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(sender_keys, Keys);
            _assertClass(receiver, PublicKey);
            _assertClass(rumor, UnsignedEvent);
            let ptr0 = 0;
            if (!isLikeNone(expiration)) {
                _assertClass(expiration, Timestamp);
                ptr0 = expiration.__destroy_into_raw();
            }
            wasm.eventbuilder_giftWrap(retptr, sender_keys.__wbg_ptr, receiver.__wbg_ptr, rumor.__wbg_ptr, ptr0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * GiftWrapped Sealed Direct message
    * @param {PublicKey} receiver
    * @param {string} message
    * @returns {EventBuilder}
    */
    static sealedDirect(receiver, message) {
        _assertClass(receiver, PublicKey);
        const ptr0 = passStringToWasm0(message, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_sealedDirect(receiver.__wbg_ptr, ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Mute list
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {MuteList} list
    * @returns {EventBuilder}
    */
    static muteList(list) {
        _assertClass(list, MuteList);
        var ptr0 = list.__destroy_into_raw();
        const ret = wasm.eventbuilder_muteList(ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Pinned notes
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(EventId)[]} ids
    * @returns {EventBuilder}
    */
    static pinnedNotes(ids) {
        const ptr0 = passArrayJsValueToWasm0(ids, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_pinnedNotes(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Bookmarks
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {Bookmarks} list
    * @returns {EventBuilder}
    */
    static bookmarks(list) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(list, Bookmarks);
            var ptr0 = list.__destroy_into_raw();
            wasm.eventbuilder_bookmarks(retptr, ptr0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Communities
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(Coordinate)[]} communities
    * @returns {EventBuilder}
    */
    static communities(communities) {
        const ptr0 = passArrayJsValueToWasm0(communities, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_communities(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Public chats
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(EventId)[]} chat
    * @returns {EventBuilder}
    */
    static publicChats(chat) {
        const ptr0 = passArrayJsValueToWasm0(chat, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_publicChats(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Blocked relays
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(string)[]} relays
    * @returns {EventBuilder}
    */
    static blockedRelays(relays) {
        const ptr0 = passArrayJsValueToWasm0(relays, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_blockedRelays(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Search relays
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(string)[]} relays
    * @returns {EventBuilder}
    */
    static searchRelays(relays) {
        const ptr0 = passArrayJsValueToWasm0(relays, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_searchRelays(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Interests
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {Interests} list
    * @returns {EventBuilder}
    */
    static interests(list) {
        _assertClass(list, Interests);
        var ptr0 = list.__destroy_into_raw();
        const ret = wasm.eventbuilder_interests(ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Emojis
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {Emojis} list
    * @returns {EventBuilder}
    */
    static emojis(list) {
        _assertClass(list, Emojis);
        var ptr0 = list.__destroy_into_raw();
        const ret = wasm.eventbuilder_emojis(ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Follow sets
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(PublicKey)[]} public_keys
    * @returns {EventBuilder}
    */
    static followSets(public_keys) {
        const ptr0 = passArrayJsValueToWasm0(public_keys, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_followSets(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Relay sets
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(string)[]} relays
    * @returns {EventBuilder}
    */
    static relaySets(relays) {
        const ptr0 = passArrayJsValueToWasm0(relays, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_relaySets(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Bookmark sets
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {Bookmarks} list
    * @returns {EventBuilder}
    */
    static bookmarksSets(list) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(list, Bookmarks);
            var ptr0 = list.__destroy_into_raw();
            wasm.eventbuilder_bookmarksSets(retptr, ptr0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventBuilder.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Article Curation sets
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {ArticlesCuration} list
    * @returns {EventBuilder}
    */
    static articlesCurationSets(list) {
        _assertClass(list, ArticlesCuration);
        var ptr0 = list.__destroy_into_raw();
        const ret = wasm.eventbuilder_articlesCurationSets(ptr0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Videos Curation sets
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(Coordinate)[]} video
    * @returns {EventBuilder}
    */
    static videosCurationSets(video) {
        const ptr0 = passArrayJsValueToWasm0(video, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_videosCurationSets(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Emoji sets
    *
    * <https://github.com/nostr-protocol/nips/blob/master/51.md>
    * @param {(EmojiInfo)[]} emoji
    * @returns {EventBuilder}
    */
    static emojiSets(emoji) {
        const ptr0 = passArrayJsValueToWasm0(emoji, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_emojiSets(ptr0, len0);
        return EventBuilder.__wrap(ret);
    }
    /**
    * Label
    *
    * <https://github.com/nostr-protocol/nips/blob/master/32.md>
    * @param {string} label_namespace
    * @param {(string)[]} labels
    * @returns {EventBuilder}
    */
    static label(label_namespace, labels) {
        const ptr0 = passStringToWasm0(label_namespace, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(labels, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.eventbuilder_label(ptr0, len0, ptr1, len1);
        return EventBuilder.__wrap(ret);
    }
}
module.exports.EventBuilder = EventBuilder;

const EventIdFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_eventid_free(ptr >>> 0));
/**
*/
class EventId {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(EventId.prototype);
        obj.__wbg_ptr = ptr;
        EventIdFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof EventId)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        EventIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_eventid_free(ptr);
    }
    /**
    * @param {PublicKey} pubkey
    * @param {Timestamp} created_at
    * @param {number} kind
    * @param {(Tag)[]} tags
    * @param {string} content
    */
    constructor(pubkey, created_at, kind, tags, content) {
        _assertClass(pubkey, PublicKey);
        _assertClass(created_at, Timestamp);
        const ptr0 = passArrayJsValueToWasm0(tags, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(content, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.eventid_new(pubkey.__wbg_ptr, created_at.__wbg_ptr, kind, ptr0, len0, ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Try to parse event ID from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
    * @param {string} id
    * @returns {EventId}
    */
    static parse(id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.eventid_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {EventId}
    */
    static fromSlice(bytes) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_export_0);
            const len0 = WASM_VECTOR_LEN;
            wasm.eventid_fromSlice(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} hex
    * @returns {EventId}
    */
    static fromHex(hex) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.eventid_fromHex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} bech32
    * @returns {EventId}
    */
    static fromBech32(bech32) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.eventid_fromBech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    asBytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.eventid_asBytes(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    toHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.eventid_toHex(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    toBech32() {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.eventid_toBech32(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred2_0, deferred2_1, 1);
        }
    }
}
module.exports.EventId = EventId;

const FileMetadataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_filemetadata_free(ptr >>> 0));
/**
*/
class FileMetadata {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FileMetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_filemetadata_free(ptr);
    }
    /**
    * @param {string} url
    * @param {string} mime_type
    * @param {string} hash
    */
    constructor(url, mime_type, hash) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passStringToWasm0(mime_type, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len1 = WASM_VECTOR_LEN;
            const ptr2 = passStringToWasm0(hash, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len2 = WASM_VECTOR_LEN;
            wasm.filemetadata_new(retptr, ptr0, len0, ptr1, len1, ptr2, len2);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            this.__wbg_ptr = r0 >>> 0;
            return this;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    get urls() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.filemetadata_urls(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    get mimeType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.filemetadata_mimeType(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    get hash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.filemetadata_hash(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {Aes256Gcm | undefined}
    */
    get aes256Gcm() {
        const ret = wasm.filemetadata_aes256Gcm(this.__wbg_ptr);
        return ret === 0 ? undefined : Aes256Gcm.__wrap(ret);
    }
    /**
    * @returns {number | undefined}
    */
    get size() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.filemetadata_size(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getFloat64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {ImageDimensions | undefined}
    */
    get dim() {
        const ret = wasm.filemetadata_dim(this.__wbg_ptr);
        return ret === 0 ? undefined : ImageDimensions.__wrap(ret);
    }
    /**
    * @returns {string | undefined}
    */
    get magnet() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.filemetadata_magnet(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get blurhash() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.filemetadata_blurhash(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.FileMetadata = FileMetadata;

const FilterFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_filter_free(ptr >>> 0));
/**
*/
class Filter {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Filter.prototype);
        obj.__wbg_ptr = ptr;
        FilterFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof Filter)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FilterFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_filter_free(ptr);
    }
    /**
    */
    constructor() {
        const ret = wasm.filter_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @param {string} json
    * @returns {Filter}
    */
    static fromJson(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.filter_fromJson(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Filter.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    asJson() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.filter_asJson(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Set subscription id
    * @param {EventId} id
    * @returns {Filter}
    */
    id(id) {
        const ptr = this.__destroy_into_raw();
        _assertClass(id, EventId);
        const ret = wasm.filter_id(ptr, id.__wbg_ptr);
        return Filter.__wrap(ret);
    }
    /**
    * Set subscription ids
    * @param {(EventId)[]} ids
    * @returns {Filter}
    */
    ids(ids) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(ids, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_ids(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set author
    * @param {PublicKey} author
    * @returns {Filter}
    */
    author(author) {
        const ptr = this.__destroy_into_raw();
        _assertClass(author, PublicKey);
        const ret = wasm.filter_author(ptr, author.__wbg_ptr);
        return Filter.__wrap(ret);
    }
    /**
    * Set authors
    * @param {(PublicKey)[]} authors
    * @returns {Filter}
    */
    authors(authors) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(authors, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_authors(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set kind
    * @param {number} kind
    * @returns {Filter}
    */
    kind(kind) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.filter_kind(ptr, kind);
        return Filter.__wrap(ret);
    }
    /**
    * Set kinds
    * @param {Float64Array} kinds
    * @returns {Filter}
    */
    kinds(kinds) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayF64ToWasm0(kinds, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_kinds(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set event
    * @param {EventId} id
    * @returns {Filter}
    */
    event(id) {
        const ptr = this.__destroy_into_raw();
        _assertClass(id, EventId);
        const ret = wasm.filter_event(ptr, id.__wbg_ptr);
        return Filter.__wrap(ret);
    }
    /**
    * Set events
    * @param {(EventId)[]} ids
    * @returns {Filter}
    */
    events(ids) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(ids, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_events(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set pubkey
    * @param {PublicKey} pubkey
    * @returns {Filter}
    */
    pubkey(pubkey) {
        const ptr = this.__destroy_into_raw();
        _assertClass(pubkey, PublicKey);
        const ret = wasm.filter_pubkey(ptr, pubkey.__wbg_ptr);
        return Filter.__wrap(ret);
    }
    /**
    * Set pubkeys
    * @param {(PublicKey)[]} pubkeys
    * @returns {Filter}
    */
    pubkeys(pubkeys) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(pubkeys, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_pubkeys(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set hashtag
    *
    * <https://github.com/nostr-protocol/nips/blob/master/12.md>
    * @param {string} hashtag
    * @returns {Filter}
    */
    hashtag(hashtag) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passStringToWasm0(hashtag, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_hashtag(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set hashtags
    *
    * <https://github.com/nostr-protocol/nips/blob/master/12.md>
    * @param {(string)[]} hashtags
    * @returns {Filter}
    */
    hashtags(hashtags) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(hashtags, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_hashtags(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set reference
    *
    * <https://github.com/nostr-protocol/nips/blob/master/12.md>
    * @param {string} v
    * @returns {Filter}
    */
    reference(v) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passStringToWasm0(v, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_reference(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set references
    *
    * <https://github.com/nostr-protocol/nips/blob/master/12.md>
    * @param {(string)[]} v
    * @returns {Filter}
    */
    references(v) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(v, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_references(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set search field
    * @param {string} value
    * @returns {Filter}
    */
    search(value) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passStringToWasm0(value, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_search(ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Set since unix timestamp
    * @param {Timestamp} since
    * @returns {Filter}
    */
    since(since) {
        const ptr = this.__destroy_into_raw();
        _assertClass(since, Timestamp);
        const ret = wasm.filter_since(ptr, since.__wbg_ptr);
        return Filter.__wrap(ret);
    }
    /**
    * Set until unix timestamp
    * @param {Timestamp} until
    * @returns {Filter}
    */
    until(until) {
        const ptr = this.__destroy_into_raw();
        _assertClass(until, Timestamp);
        const ret = wasm.filter_until(ptr, until.__wbg_ptr);
        return Filter.__wrap(ret);
    }
    /**
    * Set limit
    * @param {number} limit
    * @returns {Filter}
    */
    limit(limit) {
        const ptr = this.__destroy_into_raw();
        const ret = wasm.filter_limit(ptr, limit);
        return Filter.__wrap(ret);
    }
    /**
    * @param {SingleLetterTag} tag
    * @param {(string)[]} values
    * @returns {Filter}
    */
    customTag(tag, values) {
        const ptr = this.__destroy_into_raw();
        _assertClass(tag, SingleLetterTag);
        const ptr0 = passArrayJsValueToWasm0(values, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_customTag(ptr, tag.__wbg_ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * @param {SingleLetterTag} tag
    * @param {(string)[]} values
    * @returns {Filter}
    */
    removeCustomTag(tag, values) {
        const ptr = this.__destroy_into_raw();
        _assertClass(tag, SingleLetterTag);
        const ptr0 = passArrayJsValueToWasm0(values, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.filter_removeCustomTag(ptr, tag.__wbg_ptr, ptr0, len0);
        return Filter.__wrap(ret);
    }
    /**
    * Determine if `Filter` match given `Event`.
    *
    * The `search` filed is not supported yet!
    * @param {Event} event
    * @returns {boolean}
    */
    matchEvent(event) {
        _assertClass(event, Event);
        const ret = wasm.filter_matchEvent(this.__wbg_ptr, event.__wbg_ptr);
        return ret !== 0;
    }
}
module.exports.Filter = Filter;

const GetBalanceResponseResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_getbalanceresponseresult_free(ptr >>> 0));
/**
*/
class GetBalanceResponseResult {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GetBalanceResponseResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_getbalanceresponseresult_free(ptr);
    }
    /**
    * Balance amount in msats
    * @returns {bigint}
    */
    get balance() {
        const ret = wasm.__wbg_get_getbalanceresponseresult_balance(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * Balance amount in msats
    * @param {bigint} arg0
    */
    set balance(arg0) {
        wasm.__wbg_set_getbalanceresponseresult_balance(this.__wbg_ptr, arg0);
    }
}
module.exports.GetBalanceResponseResult = GetBalanceResponseResult;

const GetInfoResponseResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_getinforesponseresult_free(ptr >>> 0));
/**
*/
class GetInfoResponseResult {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GetInfoResponseResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_getinforesponseresult_free(ptr);
    }
    /**
    * The alias of the lightning node
    * @returns {string}
    */
    get alias() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_key(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * The alias of the lightning node
    * @param {string} arg0
    */
    set alias(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_key(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * The color of the current node in hex code format
    * @returns {string}
    */
    get color() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_iv(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * The color of the current node in hex code format
    * @param {string} arg0
    */
    set color(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_iv(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Lightning Node's public key
    * @returns {string}
    */
    get pubkey() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_getinforesponseresult_pubkey(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Lightning Node's public key
    * @param {string} arg0
    */
    set pubkey(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_getinforesponseresult_pubkey(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Active network
    * @returns {string}
    */
    get network() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_getinforesponseresult_network(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Active network
    * @param {string} arg0
    */
    set network(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_getinforesponseresult_network(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Current block height
    * @returns {number}
    */
    get block_height() {
        const ret = wasm.__wbg_get_getinforesponseresult_block_height(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
    * Current block height
    * @param {number} arg0
    */
    set block_height(arg0) {
        wasm.__wbg_set_getinforesponseresult_block_height(this.__wbg_ptr, arg0);
    }
    /**
    * Most Recent Block Hash
    * @returns {string}
    */
    get block_hash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_getinforesponseresult_block_hash(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Most Recent Block Hash
    * @param {string} arg0
    */
    set block_hash(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_getinforesponseresult_block_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Available methods for this connection
    * @returns {(string)[]}
    */
    get methods() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_getinforesponseresult_methods(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Available methods for this connection
    * @param {(string)[]} arg0
    */
    set methods(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_getinforesponseresult_methods(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.GetInfoResponseResult = GetInfoResponseResult;

const HttpDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_httpdata_free(ptr >>> 0));
/**
*/
class HttpData {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        HttpDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_httpdata_free(ptr);
    }
    /**
    * @param {string} url
    * @param {HttpMethod} method
    */
    constructor(url, method) {
        const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.httpdata_new(ptr0, len0, method);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @returns {string}
    */
    get urls() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.httpdata_urls(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {HttpMethod}
    */
    get method() {
        const ret = wasm.httpdata_method(this.__wbg_ptr);
        return ret;
    }
    /**
    * @returns {string | undefined}
    */
    get payload() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.httpdata_payload(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.HttpData = HttpData;

const ImageFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_image_free(ptr >>> 0));
/**
*/
class Image {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Image.prototype);
        obj.__wbg_ptr = ptr;
        ImageFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ImageFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_image_free(ptr);
    }
    /**
    * @returns {string}
    */
    get url() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_image_url(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} arg0
    */
    set url(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_image_url(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {ImageDimensions | undefined}
    */
    get dimensions() {
        const ret = wasm.__wbg_get_image_dimensions(this.__wbg_ptr);
        return ret === 0 ? undefined : ImageDimensions.__wrap(ret);
    }
    /**
    * @param {ImageDimensions | undefined} [arg0]
    */
    set dimensions(arg0) {
        let ptr0 = 0;
        if (!isLikeNone(arg0)) {
            _assertClass(arg0, ImageDimensions);
            ptr0 = arg0.__destroy_into_raw();
        }
        wasm.__wbg_set_image_dimensions(this.__wbg_ptr, ptr0);
    }
    /**
    * @param {string} url
    * @param {ImageDimensions | undefined} [dimensions]
    */
    constructor(url, dimensions) {
        const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        let ptr1 = 0;
        if (!isLikeNone(dimensions)) {
            _assertClass(dimensions, ImageDimensions);
            ptr1 = dimensions.__destroy_into_raw();
        }
        const ret = wasm.image_new(ptr0, len0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
}
module.exports.Image = Image;

const ImageDimensionsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_imagedimensions_free(ptr >>> 0));
/**
*/
class ImageDimensions {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ImageDimensions.prototype);
        obj.__wbg_ptr = ptr;
        ImageDimensionsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ImageDimensionsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_imagedimensions_free(ptr);
    }
    /**
    * @returns {bigint}
    */
    get width() {
        const ret = wasm.__wbg_get_getbalanceresponseresult_balance(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {bigint} arg0
    */
    set width(arg0) {
        wasm.__wbg_set_getbalanceresponseresult_balance(this.__wbg_ptr, arg0);
    }
    /**
    * @returns {bigint}
    */
    get height() {
        const ret = wasm.__wbg_get_imagedimensions_height(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * @param {bigint} arg0
    */
    set height(arg0) {
        wasm.__wbg_set_imagedimensions_height(this.__wbg_ptr, arg0);
    }
}
module.exports.ImageDimensions = ImageDimensions;

const InterestsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_interests_free(ptr >>> 0));
/**
* Topics a user may be interested in and pointers
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
class Interests {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        InterestsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_interests_free(ptr);
    }
    /**
    * @returns {(string)[]}
    */
    get hashtags() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_interests_hashtags(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(string)[]} arg0
    */
    set hashtags(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_interests_hashtags(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(Coordinate)[]}
    */
    get coordinate() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_bookmarks_coordinate(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(Coordinate)[]} arg0
    */
    set coordinate(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_bookmarks_coordinate(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.Interests = Interests;

const KeysFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_keys_free(ptr >>> 0));
/**
*/
class Keys {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Keys.prototype);
        obj.__wbg_ptr = ptr;
        KeysFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        KeysFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_keys_free(ptr);
    }
    /**
    * Initialize from secret key.
    * @param {SecretKey} secret_key
    */
    constructor(secret_key) {
        _assertClass(secret_key, SecretKey);
        const ret = wasm.keys_new(secret_key.__wbg_ptr);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Try to parse keys from **secret key** `hex` or `bech32`
    * @param {string} secret_key
    * @returns {Keys}
    */
    static parse(secret_key) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(secret_key, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.keys_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Keys.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Initialize with public key only (no secret key).
    * @param {PublicKey} public_key
    * @returns {Keys}
    */
    static fromPublicKey(public_key) {
        _assertClass(public_key, PublicKey);
        const ret = wasm.keys_fromPublicKey(public_key.__wbg_ptr);
        return Keys.__wrap(ret);
    }
    /**
    * Generate new random keys
    * @returns {Keys}
    */
    static generate() {
        const ret = wasm.keys_generate();
        return Keys.__wrap(ret);
    }
    /**
    * @param {(string)[]} prefixes
    * @param {boolean} bech32
    * @param {number} num_cores
    * @returns {Keys}
    */
    static vanity(prefixes, bech32, num_cores) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArrayJsValueToWasm0(prefixes, wasm.__wbindgen_export_0);
            const len0 = WASM_VECTOR_LEN;
            wasm.keys_vanity(retptr, ptr0, len0, bech32, num_cores);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Keys.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Derive keys from BIP-39 mnemonics (ENGLISH wordlist).
    *
    * <https://github.com/nostr-protocol/nips/blob/master/06.md>
    * @param {string} mnemonic
    * @param {string | undefined} [passphrase]
    * @param {number | undefined} [account]
    * @param {number | undefined} [typ]
    * @param {number | undefined} [index]
    * @returns {Keys}
    */
    static fromMnemonic(mnemonic, passphrase, account, typ, index) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(mnemonic, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            var ptr1 = isLikeNone(passphrase) ? 0 : passStringToWasm0(passphrase, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            var len1 = WASM_VECTOR_LEN;
            wasm.keys_fromMnemonic(retptr, ptr0, len0, ptr1, len1, !isLikeNone(account), isLikeNone(account) ? 0 : account, !isLikeNone(typ), isLikeNone(typ) ? 0 : typ, !isLikeNone(index), isLikeNone(index) ? 0 : index);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Keys.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Get public key
    * @returns {PublicKey}
    */
    get publicKey() {
        const ret = wasm.keys_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * Get secret key
    * @returns {SecretKey}
    */
    get secretKey() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.keys_secretKey(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SecretKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Keys = Keys;

const KeysendTLVRecordFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_keysendtlvrecord_free(ptr >>> 0));
/**
* TLVs to be added to the keysend payment
*/
class KeysendTLVRecord {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(KeysendTLVRecord.prototype);
        obj.__wbg_ptr = ptr;
        KeysendTLVRecordFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof KeysendTLVRecord)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        KeysendTLVRecordFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_keysendtlvrecord_free(ptr);
    }
    /**
    * TLV type
    * @returns {bigint}
    */
    get tlv_type() {
        const ret = wasm.__wbg_get_getbalanceresponseresult_balance(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * TLV type
    * @param {bigint} arg0
    */
    set tlv_type(arg0) {
        wasm.__wbg_set_getbalanceresponseresult_balance(this.__wbg_ptr, arg0);
    }
    /**
    * TLV value
    * @returns {string}
    */
    get value() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_keysendtlvrecord_value(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * TLV value
    * @param {string} arg0
    */
    set value(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_keysendtlvrecord_value(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.KeysendTLVRecord = KeysendTLVRecord;

const ListTransactionsRequestParamsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_listtransactionsrequestparams_free(ptr >>> 0));
/**
* List Invoice Request Params
*/
class ListTransactionsRequestParams {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ListTransactionsRequestParamsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_listtransactionsrequestparams_free(ptr);
    }
    /**
    * Starting timestamp in seconds since epoch
    * @returns {bigint | undefined}
    */
    get from() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_listtransactionsrequestparams_from(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Starting timestamp in seconds since epoch
    * @param {bigint | undefined} [arg0]
    */
    set from(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_from(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
    * Ending timestamp in seconds since epoch
    * @returns {bigint | undefined}
    */
    get until() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_listtransactionsrequestparams_until(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Ending timestamp in seconds since epoch
    * @param {bigint | undefined} [arg0]
    */
    set until(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_until(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
    * Number of invoices to return
    * @returns {bigint | undefined}
    */
    get limit() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_listtransactionsrequestparams_limit(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Number of invoices to return
    * @param {bigint | undefined} [arg0]
    */
    set limit(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_limit(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
    * Offset of the first invoice to return
    * @returns {bigint | undefined}
    */
    get offset() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_listtransactionsrequestparams_offset(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Offset of the first invoice to return
    * @param {bigint | undefined} [arg0]
    */
    set offset(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_offset(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
    * If true, include unpaid invoices
    * @returns {boolean | undefined}
    */
    get unpaid() {
        const ret = wasm.__wbg_get_listtransactionsrequestparams_unpaid(this.__wbg_ptr);
        return ret === 0xFFFFFF ? undefined : ret !== 0;
    }
    /**
    * If true, include unpaid invoices
    * @param {boolean | undefined} [arg0]
    */
    set unpaid(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_unpaid(this.__wbg_ptr, isLikeNone(arg0) ? 0xFFFFFF : arg0 ? 1 : 0);
    }
    /**
    * [`TransactionType::Incoming`] for invoices, [`TransactionType::Outgoing`] for payments, [`None`] for both
    * @returns {TransactionType | undefined}
    */
    get transaction_type() {
        const ret = wasm.__wbg_get_listtransactionsrequestparams_transaction_type(this.__wbg_ptr);
        return ret === 2 ? undefined : ret;
    }
    /**
    * [`TransactionType::Incoming`] for invoices, [`TransactionType::Outgoing`] for payments, [`None`] for both
    * @param {TransactionType | undefined} [arg0]
    */
    set transaction_type(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_transaction_type(this.__wbg_ptr, isLikeNone(arg0) ? 2 : arg0);
    }
}
module.exports.ListTransactionsRequestParams = ListTransactionsRequestParams;

const LiveEventFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_liveevent_free(ptr >>> 0));
/**
*/
class LiveEvent {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LiveEventFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_liveevent_free(ptr);
    }
    /**
    * @returns {string}
    */
    get id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_id(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get title() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_title(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get summary() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_summary(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Image | undefined}
    */
    get image() {
        const ret = wasm.liveevent_image(this.__wbg_ptr);
        return ret === 0 ? undefined : Image.__wrap(ret);
    }
    /**
    * @returns {(string)[]}
    */
    get hashtags() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_hashtags(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get streaming() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_streaming(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get recording() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_recording(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {number | undefined}
    */
    get starts() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_starts(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getFloat64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {number | undefined}
    */
    get ends() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_ends(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getFloat64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {LiveEventStatus | undefined}
    */
    get status() {
        const ret = wasm.liveevent_status(this.__wbg_ptr);
        return ret === 0 ? undefined : LiveEventStatus.__wrap(ret);
    }
    /**
    * @returns {number | undefined}
    */
    get currentPartecipants() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_currentPartecipants(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getFloat64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {number | undefined}
    */
    get totalPartecipants() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_totalPartecipants(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getFloat64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {(string)[]}
    */
    get relays() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_relays(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {LiveEventHost | undefined}
    */
    get host() {
        const ret = wasm.liveevent_host(this.__wbg_ptr);
        return ret === 0 ? undefined : LiveEventHost.__wrap(ret);
    }
    /**
    * @returns {(User)[]}
    */
    get speakers() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_speakers(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {(User)[]}
    */
    get participants() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveevent_participants(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.LiveEvent = LiveEvent;

const LiveEventHostFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_liveeventhost_free(ptr >>> 0));
/**
*/
class LiveEventHost {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LiveEventHost.prototype);
        obj.__wbg_ptr = ptr;
        LiveEventHostFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LiveEventHostFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_liveeventhost_free(ptr);
    }
    /**
    * @returns {PublicKey}
    */
    get publicKey() {
        const ret = wasm.liveeventhost_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {string | undefined}
    */
    get relayUrl() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveeventhost_relayUrl(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get proof() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.liveeventhost_proof(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.LiveEventHost = LiveEventHost;

const LiveEventStatusFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_liveeventstatus_free(ptr >>> 0));
/**
*/
class LiveEventStatus {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(LiveEventStatus.prototype);
        obj.__wbg_ptr = ptr;
        LiveEventStatusFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LiveEventStatusFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_liveeventstatus_free(ptr);
    }
    /**
    * @returns {LiveEventStatus}
    */
    static planned() {
        const ret = wasm.liveeventstatus_planned();
        return LiveEventStatus.__wrap(ret);
    }
    /**
    * @returns {LiveEventStatus}
    */
    static live() {
        const ret = wasm.liveeventstatus_live();
        return LiveEventStatus.__wrap(ret);
    }
    /**
    * @returns {LiveEventStatus}
    */
    static ended() {
        const ret = wasm.liveeventstatus_ended();
        return LiveEventStatus.__wrap(ret);
    }
    /**
    * @param {string} string
    * @returns {LiveEventStatus}
    */
    static custom(string) {
        const ptr0 = passStringToWasm0(string, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.liveeventstatus_custom(ptr0, len0);
        return LiveEventStatus.__wrap(ret);
    }
}
module.exports.LiveEventStatus = LiveEventStatus;

const LookupInvoiceRequestParamsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_lookupinvoicerequestparams_free(ptr >>> 0));
/**
* Lookup Invoice Request Params
*/
class LookupInvoiceRequestParams {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LookupInvoiceRequestParamsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_lookupinvoicerequestparams_free(ptr);
    }
    /**
    * Payment hash of invoice
    * @returns {string | undefined}
    */
    get payment_hash() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoicerequestparams_payment_hash(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Payment hash of invoice
    * @param {string | undefined} [arg0]
    */
    set payment_hash(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoicerequestparams_payment_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Bolt11 invoice
    * @returns {string | undefined}
    */
    get invoice() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoicerequestparams_invoice(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Bolt11 invoice
    * @param {string | undefined} [arg0]
    */
    set invoice(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoicerequestparams_invoice(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.LookupInvoiceRequestParams = LookupInvoiceRequestParams;

const LookupInvoiceResponseResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_lookupinvoiceresponseresult_free(ptr >>> 0));
/**
*/
class LookupInvoiceResponseResult {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        LookupInvoiceResponseResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_lookupinvoiceresponseresult_free(ptr);
    }
    /**
    * Transaction type
    * @returns {TransactionType | undefined}
    */
    get transaction_type() {
        const ret = wasm.__wbg_get_lookupinvoiceresponseresult_transaction_type(this.__wbg_ptr);
        return ret === 2 ? undefined : ret;
    }
    /**
    * Transaction type
    * @param {TransactionType | undefined} [arg0]
    */
    set transaction_type(arg0) {
        wasm.__wbg_set_lookupinvoiceresponseresult_transaction_type(this.__wbg_ptr, isLikeNone(arg0) ? 2 : arg0);
    }
    /**
    * Bolt11 invoice
    * @returns {string | undefined}
    */
    get invoice() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoiceresponseresult_invoice(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Bolt11 invoice
    * @param {string | undefined} [arg0]
    */
    set invoice(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoiceresponseresult_invoice(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Invoice's description
    * @returns {string | undefined}
    */
    get description() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoiceresponseresult_description(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Invoice's description
    * @param {string | undefined} [arg0]
    */
    set description(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoiceresponseresult_description(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Invoice's description hash
    * @returns {string | undefined}
    */
    get description_hash() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoiceresponseresult_description_hash(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Invoice's description hash
    * @param {string | undefined} [arg0]
    */
    set description_hash(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoiceresponseresult_description_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Payment preimage
    * @returns {string | undefined}
    */
    get preimage() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoiceresponseresult_preimage(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Payment preimage
    * @param {string | undefined} [arg0]
    */
    set preimage(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoiceresponseresult_preimage(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Payment hash
    * @returns {string}
    */
    get payment_hash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoiceresponseresult_payment_hash(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Payment hash
    * @param {string} arg0
    */
    set payment_hash(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoiceresponseresult_payment_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Amount in millisatoshis
    * @returns {bigint}
    */
    get amount() {
        const ret = wasm.__wbg_get_lookupinvoiceresponseresult_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * Amount in millisatoshis
    * @param {bigint} arg0
    */
    set amount(arg0) {
        wasm.__wbg_set_lookupinvoiceresponseresult_amount(this.__wbg_ptr, arg0);
    }
    /**
    * Fees paid in millisatoshis
    * @returns {bigint}
    */
    get fees_paid() {
        const ret = wasm.__wbg_get_lookupinvoiceresponseresult_fees_paid(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * Fees paid in millisatoshis
    * @param {bigint} arg0
    */
    set fees_paid(arg0) {
        wasm.__wbg_set_lookupinvoiceresponseresult_fees_paid(this.__wbg_ptr, arg0);
    }
    /**
    * Creation timestamp in seconds since epoch
    * @returns {bigint}
    */
    get created_at() {
        const ret = wasm.__wbg_get_lookupinvoiceresponseresult_created_at(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * Creation timestamp in seconds since epoch
    * @param {bigint} arg0
    */
    set created_at(arg0) {
        wasm.__wbg_set_lookupinvoiceresponseresult_created_at(this.__wbg_ptr, arg0);
    }
    /**
    * Expiration timestamp in seconds since epoch
    * @returns {bigint}
    */
    get expires_at() {
        const ret = wasm.__wbg_get_lookupinvoiceresponseresult_expires_at(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * Expiration timestamp in seconds since epoch
    * @param {bigint} arg0
    */
    set expires_at(arg0) {
        wasm.__wbg_set_lookupinvoiceresponseresult_expires_at(this.__wbg_ptr, arg0);
    }
    /**
    * Settled timestamp in seconds since epoch
    * @returns {bigint | undefined}
    */
    get settled_at() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_listtransactionsrequestparams_from(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Settled timestamp in seconds since epoch
    * @param {bigint | undefined} [arg0]
    */
    set settled_at(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_from(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
    * Optional metadata about the payment
    * @returns {string}
    */
    get metadata() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoiceresponseresult_metadata(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Optional metadata about the payment
    * @param {string} arg0
    */
    set metadata(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoiceresponseresult_metadata(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.LookupInvoiceResponseResult = LookupInvoiceResponseResult;

const MakeInvoiceRequestParamsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_makeinvoicerequestparams_free(ptr >>> 0));
/**
* Make Invoice Request Params
*/
class MakeInvoiceRequestParams {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MakeInvoiceRequestParamsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_makeinvoicerequestparams_free(ptr);
    }
    /**
    * Amount in millisatoshis
    * @returns {bigint}
    */
    get amount() {
        const ret = wasm.__wbg_get_lookupinvoiceresponseresult_amount(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * Amount in millisatoshis
    * @param {bigint} arg0
    */
    set amount(arg0) {
        wasm.__wbg_set_lookupinvoiceresponseresult_amount(this.__wbg_ptr, arg0);
    }
    /**
    * Invoice description
    * @returns {string | undefined}
    */
    get description() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_makeinvoicerequestparams_description(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Invoice description
    * @param {string | undefined} [arg0]
    */
    set description(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_makeinvoicerequestparams_description(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Invoice description hash
    * @returns {string | undefined}
    */
    get description_hash() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_makeinvoicerequestparams_description_hash(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Invoice description hash
    * @param {string | undefined} [arg0]
    */
    set description_hash(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_makeinvoicerequestparams_description_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Invoice expiry in seconds
    * @returns {bigint | undefined}
    */
    get expiry() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_listtransactionsrequestparams_from(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Invoice expiry in seconds
    * @param {bigint | undefined} [arg0]
    */
    set expiry(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_from(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
}
module.exports.MakeInvoiceRequestParams = MakeInvoiceRequestParams;

const MakeInvoiceResponseResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_makeinvoiceresponseresult_free(ptr >>> 0));
/**
*/
class MakeInvoiceResponseResult {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MakeInvoiceResponseResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_makeinvoiceresponseresult_free(ptr);
    }
    /**
    * Bolt 11 invoice
    * @returns {string}
    */
    get invoice() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_key(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Bolt 11 invoice
    * @param {string} arg0
    */
    set invoice(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_key(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Invoice's payment hash
    * @returns {string}
    */
    get payment_hash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_iv(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Invoice's payment hash
    * @param {string} arg0
    */
    set payment_hash(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_iv(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.MakeInvoiceResponseResult = MakeInvoiceResponseResult;

const MetadataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_metadata_free(ptr >>> 0));
/**
*/
class Metadata {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Metadata.prototype);
        obj.__wbg_ptr = ptr;
        MetadataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_metadata_free(ptr);
    }
    /**
    */
    constructor() {
        const ret = wasm.metadata_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @param {string} json
    * @returns {Metadata}
    */
    static fromJson(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.metadata_fromJson(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Metadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    asJson() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.metadata_asJson(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} name
    * @returns {Metadata}
    */
    name(name) {
        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.metadata_name(this.__wbg_ptr, ptr0, len0);
        return Metadata.__wrap(ret);
    }
    /**
    * @param {string} display_name
    * @returns {Metadata}
    */
    displayName(display_name) {
        const ptr0 = passStringToWasm0(display_name, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.metadata_displayName(this.__wbg_ptr, ptr0, len0);
        return Metadata.__wrap(ret);
    }
    /**
    * @param {string} about
    * @returns {Metadata}
    */
    about(about) {
        const ptr0 = passStringToWasm0(about, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.metadata_about(this.__wbg_ptr, ptr0, len0);
        return Metadata.__wrap(ret);
    }
    /**
    * @param {string} url
    * @returns {Metadata}
    */
    website(url) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.metadata_website(retptr, this.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Metadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} url
    * @returns {Metadata}
    */
    picture(url) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.metadata_picture(retptr, this.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Metadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} url
    * @returns {Metadata}
    */
    banner(url) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.metadata_banner(retptr, this.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Metadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} nip05
    * @returns {Metadata}
    */
    nip05(nip05) {
        const ptr0 = passStringToWasm0(nip05, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.metadata_nip05(this.__wbg_ptr, ptr0, len0);
        return Metadata.__wrap(ret);
    }
    /**
    * @param {string} lud06
    * @returns {Metadata}
    */
    lud06(lud06) {
        const ptr0 = passStringToWasm0(lud06, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.metadata_lud06(this.__wbg_ptr, ptr0, len0);
        return Metadata.__wrap(ret);
    }
    /**
    * @param {string} lud16
    * @returns {Metadata}
    */
    lud16(lud16) {
        const ptr0 = passStringToWasm0(lud16, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.metadata_lud16(this.__wbg_ptr, ptr0, len0);
        return Metadata.__wrap(ret);
    }
}
module.exports.Metadata = Metadata;

const MultiPayInvoiceRequestParamsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_multipayinvoicerequestparams_free(ptr >>> 0));
/**
* Multi Pay Invoice Request Params
*/
class MultiPayInvoiceRequestParams {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MultiPayInvoiceRequestParamsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_multipayinvoicerequestparams_free(ptr);
    }
    /**
    * Invoices to pay
    * @returns {(PayInvoiceRequestParams)[]}
    */
    get invoices() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_multipayinvoicerequestparams_invoices(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Invoices to pay
    * @param {(PayInvoiceRequestParams)[]} arg0
    */
    set invoices(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_multipayinvoicerequestparams_invoices(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.MultiPayInvoiceRequestParams = MultiPayInvoiceRequestParams;

const MultiPayKeysendRequestParamsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_multipaykeysendrequestparams_free(ptr >>> 0));
/**
* Multi Pay Keysend Request Params
*/
class MultiPayKeysendRequestParams {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MultiPayKeysendRequestParamsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_multipaykeysendrequestparams_free(ptr);
    }
    /**
    * Keysends
    * @returns {(PayKeysendRequestParams)[]}
    */
    get keysends() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_multipaykeysendrequestparams_keysends(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Keysends
    * @param {(PayKeysendRequestParams)[]} arg0
    */
    set keysends(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_multipaykeysendrequestparams_keysends(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.MultiPayKeysendRequestParams = MultiPayKeysendRequestParams;

const MuteListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_mutelist_free(ptr >>> 0));
/**
* Things the user doesn't want to see in their feeds
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
class MuteList {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        MuteListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_mutelist_free(ptr);
    }
    /**
    * @returns {(PublicKey)[]}
    */
    get public_keys() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_mutelist_public_keys(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(PublicKey)[]} arg0
    */
    set public_keys(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_mutelist_public_keys(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(string)[]}
    */
    get hashtags() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_mutelist_hashtags(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(string)[]} arg0
    */
    set hashtags(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_mutelist_hashtags(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(EventId)[]}
    */
    get event_ids() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_mutelist_event_ids(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(EventId)[]} arg0
    */
    set event_ids(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_mutelist_event_ids(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {(string)[]}
    */
    get words() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_bookmarks_urls(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {(string)[]} arg0
    */
    set words(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_bookmarks_urls(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.MuteList = MuteList;

const Nip07SignerFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nip07signer_free(ptr >>> 0));
/**
* NIP07 Signer for interaction with browser extensions (ex. Alby)
*
* <https://github.com/aljazceru/awesome-nostr#nip-07-browser-extensions>
*/
class Nip07Signer {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Nip07SignerFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nip07signer_free(ptr);
    }
    /**
    */
    constructor() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nip07signer_new(retptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            this.__wbg_ptr = r0 >>> 0;
            return this;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Promise<PublicKey>}
    */
    getPublicKey() {
        const ret = wasm.nip07signer_getPublicKey(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @param {UnsignedEvent} unsigned
    * @returns {Promise<Event>}
    */
    signEvent(unsigned) {
        _assertClass(unsigned, UnsignedEvent);
        var ptr0 = unsigned.__destroy_into_raw();
        const ret = wasm.nip07signer_signEvent(this.__wbg_ptr, ptr0);
        return takeObject(ret);
    }
    /**
    * @param {PublicKey} public_key
    * @param {string} plaintext
    * @returns {Promise<string>}
    */
    nip04Encrypt(public_key, plaintext) {
        _assertClass(public_key, PublicKey);
        const ptr0 = passStringToWasm0(plaintext, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nip07signer_nip04Encrypt(this.__wbg_ptr, public_key.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * @param {PublicKey} public_key
    * @param {string} ciphertext
    * @returns {Promise<string>}
    */
    nip04Decrypt(public_key, ciphertext) {
        _assertClass(public_key, PublicKey);
        const ptr0 = passStringToWasm0(ciphertext, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nip07signer_nip04Decrypt(this.__wbg_ptr, public_key.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * @param {PublicKey} public_key
    * @param {string} plaintext
    * @returns {Promise<string>}
    */
    nip44Encrypt(public_key, plaintext) {
        _assertClass(public_key, PublicKey);
        const ptr0 = passStringToWasm0(plaintext, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nip07signer_nip44Encrypt(this.__wbg_ptr, public_key.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * @param {PublicKey} public_key
    * @param {string} ciphertext
    * @returns {Promise<string>}
    */
    nip44Decrypt(public_key, ciphertext) {
        _assertClass(public_key, PublicKey);
        const ptr0 = passStringToWasm0(ciphertext, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nip07signer_nip44Decrypt(this.__wbg_ptr, public_key.__wbg_ptr, ptr0, len0);
        return takeObject(ret);
    }
}
module.exports.Nip07Signer = Nip07Signer;

const Nip19EventFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nip19event_free(ptr >>> 0));
/**
*/
class Nip19Event {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Nip19Event.prototype);
        obj.__wbg_ptr = ptr;
        Nip19EventFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Nip19EventFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nip19event_free(ptr);
    }
    /**
    * @param {EventId} event_id
    * @param {PublicKey | undefined} author
    * @param {(string)[]} relays
    */
    constructor(event_id, author, relays) {
        _assertClass(event_id, EventId);
        let ptr0 = 0;
        if (!isLikeNone(author)) {
            _assertClass(author, PublicKey);
            ptr0 = author.__destroy_into_raw();
        }
        const ptr1 = passArrayJsValueToWasm0(relays, wasm.__wbindgen_export_0);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.nip19event_new(event_id.__wbg_ptr, ptr0, ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @param {string} bech32
    * @returns {Nip19Event}
    */
    static fromBech32(bech32) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.nip19event_fromBech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Nip19Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} uri
    * @returns {Nip19Event}
    */
    static fromNostrUri(uri) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.nip19event_fromNostrUri(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Nip19Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    toBech32() {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nip19event_toBech32(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred2_0, deferred2_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    toNostrUri() {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nip19event_toNostrUri(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred2_0, deferred2_1, 1);
        }
    }
    /**
    * @returns {EventId}
    */
    eventId() {
        const ret = wasm.nip19event_eventId(this.__wbg_ptr);
        return EventId.__wrap(ret);
    }
    /**
    * @returns {PublicKey | undefined}
    */
    author() {
        const ret = wasm.nip19event_author(this.__wbg_ptr);
        return ret === 0 ? undefined : PublicKey.__wrap(ret);
    }
    /**
    * @returns {(string)[]}
    */
    relays() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nip19event_relays(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Nip19Event = Nip19Event;

const Nip19ProfileFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nip19profile_free(ptr >>> 0));
/**
*/
class Nip19Profile {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Nip19Profile.prototype);
        obj.__wbg_ptr = ptr;
        Nip19ProfileFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        Nip19ProfileFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nip19profile_free(ptr);
    }
    /**
    * New NIP19 profile
    * @param {PublicKey} public_key
    * @param {(string)[]} relays
    */
    constructor(public_key, relays) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(public_key, PublicKey);
            const ptr0 = passArrayJsValueToWasm0(relays, wasm.__wbindgen_export_0);
            const len0 = WASM_VECTOR_LEN;
            wasm.nip19profile_new(retptr, public_key.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            this.__wbg_ptr = r0 >>> 0;
            return this;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} bech32
    * @returns {Nip19Profile}
    */
    static fromBech32(bech32) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.nip19profile_fromBech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Nip19Profile.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} uri
    * @returns {Nip19Profile}
    */
    static fromNostrUri(uri) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.nip19profile_fromNostrUri(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Nip19Profile.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    toBech32() {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nip19profile_toBech32(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred2_0, deferred2_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    toNostrUri() {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nip19profile_toNostrUri(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred2_0, deferred2_1, 1);
        }
    }
    /**
    * @returns {PublicKey}
    */
    publicKey() {
        const ret = wasm.liveeventhost_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {(string)[]}
    */
    relays() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nip19profile_relays(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Nip19Profile = Nip19Profile;

const NostrConnectMetadataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nostrconnectmetadata_free(ptr >>> 0));
/**
*/
class NostrConnectMetadata {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NostrConnectMetadata.prototype);
        obj.__wbg_ptr = ptr;
        NostrConnectMetadataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NostrConnectMetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nostrconnectmetadata_free(ptr);
    }
    /**
    * New Nostr Connect Metadata
    * @param {string} name
    */
    constructor(name) {
        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nostrconnectmetadata_new(ptr0, len0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * URL of the website requesting the connection
    * @param {string} url
    * @returns {NostrConnectMetadata}
    */
    url(url) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.nostrconnectmetadata_url(retptr, ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NostrConnectMetadata.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Description of the `App`
    * @param {string} description
    * @returns {NostrConnectMetadata}
    */
    description(description) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passStringToWasm0(description, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nostrconnectmetadata_description(ptr, ptr0, len0);
        return NostrConnectMetadata.__wrap(ret);
    }
    /**
    * List of URLs for icons of the `App`
    * @param {(string)[]} icons
    * @returns {NostrConnectMetadata}
    */
    icons(icons) {
        const ptr = this.__destroy_into_raw();
        const ptr0 = passArrayJsValueToWasm0(icons, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.nostrconnectmetadata_icons(ptr, ptr0, len0);
        return NostrConnectMetadata.__wrap(ret);
    }
    /**
    * Serialize as JSON string
    * @returns {string}
    */
    as_json() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nostrconnectmetadata_as_json(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.NostrConnectMetadata = NostrConnectMetadata;

const NostrConnectURIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nostrconnecturi_free(ptr >>> 0));
/**
*/
class NostrConnectURI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NostrConnectURI.prototype);
        obj.__wbg_ptr = ptr;
        NostrConnectURIFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NostrConnectURIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nostrconnecturi_free(ptr);
    }
    /**
    * @param {string} uri
    * @returns {NostrConnectURI}
    */
    static parse(uri) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.nostrconnecturi_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NostrConnectURI.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    asString() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nostrconnecturi_asString(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.NostrConnectURI = NostrConnectURI;

const NostrLibraryFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nostrlibrary_free(ptr >>> 0));
/**
*/
class NostrLibrary {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NostrLibraryFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nostrlibrary_free(ptr);
    }
    /**
    */
    constructor() {
        const ret = wasm.nostrlibrary_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @returns {string | undefined}
    */
    gitHashVersion() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nostrlibrary_gitHashVersion(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.NostrLibrary = NostrLibrary;

const NostrWalletConnectURIFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_nostrwalletconnecturi_free(ptr >>> 0));
/**
*/
class NostrWalletConnectURI {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NostrWalletConnectURI.prototype);
        obj.__wbg_ptr = ptr;
        NostrWalletConnectURIFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NostrWalletConnectURIFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_nostrwalletconnecturi_free(ptr);
    }
    /**
    * Create new Nostr Wallet Connect URI
    * @param {PublicKey} public_key
    * @param {string} relay_url
    * @param {SecretKey} random_secret_key
    * @param {string | undefined} [lud16]
    */
    constructor(public_key, relay_url, random_secret_key, lud16) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(public_key, PublicKey);
            const ptr0 = passStringToWasm0(relay_url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            _assertClass(random_secret_key, SecretKey);
            var ptr1 = isLikeNone(lud16) ? 0 : passStringToWasm0(lud16, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            var len1 = WASM_VECTOR_LEN;
            wasm.nostrwalletconnecturi_new(retptr, public_key.__wbg_ptr, ptr0, len0, random_secret_key.__wbg_ptr, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            this.__wbg_ptr = r0 >>> 0;
            return this;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Parse
    * @param {string} uri
    * @returns {NostrWalletConnectURI}
    */
    static parse(uri) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(uri, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.nostrwalletconnecturi_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return NostrWalletConnectURI.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * App Pubkey
    * @returns {PublicKey}
    */
    publicKey() {
        const ret = wasm.nostrwalletconnecturi_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * URL of the relay of choice where the `App` is connected and the `Signer` must send and listen for messages.
    * @returns {string}
    */
    relayUrl() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nostrwalletconnecturi_relayUrl(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * 32-byte randomly generated hex encoded string
    * @returns {SecretKey}
    */
    secret() {
        const ret = wasm.nostrwalletconnecturi_secret(this.__wbg_ptr);
        return SecretKey.__wrap(ret);
    }
    /**
    * A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured.
    * @returns {string | undefined}
    */
    lud16() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nostrwalletconnecturi_lud16(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    asString() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.nostrwalletconnecturi_asString(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.NostrWalletConnectURI = NostrWalletConnectURI;

const PayInvoiceRequestParamsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_payinvoicerequestparams_free(ptr >>> 0));
/**
* Pay Invoice Request Params
*/
class PayInvoiceRequestParams {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PayInvoiceRequestParams.prototype);
        obj.__wbg_ptr = ptr;
        PayInvoiceRequestParamsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof PayInvoiceRequestParams)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PayInvoiceRequestParamsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_payinvoicerequestparams_free(ptr);
    }
    /**
    * Optional id
    * @returns {string | undefined}
    */
    get id() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_payinvoicerequestparams_id(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Optional id
    * @param {string | undefined} [arg0]
    */
    set id(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_payinvoicerequestparams_id(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Request invoice
    * @returns {string}
    */
    get invoice() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_payinvoicerequestparams_invoice(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Request invoice
    * @param {string} arg0
    */
    set invoice(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_payinvoicerequestparams_invoice(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Optional amount in millisatoshis
    * @returns {bigint | undefined}
    */
    get amount() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_listtransactionsrequestparams_from(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getBigInt64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : BigInt.asUintN(64, r2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Optional amount in millisatoshis
    * @param {bigint | undefined} [arg0]
    */
    set amount(arg0) {
        wasm.__wbg_set_listtransactionsrequestparams_from(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
}
module.exports.PayInvoiceRequestParams = PayInvoiceRequestParams;

const PayInvoiceResponseResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_payinvoiceresponseresult_free(ptr >>> 0));
/**
*/
class PayInvoiceResponseResult {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PayInvoiceResponseResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_payinvoiceresponseresult_free(ptr);
    }
    /**
    * Response preimage
    * @returns {string}
    */
    get preimage() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_key(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Response preimage
    * @param {string} arg0
    */
    set preimage(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_key(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.PayInvoiceResponseResult = PayInvoiceResponseResult;

const PayKeysendRequestParamsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_paykeysendrequestparams_free(ptr >>> 0));
/**
* Pay Invoice Request Params
*/
class PayKeysendRequestParams {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PayKeysendRequestParams.prototype);
        obj.__wbg_ptr = ptr;
        PayKeysendRequestParamsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof PayKeysendRequestParams)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PayKeysendRequestParamsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_paykeysendrequestparams_free(ptr);
    }
    /**
    * Optional id
    * @returns {string | undefined}
    */
    get id() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_paykeysendrequestparams_id(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Optional id
    * @param {string | undefined} [arg0]
    */
    set id(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_paykeysendrequestparams_id(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Amount in millisatoshis
    * @returns {bigint}
    */
    get amount() {
        const ret = wasm.__wbg_get_getbalanceresponseresult_balance(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * Amount in millisatoshis
    * @param {bigint} arg0
    */
    set amount(arg0) {
        wasm.__wbg_set_getbalanceresponseresult_balance(this.__wbg_ptr, arg0);
    }
    /**
    * Receiver's node id
    * @returns {string}
    */
    get pubkey() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_keysendtlvrecord_value(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Receiver's node id
    * @param {string} arg0
    */
    set pubkey(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_keysendtlvrecord_value(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Optional preimage
    * @returns {string | undefined}
    */
    get preimage() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_paykeysendrequestparams_preimage(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Optional preimage
    * @param {string | undefined} [arg0]
    */
    set preimage(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_paykeysendrequestparams_preimage(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * Optional TLVs to be added to the keysend payment
    * @returns {(KeysendTLVRecord)[]}
    */
    get tlv_records() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_paykeysendrequestparams_tlv_records(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Optional TLVs to be added to the keysend payment
    * @param {(KeysendTLVRecord)[]} arg0
    */
    set tlv_records(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_paykeysendrequestparams_tlv_records(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.PayKeysendRequestParams = PayKeysendRequestParams;

const PayKeysendResponseResultFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_paykeysendresponseresult_free(ptr >>> 0));
/**
*/
class PayKeysendResponseResult {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PayKeysendResponseResultFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_paykeysendresponseresult_free(ptr);
    }
    /**
    * Response preimage
    * @returns {string}
    */
    get preimage() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_key(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Response preimage
    * @param {string} arg0
    */
    set preimage(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_key(this.__wbg_ptr, ptr0, len0);
    }
}
module.exports.PayKeysendResponseResult = PayKeysendResponseResult;

const ProductDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_productdata_free(ptr >>> 0));
/**
*/
class ProductData {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProductDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_productdata_free(ptr);
    }
    /**
    * @param {string} id
    * @param {string} stall_id
    * @param {string} name
    * @param {string} currency
    */
    constructor(id, stall_id, name, currency) {
        const ptr0 = passStringToWasm0(id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(stall_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passStringToWasm0(name, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len2 = WASM_VECTOR_LEN;
        const ptr3 = passStringToWasm0(currency, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len3 = WASM_VECTOR_LEN;
        const ret = wasm.productdata_new(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @returns {string}
    */
    get id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_id(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    get stallId() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_stallId(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    get name() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_name(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get description() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_description(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {(string)[] | undefined}
    */
    get images() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_images(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getArrayJsValueFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    get currency() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_currency(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {number}
    */
    get price() {
        const ret = wasm.productdata_price(this.__wbg_ptr);
        return ret;
    }
    /**
    * @returns {number}
    */
    get quantity() {
        const ret = wasm.productdata_quantity(this.__wbg_ptr);
        return ret;
    }
    /**
    * @returns {(string[])[] | undefined}
    */
    get specs() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_specs(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getArrayJsValueFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {(ShippingCost)[]}
    */
    get shipping() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_shipping(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {(string)[] | undefined}
    */
    get categories() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_categories(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getArrayJsValueFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.ProductData = ProductData;

const PublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_publickey_free(ptr >>> 0));
/**
*/
class PublicKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PublicKey.prototype);
        obj.__wbg_ptr = ptr;
        PublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof PublicKey)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_publickey_free(ptr);
    }
    /**
    * Try to parse public key from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
    * @param {string} public_key
    * @returns {PublicKey}
    */
    static parse(public_key) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(public_key, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.publickey_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PublicKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} hex
    * @returns {PublicKey}
    */
    static fromHex(hex) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.publickey_fromHex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PublicKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} bech32
    * @returns {PublicKey}
    */
    static fromBech32(bech32) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.publickey_fromBech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return PublicKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Get in hex format
    * @returns {string}
    */
    toHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.publickey_toHex(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Get in bech32 format
    * @returns {string}
    */
    toBech32() {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.publickey_toBech32(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred2_0, deferred2_1, 1);
        }
    }
}
module.exports.PublicKey = PublicKey;

const RelayInformationDocumentFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_relayinformationdocument_free(ptr >>> 0));
/**
*/
class RelayInformationDocument {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RelayInformationDocument.prototype);
        obj.__wbg_ptr = ptr;
        RelayInformationDocumentFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RelayInformationDocumentFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_relayinformationdocument_free(ptr);
    }
    /**
    */
    constructor() {
        const ret = wasm.relayinformationdocument_new();
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @param {string} url
    * @returns {Promise<RelayInformationDocument>}
    */
    static get(url) {
        const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relayinformationdocument_get(ptr0, len0);
        return takeObject(ret);
    }
    /**
    * @returns {string | undefined}
    */
    get name() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relayinformationdocument_name(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get description() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relayinformationdocument_description(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get pubkey() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relayinformationdocument_pubkey(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get contact() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relayinformationdocument_contact(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint16Array | undefined}
    */
    get supported_nips() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relayinformationdocument_supported_nips(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getArrayU16FromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 2, 2);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get software() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relayinformationdocument_software(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get version() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relayinformationdocument_version(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.RelayInformationDocument = RelayInformationDocument;

const RelayListItemFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_relaylistitem_free(ptr >>> 0));
/**
*/
class RelayListItem {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RelayListItem.prototype);
        obj.__wbg_ptr = ptr;
        RelayListItemFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof RelayListItem)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RelayListItemFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_relaylistitem_free(ptr);
    }
    /**
    * @returns {string}
    */
    get url() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_aes256gcm_key(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} arg0
    */
    set url(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_aes256gcm_key(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {RelayMetadata | undefined}
    */
    get metadata() {
        const ret = wasm.__wbg_get_relaylistitem_metadata(this.__wbg_ptr);
        return ret === 2 ? undefined : ret;
    }
    /**
    * @param {RelayMetadata | undefined} [arg0]
    */
    set metadata(arg0) {
        wasm.__wbg_set_relaylistitem_metadata(this.__wbg_ptr, isLikeNone(arg0) ? 2 : arg0);
    }
    /**
    * @param {string} url
    * @param {RelayMetadata | undefined} [metadata]
    */
    constructor(url, metadata) {
        const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relaylistitem_new(ptr0, len0, isLikeNone(metadata) ? 2 : metadata);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
}
module.exports.RelayListItem = RelayListItem;

const RelayMessageFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_relaymessage_free(ptr >>> 0));
/**
*/
class RelayMessage {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(RelayMessage.prototype);
        obj.__wbg_ptr = ptr;
        RelayMessageFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RelayMessageFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_relaymessage_free(ptr);
    }
    /**
    * Create new `EVENT` message
    * @param {string} subscription_id
    * @param {Event} event
    * @returns {RelayMessage}
    */
    static event(subscription_id, event) {
        const ptr0 = passStringToWasm0(subscription_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(event, Event);
        const ret = wasm.relaymessage_event(ptr0, len0, event.__wbg_ptr);
        return RelayMessage.__wrap(ret);
    }
    /**
    * Create new `NOTICE` message
    * @param {string} message
    * @returns {RelayMessage}
    */
    static notice(message) {
        const ptr0 = passStringToWasm0(message, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relaymessage_notice(ptr0, len0);
        return RelayMessage.__wrap(ret);
    }
    /**
    * Create new `CLOSED` message
    * @param {string} subscription_id
    * @param {string} message
    * @returns {RelayMessage}
    */
    static closed(subscription_id, message) {
        const ptr0 = passStringToWasm0(subscription_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(message, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.relaymessage_closed(ptr0, len0, ptr1, len1);
        return RelayMessage.__wrap(ret);
    }
    /**
    * Create new `EOSE` message
    * @param {string} subscription_id
    * @returns {RelayMessage}
    */
    static eose(subscription_id) {
        const ptr0 = passStringToWasm0(subscription_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relaymessage_eose(ptr0, len0);
        return RelayMessage.__wrap(ret);
    }
    /**
    * Create new `OK` message
    * @param {EventId} event_id
    * @param {boolean} status
    * @param {string} message
    * @returns {RelayMessage}
    */
    static ok(event_id, status, message) {
        _assertClass(event_id, EventId);
        const ptr0 = passStringToWasm0(message, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relaymessage_ok(event_id.__wbg_ptr, status, ptr0, len0);
        return RelayMessage.__wrap(ret);
    }
    /**
    * Create new `AUTH` message
    * @param {string} challenge
    * @returns {RelayMessage}
    */
    static auth(challenge) {
        const ptr0 = passStringToWasm0(challenge, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relaymessage_auth(ptr0, len0);
        return RelayMessage.__wrap(ret);
    }
    /**
    * Create new `EVENT` message
    * @param {string} subscription_id
    * @param {number} count
    * @returns {RelayMessage}
    */
    static count(subscription_id, count) {
        const ptr0 = passStringToWasm0(subscription_id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.relaymessage_count(ptr0, len0, count);
        return RelayMessage.__wrap(ret);
    }
    /**
    * Deserialize `RelayMessage` from JSON string
    *
    * **This method NOT verify the event signature!**
    * @param {string} json
    * @returns {RelayMessage}
    */
    static fromJson(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.relaymessage_fromJson(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return RelayMessage.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    asJson() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.relaymessage_asJson(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.RelayMessage = RelayMessage;

const SecretKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_secretkey_free(ptr >>> 0));
/**
*/
class SecretKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SecretKey.prototype);
        obj.__wbg_ptr = ptr;
        SecretKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SecretKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_secretkey_free(ptr);
    }
    /**
    * Try to parse secret key from `hex` or `bech32`
    * @param {string} secret_key
    * @returns {SecretKey}
    */
    static parse(secret_key) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(secret_key, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.secretkey_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SecretKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} hex
    * @returns {SecretKey}
    */
    static fromHex(hex) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.secretkey_fromHex(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SecretKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string} bech32
    * @returns {SecretKey}
    */
    static fromBech32(bech32) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(bech32, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.secretkey_fromBech32(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return SecretKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    toHex() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.secretkey_toHex(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    toBech32() {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.secretkey_toBech32(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred2_0, deferred2_1, 1);
        }
    }
    /**
    * Encrypt secret key
    *
    * By default `LOG_N` is set to `16` and `KeySecurity` to `Unknown`.
    * To use custom values check `EncryptedSecretKey` constructor.
    * @param {string} password
    * @returns {EncryptedSecretKey}
    */
    encrypt(password) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(password, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.secretkey_encrypt(retptr, this.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EncryptedSecretKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.SecretKey = SecretKey;

const ShippingCostFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_shippingcost_free(ptr >>> 0));
/**
*/
class ShippingCost {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ShippingCost.prototype);
        obj.__wbg_ptr = ptr;
        ShippingCostFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ShippingCostFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_shippingcost_free(ptr);
    }
    /**
    * @returns {string}
    */
    get id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.shippingcost_id(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {number}
    */
    get cost() {
        const ret = wasm.productdata_price(this.__wbg_ptr);
        return ret;
    }
}
module.exports.ShippingCost = ShippingCost;

const ShippingMethodFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_shippingmethod_free(ptr >>> 0));
/**
*/
class ShippingMethod {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ShippingMethod.prototype);
        obj.__wbg_ptr = ptr;
        ShippingMethodFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ShippingMethodFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_shippingmethod_free(ptr);
    }
    /**
    * @param {string} id
    * @param {number} cost
    */
    constructor(id, cost) {
        const ptr0 = passStringToWasm0(id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.shippingmethod_new(ptr0, len0, cost);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @returns {ShippingCost}
    */
    getShippingCost() {
        const ret = wasm.shippingmethod_getShippingCost(this.__wbg_ptr);
        return ShippingCost.__wrap(ret);
    }
    /**
    * @returns {string}
    */
    get id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.shippingcost_id(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get name() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.shippingmethod_name(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {number}
    */
    get cost() {
        const ret = wasm.productdata_price(this.__wbg_ptr);
        return ret;
    }
    /**
    * @returns {(string)[]}
    */
    get regions() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.shippingmethod_regions(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.ShippingMethod = ShippingMethod;

const SingleLetterTagFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_singlelettertag_free(ptr >>> 0));
/**
*/
class SingleLetterTag {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SingleLetterTag.prototype);
        obj.__wbg_ptr = ptr;
        SingleLetterTagFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SingleLetterTagFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_singlelettertag_free(ptr);
    }
    /**
    * @param {Alphabet} character
    * @returns {SingleLetterTag}
    */
    static lowercase(character) {
        const ret = wasm.singlelettertag_lowercase(character);
        return SingleLetterTag.__wrap(ret);
    }
    /**
    * @param {Alphabet} character
    * @returns {SingleLetterTag}
    */
    static uppercase(character) {
        const ret = wasm.singlelettertag_uppercase(character);
        return SingleLetterTag.__wrap(ret);
    }
    /**
    * @returns {boolean}
    */
    isLowercase() {
        const ret = wasm.singlelettertag_isLowercase(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * @returns {boolean}
    */
    isUppercase() {
        const ret = wasm.singlelettertag_isUppercase(this.__wbg_ptr);
        return ret !== 0;
    }
}
module.exports.SingleLetterTag = SingleLetterTag;

const StallDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_stalldata_free(ptr >>> 0));
/**
*/
class StallData {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        StallDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_stalldata_free(ptr);
    }
    /**
    * @param {string} id
    * @param {string} name
    * @param {string} currency
    */
    constructor(id, name, currency) {
        const ptr0 = passStringToWasm0(id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(name, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passStringToWasm0(currency, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len2 = WASM_VECTOR_LEN;
        const ret = wasm.stalldata_new(ptr0, len0, ptr1, len1, ptr2, len2);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @returns {string}
    */
    get id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stalldata_id(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string}
    */
    get name() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stalldata_name(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get description() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stalldata_description(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    get currency() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stalldata_currency(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {(ShippingMethod)[]}
    */
    get shipping() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.stalldata_shipping(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.StallData = StallData;

const SubscriptionIdFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_subscriptionid_free(ptr >>> 0));
/**
*/
class SubscriptionId {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SubscriptionId.prototype);
        obj.__wbg_ptr = ptr;
        SubscriptionIdFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SubscriptionIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_subscriptionid_free(ptr);
    }
    /**
    * @param {string} id
    */
    constructor(id) {
        const ptr0 = passStringToWasm0(id, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.subscriptionid_new(ptr0, len0);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * Generate new random [`SubscriptionId`]
    * @returns {SubscriptionId}
    */
    static generate() {
        const ret = wasm.subscriptionid_generate();
        return SubscriptionId.__wrap(ret);
    }
    /**
    * @returns {string}
    */
    get() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.subscriptionid_get(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.SubscriptionId = SubscriptionId;

const TagFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_tag_free(ptr >>> 0));
/**
*/
class Tag {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Tag.prototype);
        obj.__wbg_ptr = ptr;
        TagFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof Tag)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TagFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tag_free(ptr);
    }
    /**
    * @param {(string)[]} tag
    * @returns {Tag}
    */
    static parse(tag) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArrayJsValueToWasm0(tag, wasm.__wbindgen_export_0);
            const len0 = WASM_VECTOR_LEN;
            wasm.tag_parse(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Tag.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Compose `["e", "<event-id>"]` tag
    * @param {EventId} event_id
    * @returns {Tag}
    */
    static event(event_id) {
        _assertClass(event_id, EventId);
        const ret = wasm.tag_event(event_id.__wbg_ptr);
        return Tag.__wrap(ret);
    }
    /**
    * Compose `["p", "<public-key>"]` tag
    * @param {PublicKey} public_key
    * @returns {Tag}
    */
    static public_key(public_key) {
        _assertClass(public_key, PublicKey);
        const ret = wasm.tag_public_key(public_key.__wbg_ptr);
        return Tag.__wrap(ret);
    }
    /**
    * Check if `Tag` is an event `reply`
    * @returns {boolean}
    */
    is_reply() {
        const ret = wasm.tag_is_reply(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
    * @returns {string}
    */
    kind() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.tag_kind(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Get tag as vector of string
    *
    * Internally clone tag and convert it to `Vec<String>`. To avoid tag clone, use `toVec()`.
    * @returns {(string)[]}
    */
    asVec() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.tag_asVec(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Consume the tag and return vector of string
    * @returns {(string)[]}
    */
    toVec() {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.tag_toVec(retptr, ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Tag = Tag;

const ThumbnailsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_thumbnails_free(ptr >>> 0));
/**
*/
class Thumbnails {

    static __unwrap(jsValue) {
        if (!(jsValue instanceof Thumbnails)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ThumbnailsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_thumbnails_free(ptr);
    }
    /**
    * @returns {string}
    */
    get url() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_image_url(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} arg0
    */
    set url(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_image_url(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @returns {ImageDimensions | undefined}
    */
    get dimensions() {
        const ret = wasm.__wbg_get_image_dimensions(this.__wbg_ptr);
        return ret === 0 ? undefined : ImageDimensions.__wrap(ret);
    }
    /**
    * @param {ImageDimensions | undefined} [arg0]
    */
    set dimensions(arg0) {
        let ptr0 = 0;
        if (!isLikeNone(arg0)) {
            _assertClass(arg0, ImageDimensions);
            ptr0 = arg0.__destroy_into_raw();
        }
        wasm.__wbg_set_image_dimensions(this.__wbg_ptr, ptr0);
    }
    /**
    * @param {string} url
    * @param {ImageDimensions | undefined} [dimensions]
    */
    constructor(url, dimensions) {
        const ptr0 = passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        let ptr1 = 0;
        if (!isLikeNone(dimensions)) {
            _assertClass(dimensions, ImageDimensions);
            ptr1 = dimensions.__destroy_into_raw();
        }
        const ret = wasm.image_new(ptr0, len0, ptr1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
}
module.exports.Thumbnails = Thumbnails;

const TimestampFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_timestamp_free(ptr >>> 0));
/**
*/
class Timestamp {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Timestamp.prototype);
        obj.__wbg_ptr = ptr;
        TimestampFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TimestampFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_timestamp_free(ptr);
    }
    /**
    * Get UNIX timestamp (seconds)
    * @returns {Timestamp}
    */
    static now() {
        const ret = wasm.timestamp_now();
        return Timestamp.__wrap(ret);
    }
    /**
    * @param {number} secs
    * @returns {Timestamp}
    */
    static fromSecs(secs) {
        const ret = wasm.timestamp_fromSecs(secs);
        return Timestamp.__wrap(ret);
    }
    /**
    * Get timestamp as seconds
    * @returns {number}
    */
    asSecs() {
        const ret = wasm.timestamp_asSecs(this.__wbg_ptr);
        return ret;
    }
    /**
    * Convert `Timestamp` to human datetime
    * @returns {string}
    */
    toHumanDatetime() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.timestamp_toHumanDatetime(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
}
module.exports.Timestamp = Timestamp;

const UnsignedEventFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_unsignedevent_free(ptr >>> 0));
/**
*/
class UnsignedEvent {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(UnsignedEvent.prototype);
        obj.__wbg_ptr = ptr;
        UnsignedEventFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UnsignedEventFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_unsignedevent_free(ptr);
    }
    /**
    * @returns {EventId | undefined}
    */
    get id() {
        const ret = wasm.unsignedevent_id(this.__wbg_ptr);
        return ret === 0 ? undefined : EventId.__wrap(ret);
    }
    /**
    * @returns {PublicKey}
    */
    get pubkey() {
        const ret = wasm.coordinate_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {Timestamp}
    */
    get createdAt() {
        const ret = wasm.unsignedevent_createdAt(this.__wbg_ptr);
        return Timestamp.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    get kind() {
        const ret = wasm.coordinate_kind(this.__wbg_ptr);
        return ret;
    }
    /**
    * @returns {(Tag)[]}
    */
    get tags() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.unsignedevent_tags(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    get content() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.productdata_currency(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @param {string} json
    * @returns {UnsignedEvent}
    */
    static fromJson(json) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(json, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.unsignedevent_fromJson(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UnsignedEvent.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    asJson() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.unsignedevent_asJson(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * Sign an unsigned event
    *
    * Internally: calculate event ID (if not set), sign it, compose and verify event.
    * @param {Keys} keys
    * @returns {Event}
    */
    sign(keys) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(keys, Keys);
            wasm.unsignedevent_sign(retptr, ptr, keys.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Add signature to unsigned event
    *
    * Internally verify the event.
    * @param {string} sig
    * @returns {Event}
    */
    addSignature(sig) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(sig, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
            const len0 = WASM_VECTOR_LEN;
            wasm.unsignedevent_addSignature(retptr, ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Event.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.UnsignedEvent = UnsignedEvent;

const UnwrappedGiftFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_unwrappedgift_free(ptr >>> 0));
/**
* Unwrapped Gift Wrap
*
* <https://github.com/nostr-protocol/nips/blob/master/59.md>
*/
class UnwrappedGift {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(UnwrappedGift.prototype);
        obj.__wbg_ptr = ptr;
        UnwrappedGiftFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UnwrappedGiftFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_unwrappedgift_free(ptr);
    }
    /**
    * Unwrap Gift Wrap event
    *
    * Internally verify the `seal` event
    * @param {Keys} receiver_keys
    * @param {Event} gift_wrap
    * @returns {UnwrappedGift}
    */
    static fromGiftWrap(receiver_keys, gift_wrap) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(receiver_keys, Keys);
            _assertClass(gift_wrap, Event);
            wasm.unwrappedgift_fromGiftWrap(retptr, receiver_keys.__wbg_ptr, gift_wrap.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UnwrappedGift.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Get sender public key
    * @returns {PublicKey}
    */
    get sender() {
        const ret = wasm.coordinate_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * Get rumor
    * @returns {UnsignedEvent}
    */
    get rumor() {
        const ret = wasm.unwrappedgift_rumor(this.__wbg_ptr);
        return UnsignedEvent.__wrap(ret);
    }
}
module.exports.UnwrappedGift = UnwrappedGift;

const UserFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_user_free(ptr >>> 0));
/**
*/
class User {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(User.prototype);
        obj.__wbg_ptr = ptr;
        UserFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        UserFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_user_free(ptr);
    }
    /**
    * @returns {PublicKey}
    */
    get publicKey() {
        const ret = wasm.__wbg_get_user_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @param {PublicKey} arg0
    */
    set publicKey(arg0) {
        _assertClass(arg0, PublicKey);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_user_publicKey(this.__wbg_ptr, ptr0);
    }
    /**
    * @returns {string | undefined}
    */
    get url() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.__wbg_get_lookupinvoicerequestparams_payment_hash(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string | undefined} [arg0]
    */
    set url(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_lookupinvoicerequestparams_payment_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
    * @param {PublicKey} public_key
    * @param {string | undefined} [url]
    */
    constructor(public_key, url) {
        _assertClass(public_key, PublicKey);
        var ptr0 = public_key.__destroy_into_raw();
        var ptr1 = isLikeNone(url) ? 0 : passStringToWasm0(url, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len1 = WASM_VECTOR_LEN;
        const ret = wasm.user_new(ptr0, ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
}
module.exports.User = User;

const ZapRequestDataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_zaprequestdata_free(ptr >>> 0));
/**
*/
class ZapRequestData {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ZapRequestDataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_zaprequestdata_free(ptr);
    }
    /**
    * @param {PublicKey} public_key
    * @param {(string)[]} relays
    * @param {string} message
    * @param {number | undefined} [amount]
    * @param {string | undefined} [lnurl]
    * @param {EventId | undefined} [event_id]
    * @param {Coordinate | undefined} [event_coordinate]
    */
    constructor(public_key, relays, message, amount, lnurl, event_id, event_coordinate) {
        _assertClass(public_key, PublicKey);
        const ptr0 = passArrayJsValueToWasm0(relays, wasm.__wbindgen_export_0);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(message, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        const len1 = WASM_VECTOR_LEN;
        var ptr2 = isLikeNone(lnurl) ? 0 : passStringToWasm0(lnurl, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
        var len2 = WASM_VECTOR_LEN;
        let ptr3 = 0;
        if (!isLikeNone(event_id)) {
            _assertClass(event_id, EventId);
            ptr3 = event_id.__destroy_into_raw();
        }
        let ptr4 = 0;
        if (!isLikeNone(event_coordinate)) {
            _assertClass(event_coordinate, Coordinate);
            ptr4 = event_coordinate.__destroy_into_raw();
        }
        const ret = wasm.zaprequestdata_new(public_key.__wbg_ptr, ptr0, len0, ptr1, len1, !isLikeNone(amount), isLikeNone(amount) ? 0 : amount, ptr2, len2, ptr3, ptr4);
        this.__wbg_ptr = ret >>> 0;
        return this;
    }
    /**
    * @returns {PublicKey}
    */
    get publicKey() {
        const ret = wasm.zaprequestdata_publicKey(this.__wbg_ptr);
        return PublicKey.__wrap(ret);
    }
    /**
    * @returns {(string)[]}
    */
    get relays() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.zaprequestdata_relays(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_4(r0, r1 * 4, 4);
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string}
    */
    get message() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.zaprequestdata_message(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_export_4(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {number | undefined}
    */
    get amount() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.zaprequestdata_amount(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r2 = getFloat64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r2;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    get lnurl() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.zaprequestdata_lnurl(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_export_4(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {EventId | undefined}
    */
    get eventID() {
        const ret = wasm.zaprequestdata_eventID(this.__wbg_ptr);
        return ret === 0 ? undefined : EventId.__wrap(ret);
    }
    /**
    * @returns {Coordinate | undefined}
    */
    get eventCoordinate() {
        const ret = wasm.zaprequestdata_eventCoordinate(this.__wbg_ptr);
        return ret === 0 ? undefined : Coordinate.__wrap(ret);
    }
}
module.exports.ZapRequestData = ZapRequestData;

module.exports.__wbg_shippingmethod_new = function(arg0) {
    const ret = ShippingMethod.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_payinvoicerequestparams_new = function(arg0) {
    const ret = PayInvoiceRequestParams.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbindgen_number_new = function(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
};

module.exports.__wbg_user_new = function(arg0) {
    const ret = User.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_coordinate_new = function(arg0) {
    const ret = Coordinate.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_eventid_new = function(arg0) {
    const ret = EventId.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_relaylistitem_new = function(arg0) {
    const ret = RelayListItem.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_tag_new = function(arg0) {
    const ret = Tag.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_publickey_new = function(arg0) {
    const ret = PublicKey.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_emojiinfo_new = function(arg0) {
    const ret = EmojiInfo.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_event_new = function(arg0) {
    const ret = Event.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_keysendtlvrecord_new = function(arg0) {
    const ret = KeysendTLVRecord.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_relayinformationdocument_new = function(arg0) {
    const ret = RelayInformationDocument.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_paykeysendrequestparams_new = function(arg0) {
    const ret = PayKeysendRequestParams.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_shippingcost_new = function(arg0) {
    const ret = ShippingCost.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
};

module.exports.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
};

module.exports.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof(obj) === 'string' ? obj : undefined;
    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    var len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
};

module.exports.__wbg_eventid_unwrap = function(arg0) {
    const ret = EventId.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_thumbnails_unwrap = function(arg0) {
    const ret = Thumbnails.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_tag_unwrap = function(arg0) {
    const ret = Tag.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_event_unwrap = function(arg0) {
    const ret = Event.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_publickey_unwrap = function(arg0) {
    const ret = PublicKey.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_coordinate_unwrap = function(arg0) {
    const ret = Coordinate.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_payinvoicerequestparams_unwrap = function(arg0) {
    const ret = PayInvoiceRequestParams.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_keysendtlvrecord_unwrap = function(arg0) {
    const ret = KeysendTLVRecord.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_paykeysendrequestparams_unwrap = function(arg0) {
    const ret = PayKeysendRequestParams.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_emojiinfo_unwrap = function(arg0) {
    const ret = EmojiInfo.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_relaylistitem_unwrap = function(arg0) {
    const ret = RelayListItem.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_contact_unwrap = function(arg0) {
    const ret = Contact.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_filter_unwrap = function(arg0) {
    const ret = Filter.__unwrap(takeObject(arg0));
    return ret;
};

module.exports.__wbg_new_abda76e883ba8a5f = function() {
    const ret = new Error();
    return addHeapObject(ret);
};

module.exports.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
};

module.exports.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        console.error(getStringFromWasm0(arg0, arg1));
    } finally {
        wasm.__wbindgen_export_4(deferred0_0, deferred0_1, 1);
    }
};

module.exports.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_fetch_226e3dfaba0d2a21 = function(arg0) {
    const ret = fetch(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_queueMicrotask_adae4bc085237231 = function(arg0) {
    const ret = getObject(arg0).queueMicrotask;
    return addHeapObject(ret);
};

module.exports.__wbindgen_is_function = function(arg0) {
    const ret = typeof(getObject(arg0)) === 'function';
    return ret;
};

module.exports.__wbindgen_cb_drop = function(arg0) {
    const obj = takeObject(arg0).original;
    if (obj.cnt-- == 1) {
        obj.a = 0;
        return true;
    }
    const ret = false;
    return ret;
};

module.exports.__wbg_queueMicrotask_4d890031a6a5a50c = function(arg0) {
    queueMicrotask(getObject(arg0));
};

module.exports.__wbg_instanceof_Window_3e5cd1f48c152d01 = function(arg0) {
    let result;
    try {
        result = getObject(arg0) instanceof Window;
    } catch (_) {
        result = false;
    }
    const ret = result;
    return ret;
};

module.exports.__wbg_signal_3c701f5f40a5f08d = function(arg0) {
    const ret = getObject(arg0).signal;
    return addHeapObject(ret);
};

module.exports.__wbg_new_0ae46f44b7485bb2 = function() { return handleError(function () {
    const ret = new AbortController();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_abort_2c4fb490d878d2b2 = function(arg0) {
    getObject(arg0).abort();
};

module.exports.__wbg_new_7a20246daa6eec7e = function() { return handleError(function () {
    const ret = new Headers();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_append_aa3f462f9e2b5ff2 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {
    getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
}, arguments) };

module.exports.__wbg_newwithstrandinit_f581dff0d19a8b03 = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_instanceof_Response_4c3b1446206114d1 = function(arg0) {
    let result;
    try {
        result = getObject(arg0) instanceof Response;
    } catch (_) {
        result = false;
    }
    const ret = result;
    return ret;
};

module.exports.__wbg_url_83a6a4f65f7a2b38 = function(arg0, arg1) {
    const ret = getObject(arg1).url;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
};

module.exports.__wbg_status_d6d47ad2837621eb = function(arg0) {
    const ret = getObject(arg0).status;
    return ret;
};

module.exports.__wbg_headers_24def508a7518df9 = function(arg0) {
    const ret = getObject(arg0).headers;
    return addHeapObject(ret);
};

module.exports.__wbg_text_668782292b0bc561 = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).text();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_fetch_693453ca3f88c055 = function(arg0, arg1) {
    const ret = getObject(arg0).fetch(getObject(arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_crypto_d05b68a3572bb8ca = function(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
};

module.exports.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    const ret = typeof(val) === 'object' && val !== null;
    return ret;
};

module.exports.__wbg_process_b02b3570280d0366 = function(arg0) {
    const ret = getObject(arg0).process;
    return addHeapObject(ret);
};

module.exports.__wbg_versions_c1cb42213cedf0f5 = function(arg0) {
    const ret = getObject(arg0).versions;
    return addHeapObject(ret);
};

module.exports.__wbg_node_43b1089f407e4ec2 = function(arg0) {
    const ret = getObject(arg0).node;
    return addHeapObject(ret);
};

module.exports.__wbindgen_is_string = function(arg0) {
    const ret = typeof(getObject(arg0)) === 'string';
    return ret;
};

module.exports.__wbg_require_9a7e0f667ead4995 = function() { return handleError(function () {
    const ret = module.require;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_msCrypto_10fc94afee92bd76 = function(arg0) {
    const ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
};

module.exports.__wbg_randomFillSync_b70ccbdf4926a99d = function() { return handleError(function (arg0, arg1) {
    getObject(arg0).randomFillSync(takeObject(arg1));
}, arguments) };

module.exports.__wbg_getRandomValues_7e42b4fb8779dc6d = function() { return handleError(function (arg0, arg1) {
    getObject(arg0).getRandomValues(getObject(arg1));
}, arguments) };

module.exports.__wbg_self_ce0dbfc45cf2f5be = function() { return handleError(function () {
    const ret = self.self;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_window_c6fb939a7f436783 = function() { return handleError(function () {
    const ret = window.window;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_globalThis_d1e6af4856ba331b = function() { return handleError(function () {
    const ret = globalThis.globalThis;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_global_207b558942527489 = function() { return handleError(function () {
    const ret = global.global;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject(arg0) === undefined;
    return ret;
};

module.exports.__wbg_newnoargs_e258087cd0daa0ea = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_call_27c0f87801dedf93 = function() { return handleError(function (arg0, arg1) {
    const ret = getObject(arg0).call(getObject(arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_new_16b304a2cfa7ff4a = function() {
    const ret = new Array();
    return addHeapObject(ret);
};

module.exports.__wbg_next_40fc327bfc8770e6 = function(arg0) {
    const ret = getObject(arg0).next;
    return addHeapObject(ret);
};

module.exports.__wbg_next_196c84450b364254 = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).next();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_done_298b57d23c0fc80c = function(arg0) {
    const ret = getObject(arg0).done;
    return ret;
};

module.exports.__wbg_value_d93c65011f51a456 = function(arg0) {
    const ret = getObject(arg0).value;
    return addHeapObject(ret);
};

module.exports.__wbg_iterator_2cee6dadfd956dfa = function() {
    const ret = Symbol.iterator;
    return addHeapObject(ret);
};

module.exports.__wbg_get_e3c254076557e348 = function() { return handleError(function (arg0, arg1) {
    const ret = Reflect.get(getObject(arg0), getObject(arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_new_72fb9a18b5ae2624 = function() {
    const ret = new Object();
    return addHeapObject(ret);
};

module.exports.__wbg_push_a5b05aedc7234f9f = function(arg0, arg1) {
    const ret = getObject(arg0).push(getObject(arg1));
    return ret;
};

module.exports.__wbg_call_b3ca7c6051f9bec1 = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_call_8e7cb608789c2528 = function() { return handleError(function (arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_now_3014639a94423537 = function() {
    const ret = Date.now();
    return ret;
};

module.exports.__wbg_instanceof_Object_71ca3c0a59266746 = function(arg0) {
    let result;
    try {
        result = getObject(arg0) instanceof Object;
    } catch (_) {
        result = false;
    }
    const ret = result;
    return ret;
};

module.exports.__wbg_has_0af94d20077affa2 = function() { return handleError(function (arg0, arg1) {
    const ret = Reflect.has(getObject(arg0), getObject(arg1));
    return ret;
}, arguments) };

module.exports.__wbg_set_1f9b04f170055d33 = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));
    return ret;
}, arguments) };

module.exports.__wbg_buffer_12d079cc21e14bdb = function(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
};

module.exports.__wbg_stringify_8887fe74e1c50d81 = function() { return handleError(function (arg0) {
    const ret = JSON.stringify(getObject(arg0));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_new_81740750da40724f = function(arg0, arg1) {
    try {
        var state0 = {a: arg0, b: arg1};
        var cb0 = (arg0, arg1) => {
            const a = state0.a;
            state0.a = 0;
            try {
                return __wbg_adapter_650(a, state0.b, arg0, arg1);
            } finally {
                state0.a = a;
            }
        };
        const ret = new Promise(cb0);
        return addHeapObject(ret);
    } finally {
        state0.a = state0.b = 0;
    }
};

module.exports.__wbg_resolve_b0083a7967828ec8 = function(arg0) {
    const ret = Promise.resolve(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_then_0c86a60e8fcfe9f6 = function(arg0, arg1) {
    const ret = getObject(arg0).then(getObject(arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_then_a73caa9a87991566 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
};

module.exports.__wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb = function(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
};

module.exports.__wbg_new_63b92bc8671ed464 = function(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_set_a47bac70306a19a7 = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
};

module.exports.__wbg_newwithlength_e9b4878cebadb3d3 = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject(ret);
};

module.exports.__wbg_subarray_a1f73cd4b5b42fe1 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
};

module.exports.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString(getObject(arg1));
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_export_0, wasm.__wbindgen_export_1);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
};

module.exports.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
};

module.exports.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return addHeapObject(ret);
};

module.exports.__wbindgen_closure_wrapper3095 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 301, __wbg_adapter_28);
    return addHeapObject(ret);
};

let inited = false;
module.exports.loadWasmSync = function () {
    if (inited) {
        return;
    }
    if (initPromise) {
        throw new Error("Asynchronous initialisation already in progress: cannot initialise synchronously");
    }
    const bytes = unbase64(require("./nostr_js_bg.wasm.js"));
    const mod = new WebAssembly.Module(bytes);
    const instance = new WebAssembly.Instance(mod, imports);
    wasm = instance.exports;
    wasm.__wbindgen_start();
    inited = true;
};

let initPromise = null;

/**
 * Load the WebAssembly module in the background, if it has not already been loaded.
 *
 * Returns a promise which will resolve once the other methods are ready.
 *
 * @returns {Promise<void>}
 */
module.exports.loadWasmAsync = function () {
    if (inited) {
        return Promise.resolve();
    }
    if (!initPromise) {
        initPromise = Promise.resolve()
            .then(() => require("./nostr_js_bg.wasm.js"))
            .then((b64) => WebAssembly.instantiate(unbase64(b64), imports))
            .then((result) => {
                wasm = result.instance.exports;
                wasm.__wbindgen_start();
                inited = true;
            });
    }
    return initPromise;
};

const b64lookup = new Uint8Array([
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 62, 0, 62, 0, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
    8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 63, 0, 26, 27, 28, 29, 30, 31, 32,
    33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
]);

// base64 decoder, based on the code at https://developer.mozilla.org/en-US/docs/Glossary/Base64#solution_2_%E2%80%93_rewriting_atob_and_btoa_using_typedarrays_and_utf-8
function unbase64(sBase64) {
    const sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, "");
    const nInLen = sB64Enc.length;
    const nOutLen = (nInLen * 3 + 1) >> 2;
    const taBytes = new Uint8Array(nOutLen);

    let nMod3;
    let nMod4;
    let nUint24 = 0;
    let nOutIdx = 0;
    for (let nInIdx = 0; nInIdx < nInLen; nInIdx++) {
        nMod4 = nInIdx & 3;
        nUint24 |= b64lookup[sB64Enc.charCodeAt(nInIdx)] << (6 * (3 - nMod4));
        if (nMod4 === 3 || nInLen - nInIdx === 1) {
            nMod3 = 0;
            while (nMod3 < 3 && nOutIdx < nOutLen) {
                taBytes[nOutIdx] = (nUint24 >>> ((16 >>> nMod3) & 24)) & 255;
                nMod3++;
                nOutIdx++;
            }
            nUint24 = 0;
        }
    }

    return taBytes;
}