/* tslint:disable */
/* eslint-disable */
/**
* @param {LogLevel} level
*/
export function initLogger(level: LogLevel): void;
/**
* Encrypt (NIP04)
* @param {SecretKey} sk
* @param {PublicKey} pk
* @param {string} text
* @returns {string}
*/
export function nip04Encrypt(sk: SecretKey, pk: PublicKey, text: string): string;
/**
* Decrypt (NIP04)
* @param {SecretKey} sk
* @param {PublicKey} pk
* @param {string} encrypted_content
* @returns {string}
*/
export function nip04Decrypt(sk: SecretKey, pk: PublicKey, encrypted_content: string): string;
/**
* Verify NIP05
* @param {PublicKey} public_key
* @param {string} nip05
* @returns {Promise<void>}
*/
export function verifyNip05(public_key: PublicKey, nip05: string): Promise<void>;
/**
* Create a NIP-26 delegation tag (including the signature).
* See also validate_delegation_tag().
* @param {Keys} delegator_keys
* @param {PublicKey} delegatee_pubkey
* @param {string} conditions
* @returns {string}
*/
export function createDelegationTag(delegator_keys: Keys, delegatee_pubkey: PublicKey, conditions: string): string;
/**
* Validate a NIP-26 delegation tag, check signature and conditions.
* @param {string} delegation_tag
* @param {PublicKey} delegatee_pubkey
* @param {number} event_kind
* @param {Timestamp} created_at
* @returns {boolean}
*/
export function validateDelegationTag(delegation_tag: string, delegatee_pubkey: PublicKey, event_kind: number, created_at: Timestamp): boolean;
/**
* Sign delegation (NIP26)
* @param {Keys} keys
* @param {PublicKey} delegatee_pk
* @param {string} conditions
* @returns {string}
*/
export function signDelegation(keys: Keys, delegatee_pk: PublicKey, conditions: string): string;
/**
* Verify delegation signature (NIP26)
* @param {PublicKey} delegator_public_key
* @param {PublicKey} delegatee_public_key
* @param {string} conditions
* @param {string} signature
* @returns {boolean}
*/
export function verifyDelegationSignature(delegator_public_key: PublicKey, delegatee_public_key: PublicKey, conditions: string, signature: string): boolean;
/**
* Encrypt (NIP44)
* @param {SecretKey} sk
* @param {PublicKey} pk
* @param {string} content
* @param {NIP44Version} version
* @returns {string}
*/
export function nip44Encrypt(sk: SecretKey, pk: PublicKey, content: string, version: NIP44Version): string;
/**
* Decrypt (NIP44)
* @param {SecretKey} sk
* @param {PublicKey} pk
* @param {string} payload
* @returns {string}
*/
export function nip44Decrypt(sk: SecretKey, pk: PublicKey, payload: string): string;
/**
* @param {Event} event
* @returns {(RelayListItem)[]}
*/
export function extractRelayList(event: Event): (RelayListItem)[];
/**
* Run some stuff when the Wasm module is instantiated.
*
* Right now, it does the following:
*
* * Redirect Rust panics to JavaScript console.
*/
export function start(): void;
/**
* Encrypted Secret Key version (NIP49)
*/
export enum EncryptedSecretKeyVersion {
  V2 = 0,
}
/**
*/
export enum DataVendingMachineStatus {
  PaymentRequired = 0,
  Processing = 1,
  Error = 2,
  Success = 3,
  Partial = 4,
}
/**
* NIP47 Response Error codes
*/
export enum Nip47ErrorCode {
/**
*  The client is sending commands too fast.
*/
  RateLimited = 0,
/**
* The command is not known of is intentionally not implemented
*/
  NotImplemented = 1,
/**
* The wallet does not have enough funds to cover a fee reserve or the payment amount
*/
  InsufficientBalance = 2,
/**
* The payment failed. This may be due to a timeout, exhausting all routes, insufficient capacity or similar.
*/
  PaymentFailed = 3,
/**
* The invoice could not be found by the given parameters.
*/
  NotFound = 4,
/**
* The wallet has exceeded its spending quota
*/
  QuotaExceeded = 5,
/**
* This public key is not allowed to do this operation
*/
  Restricted = 6,
/**
* This public key has no wallet connected
*/
  Unauthorized = 7,
/**
* An internal error
*/
  Internal = 8,
/**
* Other error
*/
  Other = 9,
}
/**
* Key security
*/
export enum KeySecurity {
/**
* The key has been known to have been handled insecurely (stored unencrypted, cut and paste unencrypted, etc)
*/
  Weak = 0,
/**
* The key has NOT been known to have been handled insecurely (stored encrypted, cut and paste encrypted, etc)
*/
  Medium = 1,
/**
* The client does not track this data
*/
  Unknown = 2,
}
/**
* Transaction Type
*/
export enum TransactionType {
/**
* Incoming payments
*/
  Incoming = 0,
/**
* Outgoing payments
*/
  Outgoing = 1,
}
/**
*/
export enum ZapType {
/**
* Public
*/
  Public = 0,
/**
* Private
*/
  Private = 1,
/**
* Anonymous
*/
  Anonymous = 2,
}
/**
*/
export enum HttpMethod {
  GET = 0,
  POST = 1,
  PUT = 2,
  PATCH = 3,
}
/**
*/
export enum NegentropyDirection {
  Up = 0,
  Down = 1,
  Both = 2,
}
/**
*/
export enum NIP44Version {
/**
* V1 - Deprecated
*/
  Deprecated = 1,
  V2 = 2,
}
/**
*/
export enum RelayMetadata {
  Read = 0,
  Write = 1,
}
/**
*/
export enum RelayStatus {
/**
* Relay initialized
*/
  Initialized = 0,
/**
* Pending
*/
  Pending = 1,
/**
* Connecting
*/
  Connecting = 2,
/**
* Relay connected
*/
  Connected = 3,
/**
* Relay disconnected, will retry to connect again
*/
  Disconnected = 4,
/**
* Stop
*/
  Stopped = 5,
/**
* Relay completely disconnected
*/
  Terminated = 6,
}
/**
*/
export enum Alphabet {
  A = 0,
  B = 1,
  C = 2,
  D = 3,
  E = 4,
  F = 5,
  G = 6,
  H = 7,
  I = 8,
  J = 9,
  K = 10,
  L = 11,
  M = 12,
  N = 13,
  O = 14,
  P = 15,
  Q = 16,
  R = 17,
  S = 18,
  T = 19,
  U = 20,
  V = 21,
  W = 22,
  X = 23,
  Y = 24,
  Z = 25,
}

interface HandleNotification {
    handleEvent: (relayUrl: string, subscriptionId: string, event: Event) => Promise<boolean>;
    handleMsg: (relayUrl: string, message: RelayMessage) => Promise<boolean>;
}


/**
*/
export class AbortHandle {
  free(): void;
/**
* Abort thread
*/
  abort(): void;
/**
* Check if thread is aborted
* @returns {boolean}
*/
  is_aborted(): boolean;
}
/**
*/
export class Aes256Gcm {
  free(): void;
/**
* @param {string} key
* @param {string} iv
*/
  constructor(key: string, iv: string);
/**
*/
  iv: string;
/**
*/
  key: string;
}
/**
* Groups of articles picked by users as interesting and/or belonging to the same category
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
export class ArticlesCuration {
  free(): void;
/**
*/
  coordinate: (Coordinate)[];
/**
*/
  event_ids: (EventId)[];
}
/**
*/
export class AtomicRelayServiceFlags {
  free(): void;
/**
* @param {RelayServiceFlags} flags
* @returns {AtomicRelayServiceFlags}
*/
  static new(flags: RelayServiceFlags): AtomicRelayServiceFlags;
/**
* @param {RelayServiceFlags} flags
*/
  add(flags: RelayServiceFlags): void;
/**
* @param {RelayServiceFlags} flags
*/
  remove(flags: RelayServiceFlags): void;
/**
* Check whether `RelayServiceFlags` are included in this one.
* @param {RelayServiceFlags} flags
* @returns {boolean}
*/
  has(flags: RelayServiceFlags): boolean;
/**
* Check if `READ` service is enabled
* @returns {boolean}
*/
  has_read(): boolean;
/**
* Check if `WRITE` service is enabled
* @returns {boolean}
*/
  has_write(): boolean;
/**
* Check if `PING` service is enabled
* @returns {boolean}
*/
  has_ping(): boolean;
}
/**
* Uncategorized, "global" list of things a user wants to save
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
export class Bookmarks {
  free(): void;
/**
*/
  coordinate: (Coordinate)[];
/**
*/
  event_ids: (EventId)[];
/**
*/
  hashtags: (string)[];
/**
*/
  urls: (string)[];
}
/**
*/
export class Client {
  free(): void;
/**
* @param {NostrSigner | undefined} [signer]
*/
  constructor(signer?: NostrSigner);
/**
* Create a new Client with Options
* @param {NostrSigner | undefined} signer
* @param {Options} opts
* @returns {Client}
*/
  static withOpts(signer: NostrSigner | undefined, opts: Options): Client;
/**
* Update default difficulty for new `Event`
* @param {number} difficulty
*/
  updateDifficulty(difficulty: number): void;
/**
* Get current nostr signer
*
* Rise error if it not set.
* @returns {Promise<NostrSigner>}
*/
  signer(): Promise<NostrSigner>;
/**
* Completely shutdown `Client`
* @returns {Promise<void>}
*/
  shutdown(): Promise<void>;
/**
* Get relays
* @returns {Promise<JsRelay[]>}
*/
  relays(): Promise<JsRelay[]>;
/**
* Get a previously added `Relay`
* @param {string} url
* @returns {Promise<Relay>}
*/
  relay(url: string): Promise<Relay>;
/**
* Add new relay
*
* Return `false` if the relay already exists.
*
* This method use perviously set or default `Options` to configure the `Relay` (ex. set proxy, set min POW, set relay limits, ...).
*
* Connection is **NOT** automatically started with relay, remember to call `connect` method!
* @param {string} url
* @returns {Promise<boolean>}
*/
  addRelay(url: string): Promise<boolean>;
/**
* Add multiple relays
*
* Connection is **NOT** automatically started with relays, remember to call `connect` method!
* @param {(string)[]} urls
* @returns {Promise<void>}
*/
  addRelays(urls: (string)[]): Promise<void>;
/**
* Remove relay
* @param {string} url
* @returns {Promise<void>}
*/
  removeRelay(url: string): Promise<void>;
/**
* Connect relay
* @param {string} url
* @returns {Promise<void>}
*/
  connectRelay(url: string): Promise<void>;
/**
* Disconnect relay
* @param {string} url
* @returns {Promise<void>}
*/
  disconnectRelay(url: string): Promise<void>;
/**
* Connect to all added relays
* @returns {Promise<void>}
*/
  connect(): Promise<void>;
/**
* Disconnect from all relays
* @returns {Promise<void>}
*/
  disconnect(): Promise<void>;
/**
* Subscribe to filters
*
* ### Auto-closing subscription
*
* It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
* @param {(Filter)[]} filters
* @param {SubscribeAutoCloseOptions | undefined} [opts]
* @returns {Promise<string>}
*/
  subscribe(filters: (Filter)[], opts?: SubscribeAutoCloseOptions): Promise<string>;
/**
* Subscribe to filters with custom subscription ID
*
* ### Auto-closing subscription
*
* It's possible to automatically close a subscription by configuring the `SubscribeAutoCloseOptions`.
* @param {string} id
* @param {(Filter)[]} filters
* @param {SubscribeAutoCloseOptions | undefined} [opts]
* @returns {Promise<void>}
*/
  subscribeWithId(id: string, filters: (Filter)[], opts?: SubscribeAutoCloseOptions): Promise<void>;
/**
* Unsubscribe
* @param {string} subscription_id
* @returns {Promise<void>}
*/
  unsubscribe(subscription_id: string): Promise<void>;
/**
* Unsubscribe
* @returns {Promise<void>}
*/
  unsubscribeAll(): Promise<void>;
/**
* Get events of filters
*
* If timeout is not set, the default one from Options will be used.
* @param {(Filter)[]} filters
* @param {Duration | undefined} [timeout]
* @returns {Promise<Event[]>}
*/
  getEventsOf(filters: (Filter)[], timeout?: Duration): Promise<Event[]>;
/**
* Get events of filters from specific relays
*
* Get events both from **local database** and **relays**
* @param {(string)[]} urls
* @param {(Filter)[]} filters
* @param {Duration | undefined} [timeout]
* @returns {Promise<Event[]>}
*/
  getEventsFrom(urls: (string)[], filters: (Filter)[], timeout?: Duration): Promise<Event[]>;
/**
* Send client message
* @param {ClientMessage} msg
* @returns {Promise<void>}
*/
  sendMsg(msg: ClientMessage): Promise<void>;
/**
* Send client message to a specific relay
* @param {(string)[]} urls
* @param {ClientMessage} msg
* @returns {Promise<void>}
*/
  sendMsgTo(urls: (string)[], msg: ClientMessage): Promise<void>;
/**
* Send event
*
* This method will wait for the `OK` message from the relay.
* If you not want to wait for the `OK` message, use `sendMsg` method instead.
* @param {Event} event
* @returns {Promise<EventId>}
*/
  sendEvent(event: Event): Promise<EventId>;
/**
* Send event to specific relay
*
* This method will wait for the `OK` message from the relay.
* If you not want to wait for the `OK` message, use `sendMsgTo` method instead.
* @param {(string)[]} urls
* @param {Event} event
* @returns {Promise<EventId>}
*/
  sendEventTo(urls: (string)[], event: Event): Promise<EventId>;
/**
* Signs the `EventBuilder` into an `Event` using the `NostrSigner`
* @param {EventBuilder} builder
* @returns {Promise<Event>}
*/
  signEventBuilder(builder: EventBuilder): Promise<Event>;
/**
* Take an [`EventBuilder`], sign it by using the [`NostrSigner`] and broadcast to all relays.
*
* Rise an error if the [`NostrSigner`] is not set.
* @param {EventBuilder} builder
* @returns {Promise<EventId>}
*/
  sendEventBuilder(builder: EventBuilder): Promise<EventId>;
/**
* Take an [`EventBuilder`], sign it by using the [`NostrSigner`] and broadcast to specific relays.
*
* Rise an error if the [`NostrSigner`] is not set.
* @param {(string)[]} urls
* @param {EventBuilder} builder
* @returns {Promise<EventId>}
*/
  sendEventBuilderTo(urls: (string)[], builder: EventBuilder): Promise<EventId>;
/**
* Update metadata
*
* <https://github.com/nostr-protocol/nips/blob/master/01.md>
* @param {Metadata} metadata
* @returns {Promise<EventId>}
*/
  setMetadata(metadata: Metadata): Promise<EventId>;
/**
* Publish text note
*
* <https://github.com/nostr-protocol/nips/blob/master/01.md>
* @param {string} content
* @param {(Tag)[]} tags
* @returns {Promise<EventId>}
*/
  publishTextNote(content: string, tags: (Tag)[]): Promise<EventId>;
/**
* Set contact list
*
* <https://github.com/nostr-protocol/nips/blob/master/02.md>
* @param {(Contact)[]} list
* @returns {Promise<EventId>}
*/
  setContactList(list: (Contact)[]): Promise<EventId>;
/**
* Send encrypted direct message
*
* <https://github.com/nostr-protocol/nips/blob/master/04.md>
* @param {PublicKey} receiver
* @param {string} msg
* @param {EventId | undefined} [reply]
* @returns {Promise<EventId>}
*/
  sendDirectMsg(receiver: PublicKey, msg: string, reply?: EventId): Promise<EventId>;
/**
* Repost
* @param {Event} event
* @param {string | undefined} [relay_url]
* @returns {Promise<EventId>}
*/
  repost(event: Event, relay_url?: string): Promise<EventId>;
/**
* Delete event
*
* <https://github.com/nostr-protocol/nips/blob/master/09.md>
* @param {EventId} event_id
* @returns {Promise<EventId>}
*/
  deleteEvent(event_id: EventId): Promise<EventId>;
/**
* Like event
*
* <https://github.com/nostr-protocol/nips/blob/master/25.md>
* @param {Event} event
* @returns {Promise<EventId>}
*/
  like(event: Event): Promise<EventId>;
/**
* Disike event
*
* <https://github.com/nostr-protocol/nips/blob/master/25.md>
* @param {Event} event
* @returns {Promise<EventId>}
*/
  dislike(event: Event): Promise<EventId>;
/**
* React to an [`Event`]
*
* <https://github.com/nostr-protocol/nips/blob/master/25.md>
* @param {Event} event
* @param {string} reaction
* @returns {Promise<EventId>}
*/
  reaction(event: Event, reaction: string): Promise<EventId>;
/**
* Create new channel
*
* <https://github.com/nostr-protocol/nips/blob/master/28.md>
* @param {Metadata} metadata
* @returns {Promise<EventId>}
*/
  newChannel(metadata: Metadata): Promise<EventId>;
/**
* Update channel metadata
*
* <https://github.com/nostr-protocol/nips/blob/master/28.md>
* @param {EventId} channel_id
* @param {string | undefined} relay_url
* @param {Metadata} metadata
* @returns {Promise<EventId>}
*/
  setChannelMetadata(channel_id: EventId, relay_url: string | undefined, metadata: Metadata): Promise<EventId>;
/**
* Send message to channel
*
* <https://github.com/nostr-protocol/nips/blob/master/28.md>
* @param {EventId} channel_id
* @param {string} relay_url
* @param {string} msg
* @returns {Promise<EventId>}
*/
  sendChannelMsg(channel_id: EventId, relay_url: string, msg: string): Promise<EventId>;
/**
* Hide channel message
*
* <https://github.com/nostr-protocol/nips/blob/master/28.md>
* @param {EventId} message_id
* @param {string | undefined} [reason]
* @returns {Promise<EventId>}
*/
  hideChannelUser(message_id: EventId, reason?: string): Promise<EventId>;
/**
* Mute channel user
*
* <https://github.com/nostr-protocol/nips/blob/master/28.md>
* @param {PublicKey} pubkey
* @param {string | undefined} [reason]
* @returns {Promise<EventId>}
*/
  muteChannelUser(pubkey: PublicKey, reason?: string): Promise<EventId>;
/**
* Send a Zap!
*
* This method automatically create a split zap to support Rust Nostr development.
* @param {ZapEntity} to
* @param {number} satoshi
* @param {ZapDetails | undefined} [details]
* @returns {Promise<void>}
*/
  zap(to: ZapEntity, satoshi: number, details?: ZapDetails): Promise<void>;
/**
* Gift Wrap
*
* <https://github.com/nostr-protocol/nips/blob/master/59.md>
* @param {PublicKey} receiver
* @param {EventBuilder} rumor
* @param {Timestamp | undefined} [expiration]
* @returns {Promise<void>}
*/
  giftWrap(receiver: PublicKey, rumor: EventBuilder, expiration?: Timestamp): Promise<void>;
/**
* Send GiftWrapper Sealed Direct message
* @param {PublicKey} receiver
* @param {string} message
* @param {Timestamp | undefined} [expiration]
* @returns {Promise<void>}
*/
  sendSealedMsg(receiver: PublicKey, message: string, expiration?: Timestamp): Promise<void>;
/**
* Negentropy reconciliation
*
* <https://github.com/hoytech/negentropy>
* @param {Filter} filter
* @param {NegentropyOptions} opts
* @returns {Promise<void>}
*/
  reconcile(filter: Filter, opts: NegentropyOptions): Promise<void>;
/**
* Handle notifications
*
* **This method spawn a thread**, so ensure to keep up the app after calling this (if needed).
*
* To exit from the handle notifications loop, return `true` or call `abortable.abort();`.
*
* # Example
* ```javascript
* // Subscribe to filters
* const filter = new Filter().author(keys.publicKey);
* await client.subscribe([filter]);
*
* const handle = {
*    // Handle event
*    handleEvent: async (relayUrl, subscriptionId, event) => {
*        console.log("Received new event from", relayUrl);
*        if (event.kind == 4) {
*            try {
*                let content = nip04Decrypt(keys.secretKey, event.author, event.content);
*                console.log("Message:", content);
*                await client.sendDirectMsg(event.author, "Echo: " + content);
*
*                if (content == "stop") {
*                    return true;
*                }
*            } catch (error) {
*                console.log("Impossible to decrypt DM:", error);
*            }
*         }
*     },
*     // Handle relay message
*     handleMsg: async (relayUrl, message) => {
*         console.log("Received message from", relayUrl, message.asJson());
*     }
*  };
*
* let abortable = client.handleNotifications(handle);
* // Optionally, call `abortable.abort();` when you need to stop handle notifications thread
* ```
* @param {HandleNotification} callback
* @returns {AbortHandle}
*/
  handleNotifications(callback: HandleNotification): AbortHandle;
/**
*/
  readonly database: NostrDatabase;
}
/**
*/
export class ClientBuilder {
  free(): void;
/**
* New client builder
*/
  constructor();
/**
* @param {NostrSigner} signer
* @returns {ClientBuilder}
*/
  signer(signer: NostrSigner): ClientBuilder;
/**
* @param {NostrZapper} zapper
* @returns {ClientBuilder}
*/
  zapper(zapper: NostrZapper): ClientBuilder;
/**
* @param {NostrDatabase} database
* @returns {ClientBuilder}
*/
  database(database: NostrDatabase): ClientBuilder;
/**
* @param {Options} opts
* @returns {ClientBuilder}
*/
  opts(opts: Options): ClientBuilder;
/**
* Build `Client`
*
* This method **consume** the `ClientBuilder`!
* @returns {Client}
*/
  build(): Client;
}
/**
*/
export class ClientMessage {
  free(): void;
/**
* Create new `EVENT` message
* @param {Event} event
* @returns {ClientMessage}
*/
  static event(event: Event): ClientMessage;
/**
* Create new `REQ` message
* @param {string} subscription_id
* @param {(Filter)[]} filters
* @returns {ClientMessage}
*/
  static req(subscription_id: string, filters: (Filter)[]): ClientMessage;
/**
* Create new `COUNT` message
* @param {string} subscription_id
* @param {(Filter)[]} filters
* @returns {ClientMessage}
*/
  static count(subscription_id: string, filters: (Filter)[]): ClientMessage;
/**
* Create new `CLOSE` message
* @param {string} subscription_id
* @returns {ClientMessage}
*/
  static close(subscription_id: string): ClientMessage;
/**
* Create new `AUTH` message
* @param {Event} event
* @returns {ClientMessage}
*/
  static auth(event: Event): ClientMessage;
/**
* Deserialize `ClientMessage` from JSON string
*
* **This method NOT verify the event signature!**
* @param {string} json
* @returns {ClientMessage}
*/
  static fromJson(json: string): ClientMessage;
/**
* @returns {string}
*/
  asJson(): string;
}
/**
*/
export class Contact {
  free(): void;
/**
* @param {PublicKey} public_key
* @param {string | undefined} [relay_url]
* @param {string | undefined} [alias]
*/
  constructor(public_key: PublicKey, relay_url?: string, alias?: string);
}
/**
*/
export class Coordinate {
  free(): void;
/**
* @param {number} kind
* @param {PublicKey} public_key
* @param {string | undefined} [identifier]
* @param {(string)[] | undefined} [relays]
*/
  constructor(kind: number, public_key: PublicKey, identifier?: string, relays?: (string)[]);
/**
*/
  readonly identifier: string;
/**
*/
  readonly kind: number;
/**
*/
  readonly publicKey: PublicKey;
/**
*/
  readonly relays: (string)[];
}
/**
*/
export class Duration {
  free(): void;
/**
* @param {number} secs
* @returns {Duration}
*/
  static fromSecs(secs: number): Duration;
/**
* @param {bigint} millis
* @returns {Duration}
*/
  static fromMillis(millis: bigint): Duration;
/**
* @returns {number}
*/
  asSecs(): number;
/**
* @returns {number}
*/
  asMillis(): number;
}
/**
* Emoji
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
export class EmojiInfo {
  free(): void;
/**
*/
  shortcode: string;
/**
*/
  url: string;
}
/**
* User preferred emojis and pointers to emoji sets
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
export class Emojis {
  free(): void;
/**
*/
  coordinate: (Coordinate)[];
/**
*/
  emojis: (EmojiInfo)[];
}
/**
* Encrypted Secret Key
*/
export class EncryptedSecretKey {
  free(): void;
/**
* Encrypt secret key
* @param {SecretKey} secret_key
* @param {string} password
* @param {number} log_n
* @param {KeySecurity} key_security
*/
  constructor(secret_key: SecretKey, password: string, log_n: number, key_security: KeySecurity);
/**
* @param {string} bech32
* @returns {EncryptedSecretKey}
*/
  static fromBech32(bech32: string): EncryptedSecretKey;
/**
* Get encrypted secret key version
* @returns {EncryptedSecretKeyVersion}
*/
  version(): EncryptedSecretKeyVersion;
/**
* Get encrypted secret key security
* @returns {KeySecurity}
*/
  keySecurity(): KeySecurity;
/**
* Consume `EncryptedSecretKey` and return `SecretKey`
* @param {string} password
* @returns {SecretKey}
*/
  toSecretKey(password: string): SecretKey;
/**
* Decrypt to `SecretKey`
* @param {string} password
* @returns {SecretKey}
*/
  asSecretKey(password: string): SecretKey;
/**
* @returns {string}
*/
  toBech32(): string;
}
/**
*/
export class Event {
  free(): void;
/**
* @returns {boolean}
*/
  verify(): boolean;
/**
* @param {string} json
* @returns {Event}
*/
  static fromJson(json: string): Event;
/**
* @returns {string}
*/
  asJson(): string;
/**
* Get event author (`pubkey` field)
*/
  readonly author: PublicKey;
/**
*/
  readonly content: string;
/**
*/
  readonly createdAt: Timestamp;
/**
*/
  readonly id: EventId;
/**
*/
  readonly kind: number;
/**
*/
  readonly signature: string;
/**
*/
  readonly tags: (Tag)[];
}
/**
*/
export class EventBuilder {
  free(): void;
/**
* @param {number} kind
* @param {string} content
* @param {(Tag)[]} tags
*/
  constructor(kind: number, content: string, tags: (Tag)[]);
/**
* Set a custom `created_at` UNIX timestamp
* @param {Timestamp} created_at
* @returns {EventBuilder}
*/
  customCreatedAt(created_at: Timestamp): EventBuilder;
/**
* Build `Event`
*
* **This method consume the builder, so it will no longer be usable!**
* @param {Keys} keys
* @returns {Event}
*/
  toEvent(keys: Keys): Event;
/**
* Build `UnsignedEvent`
*
* **This method consume the builder, so it will no longer be usable!**
* @param {PublicKey} public_key
* @returns {UnsignedEvent}
*/
  toUnsignedEvent(public_key: PublicKey): UnsignedEvent;
/**
* Build POW `Event`
*
* **This method consume the builder, so it will no longer be usable!**
* @param {Keys} keys
* @param {number} difficulty
* @returns {Event}
*/
  toPowEvent(keys: Keys, difficulty: number): Event;
/**
* Build Unisgned POW Event
*
* **This method consume the builder, so it will no longer be usable!**
* @param {PublicKey} public_key
* @param {number} difficulty
* @returns {UnsignedEvent}
*/
  toUnsignedPowEvent(public_key: PublicKey, difficulty: number): UnsignedEvent;
/**
* @param {Metadata} metadata
* @returns {EventBuilder}
*/
  static metadata(metadata: Metadata): EventBuilder;
/**
* @param {(RelayListItem)[]} relays
* @returns {EventBuilder}
*/
  static relayList(relays: (RelayListItem)[]): EventBuilder;
/**
* @param {string} content
* @param {(Tag)[]} tags
* @returns {EventBuilder}
*/
  static textNote(content: string, tags: (Tag)[]): EventBuilder;
/**
* Text note reply
*
* If no `root` is passed, the `rely_to` will be used for root `e` tag.
*
* <https://github.com/nostr-protocol/nips/blob/master/10.md>
* @param {string} content
* @param {Event} reply_to
* @param {Event | undefined} [root]
* @param {string | undefined} [relay_url]
* @returns {EventBuilder}
*/
  static textNoteReply(content: string, reply_to: Event, root?: Event, relay_url?: string): EventBuilder;
/**
* @param {string} content
* @param {(Tag)[]} tags
* @returns {EventBuilder}
*/
  static longFormTextNote(content: string, tags: (Tag)[]): EventBuilder;
/**
* @param {(Contact)[]} list
* @returns {EventBuilder}
*/
  static contactList(list: (Contact)[]): EventBuilder;
/**
* @param {Keys} sender_keys
* @param {PublicKey} receiver_pubkey
* @param {string} content
* @param {EventId | undefined} [reply_to]
* @returns {EventBuilder}
*/
  static encryptedDirectMsg(sender_keys: Keys, receiver_pubkey: PublicKey, content: string, reply_to?: EventId): EventBuilder;
/**
* Repost
* @param {Event} event
* @param {string | undefined} [relay_url]
* @returns {EventBuilder}
*/
  static repost(event: Event, relay_url?: string): EventBuilder;
/**
* @param {(EventId)[]} ids
* @param {string | undefined} [reason]
* @returns {EventBuilder}
*/
  static delete(ids: (EventId)[], reason?: string): EventBuilder;
/**
* Add reaction (like/upvote, dislike/downvote or emoji) to an event
* @param {Event} event
* @param {string} reaction
* @returns {EventBuilder}
*/
  static reaction(event: Event, reaction: string): EventBuilder;
/**
* Add reaction (like/upvote, dislike/downvote or emoji) to an event
* @param {EventId} event_id
* @param {PublicKey} public_key
* @param {number} kind
* @param {string} reaction
* @returns {EventBuilder}
*/
  static reactionExtended(event_id: EventId, public_key: PublicKey, kind: number, reaction: string): EventBuilder;
/**
* @param {Metadata} metadata
* @returns {EventBuilder}
*/
  static channel(metadata: Metadata): EventBuilder;
/**
* @param {EventId} channel_id
* @param {string | undefined} relay_url
* @param {Metadata} metadata
* @returns {EventBuilder}
*/
  static channelMetadata(channel_id: EventId, relay_url: string | undefined, metadata: Metadata): EventBuilder;
/**
* @param {EventId} channel_id
* @param {string} relay_url
* @param {string} content
* @returns {EventBuilder}
*/
  static channelMsg(channel_id: EventId, relay_url: string, content: string): EventBuilder;
/**
* @param {EventId} message_id
* @param {string | undefined} [reason]
* @returns {EventBuilder}
*/
  static hideChannelMsg(message_id: EventId, reason?: string): EventBuilder;
/**
* @param {PublicKey} pubkey
* @param {string | undefined} [reason]
* @returns {EventBuilder}
*/
  static muteChannelUser(pubkey: PublicKey, reason?: string): EventBuilder;
/**
* @param {string} challenge
* @param {string} relay
* @returns {EventBuilder}
*/
  static auth(challenge: string, relay: string): EventBuilder;
/**
* @param {LiveEvent} live_event
* @returns {EventBuilder}
*/
  static liveEvent(live_event: LiveEvent): EventBuilder;
/**
* @param {string} live_event_id
* @param {PublicKey} live_event_host
* @param {string} content
* @param {string | undefined} relay_url
* @param {(Tag)[]} tags
* @returns {EventBuilder}
*/
  static liveEventMsg(live_event_id: string, live_event_host: PublicKey, content: string, relay_url: string | undefined, tags: (Tag)[]): EventBuilder;
/**
* @param {(Tag)[]} tags
* @param {string} content
* @returns {EventBuilder}
*/
  static report(tags: (Tag)[], content: string): EventBuilder;
/**
* @param {ZapRequestData} data
* @returns {EventBuilder}
*/
  static publicZapRequest(data: ZapRequestData): EventBuilder;
/**
* @param {string} bolt11
* @param {string | undefined} preimage
* @param {Event} zap_request
* @returns {EventBuilder}
*/
  static zapReceipt(bolt11: string, preimage: string | undefined, zap_request: Event): EventBuilder;
/**
* @param {string} badge_id
* @param {string | undefined} name
* @param {string | undefined} description
* @param {string | undefined} image
* @param {ImageDimensions | undefined} image_dimensions
* @param {(Thumbnails)[]} thumbnails
* @returns {EventBuilder}
*/
  static defineBadge(badge_id: string, name: string | undefined, description: string | undefined, image: string | undefined, image_dimensions: ImageDimensions | undefined, thumbnails: (Thumbnails)[]): EventBuilder;
/**
* @param {Event} badge_definition
* @param {(Tag)[]} awarded_pubkeys
* @returns {EventBuilder}
*/
  static awardBadge(badge_definition: Event, awarded_pubkeys: (Tag)[]): EventBuilder;
/**
* @param {(Event)[]} badge_definitions
* @param {(Event)[]} badge_awards
* @param {PublicKey} pubkey_awarded
* @returns {EventBuilder}
*/
  static profileBadges(badge_definitions: (Event)[], badge_awards: (Event)[], pubkey_awarded: PublicKey): EventBuilder;
/**
* @param {number} kind
* @param {(Tag)[]} tags
* @returns {EventBuilder}
*/
  static jobRequest(kind: number, tags: (Tag)[]): EventBuilder;
/**
* @param {Event} job_request
* @param {number} amount_millisats
* @param {string | undefined} [bolt11]
* @returns {EventBuilder}
*/
  static jobResult(job_request: Event, amount_millisats: number, bolt11?: string): EventBuilder;
/**
* @param {Event} job_request
* @param {DataVendingMachineStatus} status
* @param {string | undefined} extra_info
* @param {bigint} amount_millisats
* @param {string | undefined} [bolt11]
* @param {string | undefined} [payload]
* @returns {EventBuilder}
*/
  static jobFeedback(job_request: Event, status: DataVendingMachineStatus, extra_info: string | undefined, amount_millisats: bigint, bolt11?: string, payload?: string): EventBuilder;
/**
* @param {string} description
* @param {FileMetadata} metadata
* @returns {EventBuilder}
*/
  static fileMetadata(description: string, metadata: FileMetadata): EventBuilder;
/**
* @param {HttpData} data
* @returns {EventBuilder}
*/
  static httpAuth(data: HttpData): EventBuilder;
/**
* @param {StallData} data
* @returns {EventBuilder}
*/
  static stallData(data: StallData): EventBuilder;
/**
* @param {ProductData} data
* @returns {EventBuilder}
*/
  static productData(data: ProductData): EventBuilder;
/**
* Gift Wrap from seal
*
* <https://github.com/nostr-protocol/nips/blob/master/59.md>
* @param {PublicKey} receiver
* @param {Event} seal
* @param {Timestamp | undefined} [expiration]
* @returns {Event}
*/
  static giftWrapFromSeal(receiver: PublicKey, seal: Event, expiration?: Timestamp): Event;
/**
* Gift Wrap
*
* <https://github.com/nostr-protocol/nips/blob/master/59.md>
* @param {Keys} sender_keys
* @param {PublicKey} receiver
* @param {UnsignedEvent} rumor
* @param {Timestamp | undefined} [expiration]
* @returns {Event}
*/
  static giftWrap(sender_keys: Keys, receiver: PublicKey, rumor: UnsignedEvent, expiration?: Timestamp): Event;
/**
* GiftWrapped Sealed Direct message
* @param {PublicKey} receiver
* @param {string} message
* @returns {EventBuilder}
*/
  static sealedDirect(receiver: PublicKey, message: string): EventBuilder;
/**
* Mute list
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {MuteList} list
* @returns {EventBuilder}
*/
  static muteList(list: MuteList): EventBuilder;
/**
* Pinned notes
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(EventId)[]} ids
* @returns {EventBuilder}
*/
  static pinnedNotes(ids: (EventId)[]): EventBuilder;
/**
* Bookmarks
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {Bookmarks} list
* @returns {EventBuilder}
*/
  static bookmarks(list: Bookmarks): EventBuilder;
/**
* Communities
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(Coordinate)[]} communities
* @returns {EventBuilder}
*/
  static communities(communities: (Coordinate)[]): EventBuilder;
/**
* Public chats
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(EventId)[]} chat
* @returns {EventBuilder}
*/
  static publicChats(chat: (EventId)[]): EventBuilder;
/**
* Blocked relays
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(string)[]} relays
* @returns {EventBuilder}
*/
  static blockedRelays(relays: (string)[]): EventBuilder;
/**
* Search relays
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(string)[]} relays
* @returns {EventBuilder}
*/
  static searchRelays(relays: (string)[]): EventBuilder;
/**
* Interests
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {Interests} list
* @returns {EventBuilder}
*/
  static interests(list: Interests): EventBuilder;
/**
* Emojis
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {Emojis} list
* @returns {EventBuilder}
*/
  static emojis(list: Emojis): EventBuilder;
/**
* Follow sets
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(PublicKey)[]} public_keys
* @returns {EventBuilder}
*/
  static followSets(public_keys: (PublicKey)[]): EventBuilder;
/**
* Relay sets
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(string)[]} relays
* @returns {EventBuilder}
*/
  static relaySets(relays: (string)[]): EventBuilder;
/**
* Bookmark sets
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {Bookmarks} list
* @returns {EventBuilder}
*/
  static bookmarksSets(list: Bookmarks): EventBuilder;
/**
* Article Curation sets
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {ArticlesCuration} list
* @returns {EventBuilder}
*/
  static articlesCurationSets(list: ArticlesCuration): EventBuilder;
/**
* Videos Curation sets
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(Coordinate)[]} video
* @returns {EventBuilder}
*/
  static videosCurationSets(video: (Coordinate)[]): EventBuilder;
/**
* Emoji sets
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(EmojiInfo)[]} emoji
* @returns {EventBuilder}
*/
  static emojiSets(emoji: (EmojiInfo)[]): EventBuilder;
/**
* Label
*
* <https://github.com/nostr-protocol/nips/blob/master/32.md>
* @param {string} label_namespace
* @param {(string)[]} labels
* @returns {EventBuilder}
*/
  static label(label_namespace: string, labels: (string)[]): EventBuilder;
}
/**
*/
export class EventId {
  free(): void;
/**
* @param {PublicKey} pubkey
* @param {Timestamp} created_at
* @param {number} kind
* @param {(Tag)[]} tags
* @param {string} content
*/
  constructor(pubkey: PublicKey, created_at: Timestamp, kind: number, tags: (Tag)[], content: string);
/**
* Try to parse event ID from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
* @param {string} id
* @returns {EventId}
*/
  static parse(id: string): EventId;
/**
* @param {Uint8Array} bytes
* @returns {EventId}
*/
  static fromSlice(bytes: Uint8Array): EventId;
/**
* @param {string} hex
* @returns {EventId}
*/
  static fromHex(hex: string): EventId;
/**
* @param {string} bech32
* @returns {EventId}
*/
  static fromBech32(bech32: string): EventId;
/**
* @returns {Uint8Array}
*/
  asBytes(): Uint8Array;
/**
* @returns {string}
*/
  toHex(): string;
/**
* @returns {string}
*/
  toBech32(): string;
}
/**
*/
export class FileMetadata {
  free(): void;
/**
* @param {string} url
* @param {string} mime_type
* @param {string} hash
*/
  constructor(url: string, mime_type: string, hash: string);
/**
*/
  readonly aes256Gcm: Aes256Gcm | undefined;
/**
*/
  readonly blurhash: string | undefined;
/**
*/
  readonly dim: ImageDimensions | undefined;
/**
*/
  readonly hash: string;
/**
*/
  readonly magnet: string | undefined;
/**
*/
  readonly mimeType: string;
/**
*/
  readonly size: number | undefined;
/**
*/
  readonly urls: string;
}
/**
*/
export class Filter {
  free(): void;
/**
*/
  constructor();
/**
* @param {string} json
* @returns {Filter}
*/
  static fromJson(json: string): Filter;
/**
* @returns {string}
*/
  asJson(): string;
/**
* Set subscription id
* @param {EventId} id
* @returns {Filter}
*/
  id(id: EventId): Filter;
/**
* Set subscription ids
* @param {(EventId)[]} ids
* @returns {Filter}
*/
  ids(ids: (EventId)[]): Filter;
/**
* Set author
* @param {PublicKey} author
* @returns {Filter}
*/
  author(author: PublicKey): Filter;
/**
* Set authors
* @param {(PublicKey)[]} authors
* @returns {Filter}
*/
  authors(authors: (PublicKey)[]): Filter;
/**
* Set kind
* @param {number} kind
* @returns {Filter}
*/
  kind(kind: number): Filter;
/**
* Set kinds
* @param {Float64Array} kinds
* @returns {Filter}
*/
  kinds(kinds: Float64Array): Filter;
/**
* Set event
* @param {EventId} id
* @returns {Filter}
*/
  event(id: EventId): Filter;
/**
* Set events
* @param {(EventId)[]} ids
* @returns {Filter}
*/
  events(ids: (EventId)[]): Filter;
/**
* Set pubkey
* @param {PublicKey} pubkey
* @returns {Filter}
*/
  pubkey(pubkey: PublicKey): Filter;
/**
* Set pubkeys
* @param {(PublicKey)[]} pubkeys
* @returns {Filter}
*/
  pubkeys(pubkeys: (PublicKey)[]): Filter;
/**
* Set hashtag
*
* <https://github.com/nostr-protocol/nips/blob/master/12.md>
* @param {string} hashtag
* @returns {Filter}
*/
  hashtag(hashtag: string): Filter;
/**
* Set hashtags
*
* <https://github.com/nostr-protocol/nips/blob/master/12.md>
* @param {(string)[]} hashtags
* @returns {Filter}
*/
  hashtags(hashtags: (string)[]): Filter;
/**
* Set reference
*
* <https://github.com/nostr-protocol/nips/blob/master/12.md>
* @param {string} v
* @returns {Filter}
*/
  reference(v: string): Filter;
/**
* Set references
*
* <https://github.com/nostr-protocol/nips/blob/master/12.md>
* @param {(string)[]} v
* @returns {Filter}
*/
  references(v: (string)[]): Filter;
/**
* Set search field
* @param {string} value
* @returns {Filter}
*/
  search(value: string): Filter;
/**
* Set since unix timestamp
* @param {Timestamp} since
* @returns {Filter}
*/
  since(since: Timestamp): Filter;
/**
* Set until unix timestamp
* @param {Timestamp} until
* @returns {Filter}
*/
  until(until: Timestamp): Filter;
/**
* Set limit
* @param {number} limit
* @returns {Filter}
*/
  limit(limit: number): Filter;
/**
* @param {SingleLetterTag} tag
* @param {(string)[]} values
* @returns {Filter}
*/
  customTag(tag: SingleLetterTag, values: (string)[]): Filter;
/**
* @param {SingleLetterTag} tag
* @param {(string)[]} values
* @returns {Filter}
*/
  removeCustomTag(tag: SingleLetterTag, values: (string)[]): Filter;
/**
* Determine if `Filter` match given `Event`.
*
* The `search` filed is not supported yet!
* @param {Event} event
* @returns {boolean}
*/
  matchEvent(event: Event): boolean;
}
/**
* Filter options
*/
export class FilterOptions {
  free(): void;
/**
* Exit on EOSE
* @returns {FilterOptions}
*/
  static exitOnEose(): FilterOptions;
/**
* After EOSE is received, keep listening for N more events that match the filter, then return
* @param {number} num
* @returns {FilterOptions}
*/
  static waitForEventsAfterEOSE(num: number): FilterOptions;
/**
* After EOSE is received, keep listening for matching events for `Duration` more time, then return
* @param {Duration} duration
* @returns {FilterOptions}
*/
  static waitDurationAfterEOSE(duration: Duration): FilterOptions;
}
/**
*/
export class GetBalanceResponseResult {
  free(): void;
/**
* Balance amount in msats
*/
  balance: bigint;
}
/**
*/
export class GetInfoResponseResult {
  free(): void;
/**
* The alias of the lightning node
*/
  alias: string;
/**
* Most Recent Block Hash
*/
  block_hash: string;
/**
* Current block height
*/
  block_height: number;
/**
* The color of the current node in hex code format
*/
  color: string;
/**
* Available methods for this connection
*/
  methods: (string)[];
/**
* Active network
*/
  network: string;
/**
* Lightning Node's public key
*/
  pubkey: string;
}
/**
*/
export class HttpData {
  free(): void;
/**
* @param {string} url
* @param {HttpMethod} method
*/
  constructor(url: string, method: HttpMethod);
/**
*/
  readonly method: HttpMethod;
/**
*/
  readonly payload: string | undefined;
/**
*/
  readonly urls: string;
}
/**
*/
export class Image {
  free(): void;
/**
* @param {string} url
* @param {ImageDimensions | undefined} [dimensions]
*/
  constructor(url: string, dimensions?: ImageDimensions);
/**
*/
  dimensions?: ImageDimensions;
/**
*/
  url: string;
}
/**
*/
export class ImageDimensions {
  free(): void;
/**
*/
  height: bigint;
/**
*/
  width: bigint;
}
/**
* Topics a user may be interested in and pointers
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
export class Interests {
  free(): void;
/**
*/
  coordinate: (Coordinate)[];
/**
*/
  hashtags: (string)[];
}
/**
*/
export class Keys {
  free(): void;
/**
* Initialize from secret key.
* @param {SecretKey} secret_key
*/
  constructor(secret_key: SecretKey);
/**
* Try to parse keys from **secret key** `hex` or `bech32`
* @param {string} secret_key
* @returns {Keys}
*/
  static parse(secret_key: string): Keys;
/**
* Initialize with public key only (no secret key).
* @param {PublicKey} public_key
* @returns {Keys}
*/
  static fromPublicKey(public_key: PublicKey): Keys;
/**
* Generate new random keys
* @returns {Keys}
*/
  static generate(): Keys;
/**
* @param {(string)[]} prefixes
* @param {boolean} bech32
* @param {number} num_cores
* @returns {Keys}
*/
  static vanity(prefixes: (string)[], bech32: boolean, num_cores: number): Keys;
/**
* Derive keys from BIP-39 mnemonics (ENGLISH wordlist).
*
* <https://github.com/nostr-protocol/nips/blob/master/06.md>
* @param {string} mnemonic
* @param {string | undefined} [passphrase]
* @param {number | undefined} [account]
* @param {number | undefined} [typ]
* @param {number | undefined} [index]
* @returns {Keys}
*/
  static fromMnemonic(mnemonic: string, passphrase?: string, account?: number, typ?: number, index?: number): Keys;
/**
* Get public key
*/
  readonly publicKey: PublicKey;
/**
* Get secret key
*/
  readonly secretKey: SecretKey;
}
/**
* TLVs to be added to the keysend payment
*/
export class KeysendTLVRecord {
  free(): void;
/**
* TLV type
*/
  tlv_type: bigint;
/**
* TLV value
*/
  value: string;
}
/**
* List Invoice Request Params
*/
export class ListTransactionsRequestParams {
  free(): void;
/**
* Starting timestamp in seconds since epoch
*/
  from?: bigint;
/**
* Number of invoices to return
*/
  limit?: bigint;
/**
* Offset of the first invoice to return
*/
  offset?: bigint;
/**
* [`TransactionType::Incoming`] for invoices, [`TransactionType::Outgoing`] for payments, [`None`] for both
*/
  transaction_type?: TransactionType;
/**
* If true, include unpaid invoices
*/
  unpaid?: boolean;
/**
* Ending timestamp in seconds since epoch
*/
  until?: bigint;
}
/**
*/
export class LiveEvent {
  free(): void;
/**
*/
  readonly currentPartecipants: number | undefined;
/**
*/
  readonly ends: number | undefined;
/**
*/
  readonly hashtags: (string)[];
/**
*/
  readonly host: LiveEventHost | undefined;
/**
*/
  readonly id: string;
/**
*/
  readonly image: Image | undefined;
/**
*/
  readonly participants: (User)[];
/**
*/
  readonly recording: string | undefined;
/**
*/
  readonly relays: (string)[];
/**
*/
  readonly speakers: (User)[];
/**
*/
  readonly starts: number | undefined;
/**
*/
  readonly status: LiveEventStatus | undefined;
/**
*/
  readonly streaming: string | undefined;
/**
*/
  readonly summary: string | undefined;
/**
*/
  readonly title: string | undefined;
/**
*/
  readonly totalPartecipants: number | undefined;
}
/**
*/
export class LiveEventHost {
  free(): void;
/**
*/
  readonly proof: string | undefined;
/**
*/
  readonly publicKey: PublicKey;
/**
*/
  readonly relayUrl: string | undefined;
}
/**
*/
export class LiveEventStatus {
  free(): void;
/**
* @returns {LiveEventStatus}
*/
  static planned(): LiveEventStatus;
/**
* @returns {LiveEventStatus}
*/
  static live(): LiveEventStatus;
/**
* @returns {LiveEventStatus}
*/
  static ended(): LiveEventStatus;
/**
* @param {string} string
* @returns {LiveEventStatus}
*/
  static custom(string: string): LiveEventStatus;
}
/**
*/
export class LogLevel {
  free(): void;
/**
* @returns {LogLevel}
*/
  static trace(): LogLevel;
/**
* @returns {LogLevel}
*/
  static debug(): LogLevel;
/**
* @returns {LogLevel}
*/
  static info(): LogLevel;
/**
* @returns {LogLevel}
*/
  static warn(): LogLevel;
/**
* @returns {LogLevel}
*/
  static error(): LogLevel;
}
/**
* Lookup Invoice Request Params
*/
export class LookupInvoiceRequestParams {
  free(): void;
/**
* Bolt11 invoice
*/
  invoice?: string;
/**
* Payment hash of invoice
*/
  payment_hash?: string;
}
/**
*/
export class LookupInvoiceResponseResult {
  free(): void;
/**
* Amount in millisatoshis
*/
  amount: bigint;
/**
* Creation timestamp in seconds since epoch
*/
  created_at: bigint;
/**
* Invoice's description
*/
  description?: string;
/**
* Invoice's description hash
*/
  description_hash?: string;
/**
* Expiration timestamp in seconds since epoch
*/
  expires_at: bigint;
/**
* Fees paid in millisatoshis
*/
  fees_paid: bigint;
/**
* Bolt11 invoice
*/
  invoice?: string;
/**
* Optional metadata about the payment
*/
  metadata: string;
/**
* Payment hash
*/
  payment_hash: string;
/**
* Payment preimage
*/
  preimage?: string;
/**
* Settled timestamp in seconds since epoch
*/
  settled_at?: bigint;
/**
* Transaction type
*/
  transaction_type?: TransactionType;
}
/**
* Make Invoice Request Params
*/
export class MakeInvoiceRequestParams {
  free(): void;
/**
* Amount in millisatoshis
*/
  amount: bigint;
/**
* Invoice description
*/
  description?: string;
/**
* Invoice description hash
*/
  description_hash?: string;
/**
* Invoice expiry in seconds
*/
  expiry?: bigint;
}
/**
*/
export class MakeInvoiceResponseResult {
  free(): void;
/**
* Bolt 11 invoice
*/
  invoice: string;
/**
* Invoice's payment hash
*/
  payment_hash: string;
}
/**
*/
export class Metadata {
  free(): void;
/**
*/
  constructor();
/**
* @param {string} json
* @returns {Metadata}
*/
  static fromJson(json: string): Metadata;
/**
* @returns {string}
*/
  asJson(): string;
/**
* @param {string} name
* @returns {Metadata}
*/
  name(name: string): Metadata;
/**
* @param {string} display_name
* @returns {Metadata}
*/
  displayName(display_name: string): Metadata;
/**
* @param {string} about
* @returns {Metadata}
*/
  about(about: string): Metadata;
/**
* @param {string} url
* @returns {Metadata}
*/
  website(url: string): Metadata;
/**
* @param {string} url
* @returns {Metadata}
*/
  picture(url: string): Metadata;
/**
* @param {string} url
* @returns {Metadata}
*/
  banner(url: string): Metadata;
/**
* @param {string} nip05
* @returns {Metadata}
*/
  nip05(nip05: string): Metadata;
/**
* @param {string} lud06
* @returns {Metadata}
*/
  lud06(lud06: string): Metadata;
/**
* @param {string} lud16
* @returns {Metadata}
*/
  lud16(lud16: string): Metadata;
}
/**
* Multi Pay Invoice Request Params
*/
export class MultiPayInvoiceRequestParams {
  free(): void;
/**
* Invoices to pay
*/
  invoices: (PayInvoiceRequestParams)[];
}
/**
* Multi Pay Keysend Request Params
*/
export class MultiPayKeysendRequestParams {
  free(): void;
/**
* Keysends
*/
  keysends: (PayKeysendRequestParams)[];
}
/**
* Things the user doesn't want to see in their feeds
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
export class MuteList {
  free(): void;
/**
*/
  event_ids: (EventId)[];
/**
*/
  hashtags: (string)[];
/**
*/
  public_keys: (PublicKey)[];
/**
*/
  words: (string)[];
}
/**
* Nostr Wallet Connect client
*/
export class NWC {
  free(): void;
/**
* Compose new `NWC` client
* @param {NostrWalletConnectURI} uri
*/
  constructor(uri: NostrWalletConnectURI);
/**
* Compose new `NWC` client with `NostrWalletConnectOptions`
* @param {NostrWalletConnectURI} uri
* @param {NostrWalletConnectOptions} opts
* @returns {Promise<NWC>}
*/
  static withOpts(uri: NostrWalletConnectURI, opts: NostrWalletConnectOptions): Promise<NWC>;
/**
* Pay invoice
* @param {string} invoice
* @returns {Promise<string>}
*/
  payInvoice(invoice: string): Promise<string>;
/**
* Pay keysend
* @param {PayKeysendRequestParams} params
* @returns {Promise<PayKeysendResponseResult>}
*/
  payKeysend(params: PayKeysendRequestParams): Promise<PayKeysendResponseResult>;
/**
* Create invoice
* @param {MakeInvoiceRequestParams} params
* @returns {Promise<MakeInvoiceResponseResult>}
*/
  makeInvoice(params: MakeInvoiceRequestParams): Promise<MakeInvoiceResponseResult>;
/**
* Lookup invoice
* @param {LookupInvoiceRequestParams} params
* @returns {Promise<LookupInvoiceResponseResult>}
*/
  lookupInvoice(params: LookupInvoiceRequestParams): Promise<LookupInvoiceResponseResult>;
/**
* List transactions
* @param {ListTransactionsRequestParams} params
* @returns {Promise<LookupInvoiceResponseResult[]>}
*/
  listTransactions(params: ListTransactionsRequestParams): Promise<LookupInvoiceResponseResult[]>;
/**
* Get balance
* @returns {Promise<bigint>}
*/
  getBalance(): Promise<bigint>;
/**
* Get info
* @returns {Promise<GetInfoResponseResult>}
*/
  getInfo(): Promise<GetInfoResponseResult>;
}
/**
*/
export class NegentropyOptions {
  free(): void;
/**
* New default options
*/
  constructor();
/**
* Timeout to check if negentropy it's supported (default: 10 secs)
* @param {Duration} timeout
* @returns {NegentropyOptions}
*/
  initialTimeout(timeout: Duration): NegentropyOptions;
/**
* Negentropy Sync direction (default: down)
* @param {NegentropyDirection} direction
* @returns {NegentropyOptions}
*/
  direction(direction: NegentropyDirection): NegentropyOptions;
}
/**
* NIP07 Signer for interaction with browser extensions (ex. Alby)
*
* <https://github.com/aljazceru/awesome-nostr#nip-07-browser-extensions>
*/
export class Nip07Signer {
  free(): void;
/**
*/
  constructor();
/**
* @returns {Promise<PublicKey>}
*/
  getPublicKey(): Promise<PublicKey>;
/**
* @param {UnsignedEvent} unsigned
* @returns {Promise<Event>}
*/
  signEvent(unsigned: UnsignedEvent): Promise<Event>;
/**
* @param {PublicKey} public_key
* @param {string} plaintext
* @returns {Promise<string>}
*/
  nip04Encrypt(public_key: PublicKey, plaintext: string): Promise<string>;
/**
* @param {PublicKey} public_key
* @param {string} ciphertext
* @returns {Promise<string>}
*/
  nip04Decrypt(public_key: PublicKey, ciphertext: string): Promise<string>;
/**
* @param {PublicKey} public_key
* @param {string} plaintext
* @returns {Promise<string>}
*/
  nip44Encrypt(public_key: PublicKey, plaintext: string): Promise<string>;
/**
* @param {PublicKey} public_key
* @param {string} ciphertext
* @returns {Promise<string>}
*/
  nip44Decrypt(public_key: PublicKey, ciphertext: string): Promise<string>;
}
/**
*/
export class Nip19Event {
  free(): void;
/**
* @param {EventId} event_id
* @param {PublicKey | undefined} author
* @param {(string)[]} relays
*/
  constructor(event_id: EventId, author: PublicKey | undefined, relays: (string)[]);
/**
* @param {string} bech32
* @returns {Nip19Event}
*/
  static fromBech32(bech32: string): Nip19Event;
/**
* @param {string} uri
* @returns {Nip19Event}
*/
  static fromNostrUri(uri: string): Nip19Event;
/**
* @returns {string}
*/
  toBech32(): string;
/**
* @returns {string}
*/
  toNostrUri(): string;
/**
* @returns {EventId}
*/
  eventId(): EventId;
/**
* @returns {PublicKey | undefined}
*/
  author(): PublicKey | undefined;
/**
* @returns {(string)[]}
*/
  relays(): (string)[];
}
/**
*/
export class Nip19Profile {
  free(): void;
/**
* New NIP19 profile
* @param {PublicKey} public_key
* @param {(string)[]} relays
*/
  constructor(public_key: PublicKey, relays: (string)[]);
/**
* @param {string} bech32
* @returns {Nip19Profile}
*/
  static fromBech32(bech32: string): Nip19Profile;
/**
* @param {string} uri
* @returns {Nip19Profile}
*/
  static fromNostrUri(uri: string): Nip19Profile;
/**
* @returns {string}
*/
  toBech32(): string;
/**
* @returns {string}
*/
  toNostrUri(): string;
/**
* @returns {PublicKey}
*/
  publicKey(): PublicKey;
/**
* @returns {(string)[]}
*/
  relays(): (string)[];
}
/**
*/
export class Nip46Signer {
  free(): void;
/**
* New NIP46 remote signer
* @param {NostrConnectURI} uri
* @param {Keys} app_keys
* @param {Duration} timeout
*/
  constructor(uri: NostrConnectURI, app_keys: Keys, timeout: Duration);
/**
* Get signer relays
* @returns {Promise<string[]>}
*/
  relays(): Promise<string[]>;
/**
* Get signer public key
* @returns {PublicKey}
*/
  signerPublicKey(): PublicKey;
/**
* Get Nostr Connect URI in **bunker** format.
* @returns {Promise<NostrConnectURI>}
*/
  nostrConnectUri(): Promise<NostrConnectURI>;
}
/**
*/
export class NostrConnectMetadata {
  free(): void;
/**
* New Nostr Connect Metadata
* @param {string} name
*/
  constructor(name: string);
/**
* URL of the website requesting the connection
* @param {string} url
* @returns {NostrConnectMetadata}
*/
  url(url: string): NostrConnectMetadata;
/**
* Description of the `App`
* @param {string} description
* @returns {NostrConnectMetadata}
*/
  description(description: string): NostrConnectMetadata;
/**
* List of URLs for icons of the `App`
* @param {(string)[]} icons
* @returns {NostrConnectMetadata}
*/
  icons(icons: (string)[]): NostrConnectMetadata;
/**
* Serialize as JSON string
* @returns {string}
*/
  as_json(): string;
}
/**
*/
export class NostrConnectURI {
  free(): void;
/**
* @param {string} uri
* @returns {NostrConnectURI}
*/
  static parse(uri: string): NostrConnectURI;
/**
* @returns {string}
*/
  asString(): string;
}
/**
* Nostr Database
*/
export class NostrDatabase {
  free(): void;
/**
* Open IndexedDB database
*
* If not exists, create it.
* @param {string} name
* @returns {Promise<NostrDatabase>}
*/
  static indexeddb(name: string): Promise<NostrDatabase>;
/**
* Save `Event` into store
*
* Return `true` if event was successfully saved into database.
*
* **This method assume that `Event` was already verified**
* @param {Event} event
* @returns {Promise<boolean>}
*/
  save_event(event: Event): Promise<boolean>;
/**
* Get list of relays that have seen the [`EventId`]
* @param {EventId} event_id
* @returns {Promise<string[] | undefined>}
*/
  eventSeenOnRelays(event_id: EventId): Promise<string[] | undefined>;
/**
* Get [`Event`] by [`EventId`]
* @param {EventId} event_id
* @returns {Promise<Event>}
*/
  eventById(event_id: EventId): Promise<Event>;
/**
* @param {(Filter)[]} filters
* @returns {Promise<bigint>}
*/
  count(filters: (Filter)[]): Promise<bigint>;
/**
* @param {(Filter)[]} filters
* @returns {Promise<Event[]>}
*/
  query(filters: (Filter)[]): Promise<Event[]>;
/**
* Wipe all data
* @returns {Promise<void>}
*/
  wipe(): Promise<void>;
/**
* @param {PublicKey} public_key
* @returns {Promise<Profile>}
*/
  profile(public_key: PublicKey): Promise<Profile>;
}
/**
*/
export class NostrLibrary {
  free(): void;
/**
*/
  constructor();
/**
* @returns {string | undefined}
*/
  gitHashVersion(): string | undefined;
}
/**
*/
export class NostrSigner {
  free(): void;
/**
* Private keys
* @param {Keys} keys
* @returns {NostrSigner}
*/
  static keys(keys: Keys): NostrSigner;
/**
* NIP07
* @param {Nip07Signer} signer
* @returns {NostrSigner}
*/
  static nip07(signer: Nip07Signer): NostrSigner;
/**
* NIP46
* @param {Nip46Signer} signer
* @returns {NostrSigner}
*/
  static nip46(signer: Nip46Signer): NostrSigner;
/**
* Get signer public key
* @returns {Promise<PublicKey>}
*/
  publicKey(): Promise<PublicKey>;
/**
* @param {EventBuilder} builder
* @returns {Promise<Event>}
*/
  signEventBuilder(builder: EventBuilder): Promise<Event>;
/**
* @param {UnsignedEvent} unsigned
* @returns {Promise<Event>}
*/
  signEvent(unsigned: UnsignedEvent): Promise<Event>;
/**
* @param {PublicKey} public_key
* @param {string} content
* @returns {Promise<string>}
*/
  nip04Encrypt(public_key: PublicKey, content: string): Promise<string>;
/**
* @param {PublicKey} public_key
* @param {string} encrypted_content
* @returns {Promise<string>}
*/
  nip04Decrypt(public_key: PublicKey, encrypted_content: string): Promise<string>;
/**
* @param {PublicKey} public_key
* @param {string} content
* @returns {Promise<string>}
*/
  nip44Encrypt(public_key: PublicKey, content: string): Promise<string>;
/**
* @param {PublicKey} public_key
* @param {string} content
* @returns {Promise<string>}
*/
  nip44Decrypt(public_key: PublicKey, content: string): Promise<string>;
}
/**
* NWC options
*/
export class NostrWalletConnectOptions {
  free(): void;
/**
* New default NWC options
*/
  constructor();
/**
* Set NWC requests timeout (default: 10 secs)
* @param {Duration} timeout
* @returns {NostrWalletConnectOptions}
*/
  timeout(timeout: Duration): NostrWalletConnectOptions;
}
/**
*/
export class NostrWalletConnectURI {
  free(): void;
/**
* Create new Nostr Wallet Connect URI
* @param {PublicKey} public_key
* @param {string} relay_url
* @param {SecretKey} random_secret_key
* @param {string | undefined} [lud16]
*/
  constructor(public_key: PublicKey, relay_url: string, random_secret_key: SecretKey, lud16?: string);
/**
* Parse
* @param {string} uri
* @returns {NostrWalletConnectURI}
*/
  static parse(uri: string): NostrWalletConnectURI;
/**
* App Pubkey
* @returns {PublicKey}
*/
  publicKey(): PublicKey;
/**
* URL of the relay of choice where the `App` is connected and the `Signer` must send and listen for messages.
* @returns {string}
*/
  relayUrl(): string;
/**
* 32-byte randomly generated hex encoded string
* @returns {SecretKey}
*/
  secret(): SecretKey;
/**
* A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured.
* @returns {string | undefined}
*/
  lud16(): string | undefined;
/**
* @returns {string}
*/
  asString(): string;
}
/**
* Nostr Zapper
*/
export class NostrZapper {
  free(): void;
/**
* Create new `WebLN` instance and compose `NostrZapper`
* @returns {Promise<NostrZapper>}
*/
  static webln(): Promise<NostrZapper>;
/**
* @param {NostrWalletConnectURI} uri
* @returns {Promise<NostrZapper>}
*/
  static nwc(uri: NostrWalletConnectURI): Promise<NostrZapper>;
}
/**
*/
export class Options {
  free(): void;
/**
*/
  constructor();
/**
* @param {boolean} wait
* @returns {Options}
*/
  waitForSend(wait: boolean): Options;
/**
* @param {boolean} wait
* @returns {Options}
*/
  waitForSubscription(wait: boolean): Options;
/**
* @param {number} difficulty
* @returns {Options}
*/
  difficulty(difficulty: number): Options;
/**
* Minimum POW difficulty for received events
* @param {number} difficulty
* @returns {Options}
*/
  minPow(difficulty: number): Options;
/**
* @param {number} req_filters_chunk_size
* @returns {Options}
*/
  reqFiltersChunkSize(req_filters_chunk_size: number): Options;
/**
* @param {boolean} skip
* @returns {Options}
*/
  skipDisconnectedRelays(skip: boolean): Options;
/**
* @param {Duration} timeout
* @returns {Options}
*/
  timeout(timeout: Duration): Options;
/**
* Connection timeout (default: None)
*
* If set to `None`, the client will try to connect to the relays without waiting.
* @param {Duration | undefined} [connection_timeout]
* @returns {Options}
*/
  connectionTimeout(connection_timeout?: Duration): Options;
/**
* @param {Duration | undefined} [send_timeout]
* @returns {Options}
*/
  sendTimeout(send_timeout?: Duration): Options;
/**
* Set custom relay limits
* @param {RelayLimits} limits
* @returns {Options}
*/
  relayLimits(limits: RelayLimits): Options;
}
/**
* Pay Invoice Request Params
*/
export class PayInvoiceRequestParams {
  free(): void;
/**
* Optional amount in millisatoshis
*/
  amount?: bigint;
/**
* Optional id
*/
  id?: string;
/**
* Request invoice
*/
  invoice: string;
}
/**
*/
export class PayInvoiceResponseResult {
  free(): void;
/**
* Response preimage
*/
  preimage: string;
}
/**
* Pay Invoice Request Params
*/
export class PayKeysendRequestParams {
  free(): void;
/**
* Amount in millisatoshis
*/
  amount: bigint;
/**
* Optional id
*/
  id?: string;
/**
* Optional preimage
*/
  preimage?: string;
/**
* Receiver's node id
*/
  pubkey: string;
/**
* Optional TLVs to be added to the keysend payment
*/
  tlv_records: (KeysendTLVRecord)[];
}
/**
*/
export class PayKeysendResponseResult {
  free(): void;
/**
* Response preimage
*/
  preimage: string;
}
/**
*/
export class ProductData {
  free(): void;
/**
* @param {string} id
* @param {string} stall_id
* @param {string} name
* @param {string} currency
*/
  constructor(id: string, stall_id: string, name: string, currency: string);
/**
*/
  readonly categories: (string)[] | undefined;
/**
*/
  readonly currency: string;
/**
*/
  readonly description: string | undefined;
/**
*/
  readonly id: string;
/**
*/
  readonly images: (string)[] | undefined;
/**
*/
  readonly name: string;
/**
*/
  readonly price: number;
/**
*/
  readonly quantity: number;
/**
*/
  readonly shipping: (ShippingCost)[];
/**
*/
  readonly specs: (string[])[] | undefined;
/**
*/
  readonly stallId: string;
}
/**
*/
export class Profile {
  free(): void;
/**
* Compose new profile
* @param {PublicKey} public_key
* @param {Metadata} metadata
*/
  constructor(public_key: PublicKey, metadata: Metadata);
/**
* Get profile public key
* @returns {PublicKey}
*/
  public_key(): PublicKey;
/**
* Get profile metadata
* @returns {Metadata}
*/
  metadata(): Metadata;
/**
* Get profile name
*
* Steps (go to next step if field is `None` or `empty`):
* * Check `display_name` field
* * Check `name` field
* * Return cutted public key (ex. `00000000:00000002`)
* @returns {string}
*/
  name(): string;
}
/**
*/
export class PublicKey {
  free(): void;
/**
* Try to parse public key from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
* @param {string} public_key
* @returns {PublicKey}
*/
  static parse(public_key: string): PublicKey;
/**
* @param {string} hex
* @returns {PublicKey}
*/
  static fromHex(hex: string): PublicKey;
/**
* @param {string} bech32
* @returns {PublicKey}
*/
  static fromBech32(bech32: string): PublicKey;
/**
* Get in hex format
* @returns {string}
*/
  toHex(): string;
/**
* Get in bech32 format
* @returns {string}
*/
  toBech32(): string;
}
/**
*/
export class Relay {
  free(): void;
/**
* Get relay url
* @returns {string}
*/
  url(): string;
/**
* @returns {Promise<RelayStatus>}
*/
  status(): Promise<RelayStatus>;
/**
* Get Relay Service Flags
* @returns {AtomicRelayServiceFlags}
*/
  flags(): AtomicRelayServiceFlags;
/**
* Check if relay is connected
* @returns {Promise<boolean>}
*/
  isConnected(): Promise<boolean>;
/**
* Get `RelayInformationDocument`
* @returns {Promise<RelayInformationDocument>}
*/
  document(): Promise<RelayInformationDocument>;
}
/**
*/
export class RelayInformationDocument {
  free(): void;
/**
*/
  constructor();
/**
* @param {string} url
* @returns {Promise<RelayInformationDocument>}
*/
  static get(url: string): Promise<RelayInformationDocument>;
/**
*/
  readonly contact: string | undefined;
/**
*/
  readonly description: string | undefined;
/**
*/
  readonly name: string | undefined;
/**
*/
  readonly pubkey: string | undefined;
/**
*/
  readonly software: string | undefined;
/**
*/
  readonly supported_nips: Uint16Array | undefined;
/**
*/
  readonly version: string | undefined;
}
/**
* Relay Limits
*/
export class RelayLimits {
  free(): void;
/**
* Construct with default limits
*/
  constructor();
/**
* Disable all limits
* @returns {RelayLimits}
*/
  static disable(): RelayLimits;
/**
* Maximum size of normalised JSON, in bytes (default: 5_250_000)
* @param {number | undefined} [max_size]
* @returns {RelayLimits}
*/
  messageMaxSize(max_size?: number): RelayLimits;
/**
* Maximum size of normalised JSON, in bytes (default: 70_000)
* @param {number | undefined} [max_size]
* @returns {RelayLimits}
*/
  eventMaxSize(max_size?: number): RelayLimits;
/**
* Maximum number of tags allowed (default: 2_000)
* @param {number | undefined} [max_num_tags]
* @returns {RelayLimits}
*/
  eventMaxNumTags(max_num_tags?: number): RelayLimits;
}
/**
*/
export class RelayListItem {
  free(): void;
/**
* @param {string} url
* @param {RelayMetadata | undefined} [metadata]
*/
  constructor(url: string, metadata?: RelayMetadata);
/**
*/
  metadata?: RelayMetadata;
/**
*/
  url: string;
}
/**
*/
export class RelayMessage {
  free(): void;
/**
* Create new `EVENT` message
* @param {string} subscription_id
* @param {Event} event
* @returns {RelayMessage}
*/
  static event(subscription_id: string, event: Event): RelayMessage;
/**
* Create new `NOTICE` message
* @param {string} message
* @returns {RelayMessage}
*/
  static notice(message: string): RelayMessage;
/**
* Create new `CLOSED` message
* @param {string} subscription_id
* @param {string} message
* @returns {RelayMessage}
*/
  static closed(subscription_id: string, message: string): RelayMessage;
/**
* Create new `EOSE` message
* @param {string} subscription_id
* @returns {RelayMessage}
*/
  static eose(subscription_id: string): RelayMessage;
/**
* Create new `OK` message
* @param {EventId} event_id
* @param {boolean} status
* @param {string} message
* @returns {RelayMessage}
*/
  static ok(event_id: EventId, status: boolean, message: string): RelayMessage;
/**
* Create new `AUTH` message
* @param {string} challenge
* @returns {RelayMessage}
*/
  static auth(challenge: string): RelayMessage;
/**
* Create new `EVENT` message
* @param {string} subscription_id
* @param {number} count
* @returns {RelayMessage}
*/
  static count(subscription_id: string, count: number): RelayMessage;
/**
* Deserialize `RelayMessage` from JSON string
*
* **This method NOT verify the event signature!**
* @param {string} json
* @returns {RelayMessage}
*/
  static fromJson(json: string): RelayMessage;
/**
* @returns {string}
*/
  asJson(): string;
}
/**
*/
export class RelayServiceFlags {
  free(): void;
/**
*/
  constructor();
/**
* Default flags: `READ`, `WRITE` and `PING`
* @returns {RelayServiceFlags}
*/
  static default(): RelayServiceFlags;
/**
* @returns {RelayServiceFlags}
*/
  static read(): RelayServiceFlags;
/**
* @returns {RelayServiceFlags}
*/
  static write(): RelayServiceFlags;
/**
* @returns {RelayServiceFlags}
*/
  static ping(): RelayServiceFlags;
/**
* Add `RelayServiceFlags` together.
* @param {RelayServiceFlags} other
* @returns {RelayServiceFlags}
*/
  add(other: RelayServiceFlags): RelayServiceFlags;
/**
* Remove `RelayServiceFlags` from this.
* @param {RelayServiceFlags} other
* @returns {RelayServiceFlags}
*/
  remove(other: RelayServiceFlags): RelayServiceFlags;
}
/**
*/
export class SecretKey {
  free(): void;
/**
* Try to parse secret key from `hex` or `bech32`
* @param {string} secret_key
* @returns {SecretKey}
*/
  static parse(secret_key: string): SecretKey;
/**
* @param {string} hex
* @returns {SecretKey}
*/
  static fromHex(hex: string): SecretKey;
/**
* @param {string} bech32
* @returns {SecretKey}
*/
  static fromBech32(bech32: string): SecretKey;
/**
* @returns {string}
*/
  toHex(): string;
/**
* @returns {string}
*/
  toBech32(): string;
/**
* Encrypt secret key
*
* By default `LOG_N` is set to `16` and `KeySecurity` to `Unknown`.
* To use custom values check `EncryptedSecretKey` constructor.
* @param {string} password
* @returns {EncryptedSecretKey}
*/
  encrypt(password: string): EncryptedSecretKey;
}
/**
*/
export class ShippingCost {
  free(): void;
/**
*/
  readonly cost: number;
/**
*/
  readonly id: string;
}
/**
*/
export class ShippingMethod {
  free(): void;
/**
* @param {string} id
* @param {number} cost
*/
  constructor(id: string, cost: number);
/**
* @returns {ShippingCost}
*/
  getShippingCost(): ShippingCost;
/**
*/
  readonly cost: number;
/**
*/
  readonly id: string;
/**
*/
  readonly name: string | undefined;
/**
*/
  readonly regions: (string)[];
}
/**
*/
export class SingleLetterTag {
  free(): void;
/**
* @param {Alphabet} character
* @returns {SingleLetterTag}
*/
  static lowercase(character: Alphabet): SingleLetterTag;
/**
* @param {Alphabet} character
* @returns {SingleLetterTag}
*/
  static uppercase(character: Alphabet): SingleLetterTag;
/**
* @returns {boolean}
*/
  isLowercase(): boolean;
/**
* @returns {boolean}
*/
  isUppercase(): boolean;
}
/**
*/
export class StallData {
  free(): void;
/**
* @param {string} id
* @param {string} name
* @param {string} currency
*/
  constructor(id: string, name: string, currency: string);
/**
*/
  readonly currency: string;
/**
*/
  readonly description: string | undefined;
/**
*/
  readonly id: string;
/**
*/
  readonly name: string;
/**
*/
  readonly shipping: (ShippingMethod)[];
}
/**
* Auto-closing subscribe options
*/
export class SubscribeAutoCloseOptions {
  free(): void;
/**
*/
  constructor();
/**
* Close subscription when `FilterOptions` is satisfied
* @param {FilterOptions} filter
* @returns {SubscribeAutoCloseOptions}
*/
  filter(filter: FilterOptions): SubscribeAutoCloseOptions;
/**
* Automatically close subscription after `Duration`
* @param {Duration | undefined} [timeout]
* @returns {SubscribeAutoCloseOptions}
*/
  timeout(timeout?: Duration): SubscribeAutoCloseOptions;
}
/**
* Subscribe options
*/
export class SubscribeOptions {
  free(): void;
/**
*/
  constructor();
/**
* Set auto-close conditions
* @param {SubscribeAutoCloseOptions | undefined} [opts]
* @returns {SubscribeOptions}
*/
  close_on(opts?: SubscribeAutoCloseOptions): SubscribeOptions;
}
/**
*/
export class SubscriptionId {
  free(): void;
/**
* @param {string} id
*/
  constructor(id: string);
/**
* Generate new random [`SubscriptionId`]
* @returns {SubscriptionId}
*/
  static generate(): SubscriptionId;
/**
* @returns {string}
*/
  get(): string;
}
/**
*/
export class Tag {
  free(): void;
/**
* @param {(string)[]} tag
* @returns {Tag}
*/
  static parse(tag: (string)[]): Tag;
/**
* Compose `["e", "<event-id>"]` tag
* @param {EventId} event_id
* @returns {Tag}
*/
  static event(event_id: EventId): Tag;
/**
* Compose `["p", "<public-key>"]` tag
* @param {PublicKey} public_key
* @returns {Tag}
*/
  static public_key(public_key: PublicKey): Tag;
/**
* Check if `Tag` is an event `reply`
* @returns {boolean}
*/
  is_reply(): boolean;
/**
* @returns {string}
*/
  kind(): string;
/**
* Get tag as vector of string
*
* Internally clone tag and convert it to `Vec<String>`. To avoid tag clone, use `toVec()`.
* @returns {(string)[]}
*/
  asVec(): (string)[];
/**
* Consume the tag and return vector of string
* @returns {(string)[]}
*/
  toVec(): (string)[];
}
/**
*/
export class Thumbnails {
  free(): void;
/**
* @param {string} url
* @param {ImageDimensions | undefined} [dimensions]
*/
  constructor(url: string, dimensions?: ImageDimensions);
/**
*/
  dimensions?: ImageDimensions;
/**
*/
  url: string;
}
/**
*/
export class Timestamp {
  free(): void;
/**
* Get UNIX timestamp (seconds)
* @returns {Timestamp}
*/
  static now(): Timestamp;
/**
* @param {number} secs
* @returns {Timestamp}
*/
  static fromSecs(secs: number): Timestamp;
/**
* Get timestamp as seconds
* @returns {number}
*/
  asSecs(): number;
/**
* Convert `Timestamp` to human datetime
* @returns {string}
*/
  toHumanDatetime(): string;
}
/**
*/
export class UnsignedEvent {
  free(): void;
/**
* @param {string} json
* @returns {UnsignedEvent}
*/
  static fromJson(json: string): UnsignedEvent;
/**
* @returns {string}
*/
  asJson(): string;
/**
* Sign an unsigned event
*
* Internally: calculate event ID (if not set), sign it, compose and verify event.
* @param {Keys} keys
* @returns {Event}
*/
  sign(keys: Keys): Event;
/**
* Add signature to unsigned event
*
* Internally verify the event.
* @param {string} sig
* @returns {Event}
*/
  addSignature(sig: string): Event;
/**
*/
  readonly content: string;
/**
*/
  readonly createdAt: Timestamp;
/**
*/
  readonly id: EventId | undefined;
/**
*/
  readonly kind: number;
/**
*/
  readonly pubkey: PublicKey;
/**
*/
  readonly tags: (Tag)[];
}
/**
* Unwrapped Gift Wrap
*
* <https://github.com/nostr-protocol/nips/blob/master/59.md>
*/
export class UnwrappedGift {
  free(): void;
/**
* Unwrap Gift Wrap event
*
* Internally verify the `seal` event
* @param {Keys} receiver_keys
* @param {Event} gift_wrap
* @returns {UnwrappedGift}
*/
  static fromGiftWrap(receiver_keys: Keys, gift_wrap: Event): UnwrappedGift;
/**
* Get rumor
*/
  readonly rumor: UnsignedEvent;
/**
* Get sender public key
*/
  readonly sender: PublicKey;
}
/**
*/
export class User {
  free(): void;
/**
* @param {PublicKey} public_key
* @param {string | undefined} [url]
*/
  constructor(public_key: PublicKey, url?: string);
/**
*/
  publicKey: PublicKey;
/**
*/
  url?: string;
}
/**
* Zap Details
*/
export class ZapDetails {
  free(): void;
/**
* Create new Zap Details
*
* **Note: `private` zaps are not currently supported here!**
* @param {ZapType} zap_type
*/
  constructor(zap_type: ZapType);
/**
* Add message
* @param {string} message
* @returns {ZapDetails}
*/
  message(message: string): ZapDetails;
}
/**
* Zap entity
*/
export class ZapEntity {
  free(): void;
/**
* @param {EventId} event_id
* @returns {ZapEntity}
*/
  static event(event_id: EventId): ZapEntity;
/**
* @param {PublicKey} public_key
* @returns {ZapEntity}
*/
  static publicKey(public_key: PublicKey): ZapEntity;
}
/**
*/
export class ZapRequestData {
  free(): void;
/**
* @param {PublicKey} public_key
* @param {(string)[]} relays
* @param {string} message
* @param {number | undefined} [amount]
* @param {string | undefined} [lnurl]
* @param {EventId | undefined} [event_id]
* @param {Coordinate | undefined} [event_coordinate]
*/
  constructor(public_key: PublicKey, relays: (string)[], message: string, amount?: number, lnurl?: string, event_id?: EventId, event_coordinate?: Coordinate);
/**
*/
  readonly amount: number | undefined;
/**
*/
  readonly eventCoordinate: Coordinate | undefined;
/**
*/
  readonly eventID: EventId | undefined;
/**
*/
  readonly lnurl: string | undefined;
/**
*/
  readonly message: string;
/**
*/
  readonly publicKey: PublicKey;
/**
*/
  readonly relays: (string)[];
}
/**
 * Load the WebAssembly module in the background, if it has not already been loaded.
 *
 * Returns a promise which will resolve once the other methods are ready.
 *
 * @returns {Promise<void>}
 */
 export function loadWasmAsync(): Promise<void>;

 export function loadWasmSync(): void;