/* tslint:disable */
/* eslint-disable */
/**
* Encrypt (NIP04)
* @param {SecretKey} sk
* @param {PublicKey} pk
* @param {string} text
* @returns {string}
*/
export function nip04Encrypt(sk: SecretKey, pk: PublicKey, text: string): string;
/**
* Decrypt (NIP04)
* @param {SecretKey} sk
* @param {PublicKey} pk
* @param {string} encrypted_content
* @returns {string}
*/
export function nip04Decrypt(sk: SecretKey, pk: PublicKey, encrypted_content: string): string;
/**
* Verify NIP05
* @param {PublicKey} public_key
* @param {string} nip05
* @returns {Promise<void>}
*/
export function verifyNip05(public_key: PublicKey, nip05: string): Promise<void>;
/**
* Create a NIP-26 delegation tag (including the signature).
* See also validate_delegation_tag().
* @param {Keys} delegator_keys
* @param {PublicKey} delegatee_pubkey
* @param {string} conditions
* @returns {string}
*/
export function createDelegationTag(delegator_keys: Keys, delegatee_pubkey: PublicKey, conditions: string): string;
/**
* Validate a NIP-26 delegation tag, check signature and conditions.
* @param {string} delegation_tag
* @param {PublicKey} delegatee_pubkey
* @param {number} event_kind
* @param {Timestamp} created_at
* @returns {boolean}
*/
export function validateDelegationTag(delegation_tag: string, delegatee_pubkey: PublicKey, event_kind: number, created_at: Timestamp): boolean;
/**
* Sign delegation (NIP26)
* @param {Keys} keys
* @param {PublicKey} delegatee_pk
* @param {string} conditions
* @returns {string}
*/
export function signDelegation(keys: Keys, delegatee_pk: PublicKey, conditions: string): string;
/**
* Verify delegation signature (NIP26)
* @param {PublicKey} delegator_public_key
* @param {PublicKey} delegatee_public_key
* @param {string} conditions
* @param {string} signature
* @returns {boolean}
*/
export function verifyDelegationSignature(delegator_public_key: PublicKey, delegatee_public_key: PublicKey, conditions: string, signature: string): boolean;
/**
* Encrypt (NIP44)
* @param {SecretKey} sk
* @param {PublicKey} pk
* @param {string} content
* @param {NIP44Version} version
* @returns {string}
*/
export function nip44Encrypt(sk: SecretKey, pk: PublicKey, content: string, version: NIP44Version): string;
/**
* Decrypt (NIP44)
* @param {SecretKey} sk
* @param {PublicKey} pk
* @param {string} payload
* @returns {string}
*/
export function nip44Decrypt(sk: SecretKey, pk: PublicKey, payload: string): string;
/**
* @param {Event} event
* @returns {(RelayListItem)[]}
*/
export function extractRelayList(event: Event): (RelayListItem)[];
/**
* Run some stuff when the Wasm module is instantiated.
*
* Right now, it does the following:
*
* * Redirect Rust panics to JavaScript console.
*/
export function start(): void;
/**
*/
export enum DataVendingMachineStatus {
  PaymentRequired = 0,
  Processing = 1,
  Error = 2,
  Success = 3,
  Partial = 4,
}
/**
* Encrypted Secret Key version (NIP49)
*/
export enum EncryptedSecretKeyVersion {
  V2 = 0,
}
/**
* NIP47 Response Error codes
*/
export enum Nip47ErrorCode {
/**
*  The client is sending commands too fast.
*/
  RateLimited = 0,
/**
* The command is not known of is intentionally not implemented
*/
  NotImplemented = 1,
/**
* The wallet does not have enough funds to cover a fee reserve or the payment amount
*/
  InsufficientBalance = 2,
/**
* The payment failed. This may be due to a timeout, exhausting all routes, insufficient capacity or similar.
*/
  PaymentFailed = 3,
/**
* The invoice could not be found by the given parameters.
*/
  NotFound = 4,
/**
* The wallet has exceeded its spending quota
*/
  QuotaExceeded = 5,
/**
* This public key is not allowed to do this operation
*/
  Restricted = 6,
/**
* This public key has no wallet connected
*/
  Unauthorized = 7,
/**
* An internal error
*/
  Internal = 8,
/**
* Other error
*/
  Other = 9,
}
/**
* Transaction Type
*/
export enum TransactionType {
/**
* Incoming payments
*/
  Incoming = 0,
/**
* Outgoing payments
*/
  Outgoing = 1,
}
/**
* Key security
*/
export enum KeySecurity {
/**
* The key has been known to have been handled insecurely (stored unencrypted, cut and paste unencrypted, etc)
*/
  Weak = 0,
/**
* The key has NOT been known to have been handled insecurely (stored encrypted, cut and paste encrypted, etc)
*/
  Medium = 1,
/**
* The client does not track this data
*/
  Unknown = 2,
}
/**
*/
export enum ZapType {
/**
* Public
*/
  Public = 0,
/**
* Private
*/
  Private = 1,
/**
* Anonymous
*/
  Anonymous = 2,
}
/**
*/
export enum HttpMethod {
  GET = 0,
  POST = 1,
  PUT = 2,
  PATCH = 3,
}
/**
*/
export enum Alphabet {
  A = 0,
  B = 1,
  C = 2,
  D = 3,
  E = 4,
  F = 5,
  G = 6,
  H = 7,
  I = 8,
  J = 9,
  K = 10,
  L = 11,
  M = 12,
  N = 13,
  O = 14,
  P = 15,
  Q = 16,
  R = 17,
  S = 18,
  T = 19,
  U = 20,
  V = 21,
  W = 22,
  X = 23,
  Y = 24,
  Z = 25,
}
/**
*/
export enum NIP44Version {
/**
* V1 - Deprecated
*/
  Deprecated = 1,
  V2 = 2,
}
/**
*/
export enum RelayMetadata {
  Read = 0,
  Write = 1,
}
/**
*/
export class Aes256Gcm {
  free(): void;
/**
* @param {string} key
* @param {string} iv
*/
  constructor(key: string, iv: string);
/**
*/
  iv: string;
/**
*/
  key: string;
}
/**
* Groups of articles picked by users as interesting and/or belonging to the same category
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
export class ArticlesCuration {
  free(): void;
/**
*/
  coordinate: (Coordinate)[];
/**
*/
  event_ids: (EventId)[];
}
/**
* Uncategorized, "global" list of things a user wants to save
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
export class Bookmarks {
  free(): void;
/**
*/
  coordinate: (Coordinate)[];
/**
*/
  event_ids: (EventId)[];
/**
*/
  hashtags: (string)[];
/**
*/
  urls: (string)[];
}
/**
*/
export class ClientMessage {
  free(): void;
/**
* Create new `EVENT` message
* @param {Event} event
* @returns {ClientMessage}
*/
  static event(event: Event): ClientMessage;
/**
* Create new `REQ` message
* @param {string} subscription_id
* @param {(Filter)[]} filters
* @returns {ClientMessage}
*/
  static req(subscription_id: string, filters: (Filter)[]): ClientMessage;
/**
* Create new `COUNT` message
* @param {string} subscription_id
* @param {(Filter)[]} filters
* @returns {ClientMessage}
*/
  static count(subscription_id: string, filters: (Filter)[]): ClientMessage;
/**
* Create new `CLOSE` message
* @param {string} subscription_id
* @returns {ClientMessage}
*/
  static close(subscription_id: string): ClientMessage;
/**
* Create new `AUTH` message
* @param {Event} event
* @returns {ClientMessage}
*/
  static auth(event: Event): ClientMessage;
/**
* Deserialize `ClientMessage` from JSON string
*
* **This method NOT verify the event signature!**
* @param {string} json
* @returns {ClientMessage}
*/
  static fromJson(json: string): ClientMessage;
/**
* @returns {string}
*/
  asJson(): string;
}
/**
*/
export class Contact {
  free(): void;
/**
* @param {PublicKey} public_key
* @param {string | undefined} [relay_url]
* @param {string | undefined} [alias]
*/
  constructor(public_key: PublicKey, relay_url?: string, alias?: string);
}
/**
*/
export class Coordinate {
  free(): void;
/**
* @param {number} kind
* @param {PublicKey} public_key
* @param {string | undefined} [identifier]
* @param {(string)[] | undefined} [relays]
*/
  constructor(kind: number, public_key: PublicKey, identifier?: string, relays?: (string)[]);
/**
*/
  readonly identifier: string;
/**
*/
  readonly kind: number;
/**
*/
  readonly publicKey: PublicKey;
/**
*/
  readonly relays: (string)[];
}
/**
* Emoji
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
export class EmojiInfo {
  free(): void;
/**
*/
  shortcode: string;
/**
*/
  url: string;
}
/**
* User preferred emojis and pointers to emoji sets
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
export class Emojis {
  free(): void;
/**
*/
  coordinate: (Coordinate)[];
/**
*/
  emojis: (EmojiInfo)[];
}
/**
* Encrypted Secret Key
*/
export class EncryptedSecretKey {
  free(): void;
/**
* Encrypt secret key
* @param {SecretKey} secret_key
* @param {string} password
* @param {number} log_n
* @param {KeySecurity} key_security
*/
  constructor(secret_key: SecretKey, password: string, log_n: number, key_security: KeySecurity);
/**
* @param {string} bech32
* @returns {EncryptedSecretKey}
*/
  static fromBech32(bech32: string): EncryptedSecretKey;
/**
* Get encrypted secret key version
* @returns {EncryptedSecretKeyVersion}
*/
  version(): EncryptedSecretKeyVersion;
/**
* Get encrypted secret key security
* @returns {KeySecurity}
*/
  keySecurity(): KeySecurity;
/**
* Consume `EncryptedSecretKey` and return `SecretKey`
* @param {string} password
* @returns {SecretKey}
*/
  toSecretKey(password: string): SecretKey;
/**
* Decrypt to `SecretKey`
* @param {string} password
* @returns {SecretKey}
*/
  asSecretKey(password: string): SecretKey;
/**
* @returns {string}
*/
  toBech32(): string;
}
/**
*/
export class Event {
  free(): void;
/**
* @returns {boolean}
*/
  verify(): boolean;
/**
* @param {string} json
* @returns {Event}
*/
  static fromJson(json: string): Event;
/**
* @returns {string}
*/
  asJson(): string;
/**
* Get event author (`pubkey` field)
*/
  readonly author: PublicKey;
/**
*/
  readonly content: string;
/**
*/
  readonly createdAt: Timestamp;
/**
*/
  readonly id: EventId;
/**
*/
  readonly kind: number;
/**
*/
  readonly signature: string;
/**
*/
  readonly tags: (Tag)[];
}
/**
*/
export class EventBuilder {
  free(): void;
/**
* @param {number} kind
* @param {string} content
* @param {(Tag)[]} tags
*/
  constructor(kind: number, content: string, tags: (Tag)[]);
/**
* Set a custom `created_at` UNIX timestamp
* @param {Timestamp} created_at
* @returns {EventBuilder}
*/
  customCreatedAt(created_at: Timestamp): EventBuilder;
/**
* Build `Event`
*
* **This method consume the builder, so it will no longer be usable!**
* @param {Keys} keys
* @returns {Event}
*/
  toEvent(keys: Keys): Event;
/**
* Build `UnsignedEvent`
*
* **This method consume the builder, so it will no longer be usable!**
* @param {PublicKey} public_key
* @returns {UnsignedEvent}
*/
  toUnsignedEvent(public_key: PublicKey): UnsignedEvent;
/**
* Build POW `Event`
*
* **This method consume the builder, so it will no longer be usable!**
* @param {Keys} keys
* @param {number} difficulty
* @returns {Event}
*/
  toPowEvent(keys: Keys, difficulty: number): Event;
/**
* Build Unisgned POW Event
*
* **This method consume the builder, so it will no longer be usable!**
* @param {PublicKey} public_key
* @param {number} difficulty
* @returns {UnsignedEvent}
*/
  toUnsignedPowEvent(public_key: PublicKey, difficulty: number): UnsignedEvent;
/**
* @param {Metadata} metadata
* @returns {EventBuilder}
*/
  static metadata(metadata: Metadata): EventBuilder;
/**
* @param {(RelayListItem)[]} relays
* @returns {EventBuilder}
*/
  static relayList(relays: (RelayListItem)[]): EventBuilder;
/**
* @param {string} content
* @param {(Tag)[]} tags
* @returns {EventBuilder}
*/
  static textNote(content: string, tags: (Tag)[]): EventBuilder;
/**
* Text note reply
*
* If no `root` is passed, the `rely_to` will be used for root `e` tag.
*
* <https://github.com/nostr-protocol/nips/blob/master/10.md>
* @param {string} content
* @param {Event} reply_to
* @param {Event | undefined} [root]
* @param {string | undefined} [relay_url]
* @returns {EventBuilder}
*/
  static textNoteReply(content: string, reply_to: Event, root?: Event, relay_url?: string): EventBuilder;
/**
* @param {string} content
* @param {(Tag)[]} tags
* @returns {EventBuilder}
*/
  static longFormTextNote(content: string, tags: (Tag)[]): EventBuilder;
/**
* @param {(Contact)[]} list
* @returns {EventBuilder}
*/
  static contactList(list: (Contact)[]): EventBuilder;
/**
* @param {Keys} sender_keys
* @param {PublicKey} receiver_pubkey
* @param {string} content
* @param {EventId | undefined} [reply_to]
* @returns {EventBuilder}
*/
  static encryptedDirectMsg(sender_keys: Keys, receiver_pubkey: PublicKey, content: string, reply_to?: EventId): EventBuilder;
/**
* Repost
* @param {Event} event
* @param {string | undefined} [relay_url]
* @returns {EventBuilder}
*/
  static repost(event: Event, relay_url?: string): EventBuilder;
/**
* @param {(EventId)[]} ids
* @param {string | undefined} [reason]
* @returns {EventBuilder}
*/
  static delete(ids: (EventId)[], reason?: string): EventBuilder;
/**
* Add reaction (like/upvote, dislike/downvote or emoji) to an event
* @param {Event} event
* @param {string} reaction
* @returns {EventBuilder}
*/
  static reaction(event: Event, reaction: string): EventBuilder;
/**
* Add reaction (like/upvote, dislike/downvote or emoji) to an event
* @param {EventId} event_id
* @param {PublicKey} public_key
* @param {number} kind
* @param {string} reaction
* @returns {EventBuilder}
*/
  static reactionExtended(event_id: EventId, public_key: PublicKey, kind: number, reaction: string): EventBuilder;
/**
* @param {Metadata} metadata
* @returns {EventBuilder}
*/
  static channel(metadata: Metadata): EventBuilder;
/**
* @param {EventId} channel_id
* @param {string | undefined} relay_url
* @param {Metadata} metadata
* @returns {EventBuilder}
*/
  static channelMetadata(channel_id: EventId, relay_url: string | undefined, metadata: Metadata): EventBuilder;
/**
* @param {EventId} channel_id
* @param {string} relay_url
* @param {string} content
* @returns {EventBuilder}
*/
  static channelMsg(channel_id: EventId, relay_url: string, content: string): EventBuilder;
/**
* @param {EventId} message_id
* @param {string | undefined} [reason]
* @returns {EventBuilder}
*/
  static hideChannelMsg(message_id: EventId, reason?: string): EventBuilder;
/**
* @param {PublicKey} pubkey
* @param {string | undefined} [reason]
* @returns {EventBuilder}
*/
  static muteChannelUser(pubkey: PublicKey, reason?: string): EventBuilder;
/**
* @param {string} challenge
* @param {string} relay
* @returns {EventBuilder}
*/
  static auth(challenge: string, relay: string): EventBuilder;
/**
* @param {LiveEvent} live_event
* @returns {EventBuilder}
*/
  static liveEvent(live_event: LiveEvent): EventBuilder;
/**
* @param {string} live_event_id
* @param {PublicKey} live_event_host
* @param {string} content
* @param {string | undefined} relay_url
* @param {(Tag)[]} tags
* @returns {EventBuilder}
*/
  static liveEventMsg(live_event_id: string, live_event_host: PublicKey, content: string, relay_url: string | undefined, tags: (Tag)[]): EventBuilder;
/**
* @param {(Tag)[]} tags
* @param {string} content
* @returns {EventBuilder}
*/
  static report(tags: (Tag)[], content: string): EventBuilder;
/**
* @param {ZapRequestData} data
* @returns {EventBuilder}
*/
  static publicZapRequest(data: ZapRequestData): EventBuilder;
/**
* @param {string} bolt11
* @param {string | undefined} preimage
* @param {Event} zap_request
* @returns {EventBuilder}
*/
  static zapReceipt(bolt11: string, preimage: string | undefined, zap_request: Event): EventBuilder;
/**
* @param {string} badge_id
* @param {string | undefined} name
* @param {string | undefined} description
* @param {string | undefined} image
* @param {ImageDimensions | undefined} image_dimensions
* @param {(Thumbnails)[]} thumbnails
* @returns {EventBuilder}
*/
  static defineBadge(badge_id: string, name: string | undefined, description: string | undefined, image: string | undefined, image_dimensions: ImageDimensions | undefined, thumbnails: (Thumbnails)[]): EventBuilder;
/**
* @param {Event} badge_definition
* @param {(Tag)[]} awarded_pubkeys
* @returns {EventBuilder}
*/
  static awardBadge(badge_definition: Event, awarded_pubkeys: (Tag)[]): EventBuilder;
/**
* @param {(Event)[]} badge_definitions
* @param {(Event)[]} badge_awards
* @param {PublicKey} pubkey_awarded
* @returns {EventBuilder}
*/
  static profileBadges(badge_definitions: (Event)[], badge_awards: (Event)[], pubkey_awarded: PublicKey): EventBuilder;
/**
* @param {number} kind
* @param {(Tag)[]} tags
* @returns {EventBuilder}
*/
  static jobRequest(kind: number, tags: (Tag)[]): EventBuilder;
/**
* @param {Event} job_request
* @param {number} amount_millisats
* @param {string | undefined} [bolt11]
* @returns {EventBuilder}
*/
  static jobResult(job_request: Event, amount_millisats: number, bolt11?: string): EventBuilder;
/**
* @param {Event} job_request
* @param {DataVendingMachineStatus} status
* @param {string | undefined} extra_info
* @param {bigint} amount_millisats
* @param {string | undefined} [bolt11]
* @param {string | undefined} [payload]
* @returns {EventBuilder}
*/
  static jobFeedback(job_request: Event, status: DataVendingMachineStatus, extra_info: string | undefined, amount_millisats: bigint, bolt11?: string, payload?: string): EventBuilder;
/**
* @param {string} description
* @param {FileMetadata} metadata
* @returns {EventBuilder}
*/
  static fileMetadata(description: string, metadata: FileMetadata): EventBuilder;
/**
* @param {HttpData} data
* @returns {EventBuilder}
*/
  static httpAuth(data: HttpData): EventBuilder;
/**
* @param {StallData} data
* @returns {EventBuilder}
*/
  static stallData(data: StallData): EventBuilder;
/**
* @param {ProductData} data
* @returns {EventBuilder}
*/
  static productData(data: ProductData): EventBuilder;
/**
* Gift Wrap from seal
*
* <https://github.com/nostr-protocol/nips/blob/master/59.md>
* @param {PublicKey} receiver
* @param {Event} seal
* @param {Timestamp | undefined} [expiration]
* @returns {Event}
*/
  static giftWrapFromSeal(receiver: PublicKey, seal: Event, expiration?: Timestamp): Event;
/**
* Gift Wrap
*
* <https://github.com/nostr-protocol/nips/blob/master/59.md>
* @param {Keys} sender_keys
* @param {PublicKey} receiver
* @param {UnsignedEvent} rumor
* @param {Timestamp | undefined} [expiration]
* @returns {Event}
*/
  static giftWrap(sender_keys: Keys, receiver: PublicKey, rumor: UnsignedEvent, expiration?: Timestamp): Event;
/**
* GiftWrapped Sealed Direct message
* @param {PublicKey} receiver
* @param {string} message
* @returns {EventBuilder}
*/
  static sealedDirect(receiver: PublicKey, message: string): EventBuilder;
/**
* Mute list
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {MuteList} list
* @returns {EventBuilder}
*/
  static muteList(list: MuteList): EventBuilder;
/**
* Pinned notes
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(EventId)[]} ids
* @returns {EventBuilder}
*/
  static pinnedNotes(ids: (EventId)[]): EventBuilder;
/**
* Bookmarks
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {Bookmarks} list
* @returns {EventBuilder}
*/
  static bookmarks(list: Bookmarks): EventBuilder;
/**
* Communities
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(Coordinate)[]} communities
* @returns {EventBuilder}
*/
  static communities(communities: (Coordinate)[]): EventBuilder;
/**
* Public chats
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(EventId)[]} chat
* @returns {EventBuilder}
*/
  static publicChats(chat: (EventId)[]): EventBuilder;
/**
* Blocked relays
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(string)[]} relays
* @returns {EventBuilder}
*/
  static blockedRelays(relays: (string)[]): EventBuilder;
/**
* Search relays
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(string)[]} relays
* @returns {EventBuilder}
*/
  static searchRelays(relays: (string)[]): EventBuilder;
/**
* Interests
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {Interests} list
* @returns {EventBuilder}
*/
  static interests(list: Interests): EventBuilder;
/**
* Emojis
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {Emojis} list
* @returns {EventBuilder}
*/
  static emojis(list: Emojis): EventBuilder;
/**
* Follow sets
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(PublicKey)[]} public_keys
* @returns {EventBuilder}
*/
  static followSets(public_keys: (PublicKey)[]): EventBuilder;
/**
* Relay sets
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(string)[]} relays
* @returns {EventBuilder}
*/
  static relaySets(relays: (string)[]): EventBuilder;
/**
* Bookmark sets
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {Bookmarks} list
* @returns {EventBuilder}
*/
  static bookmarksSets(list: Bookmarks): EventBuilder;
/**
* Article Curation sets
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {ArticlesCuration} list
* @returns {EventBuilder}
*/
  static articlesCurationSets(list: ArticlesCuration): EventBuilder;
/**
* Videos Curation sets
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(Coordinate)[]} video
* @returns {EventBuilder}
*/
  static videosCurationSets(video: (Coordinate)[]): EventBuilder;
/**
* Emoji sets
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
* @param {(EmojiInfo)[]} emoji
* @returns {EventBuilder}
*/
  static emojiSets(emoji: (EmojiInfo)[]): EventBuilder;
/**
* Label
*
* <https://github.com/nostr-protocol/nips/blob/master/32.md>
* @param {string} label_namespace
* @param {(string)[]} labels
* @returns {EventBuilder}
*/
  static label(label_namespace: string, labels: (string)[]): EventBuilder;
}
/**
*/
export class EventId {
  free(): void;
/**
* @param {PublicKey} pubkey
* @param {Timestamp} created_at
* @param {number} kind
* @param {(Tag)[]} tags
* @param {string} content
*/
  constructor(pubkey: PublicKey, created_at: Timestamp, kind: number, tags: (Tag)[], content: string);
/**
* Try to parse event ID from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
* @param {string} id
* @returns {EventId}
*/
  static parse(id: string): EventId;
/**
* @param {Uint8Array} bytes
* @returns {EventId}
*/
  static fromSlice(bytes: Uint8Array): EventId;
/**
* @param {string} hex
* @returns {EventId}
*/
  static fromHex(hex: string): EventId;
/**
* @param {string} bech32
* @returns {EventId}
*/
  static fromBech32(bech32: string): EventId;
/**
* @returns {Uint8Array}
*/
  asBytes(): Uint8Array;
/**
* @returns {string}
*/
  toHex(): string;
/**
* @returns {string}
*/
  toBech32(): string;
}
/**
*/
export class FileMetadata {
  free(): void;
/**
* @param {string} url
* @param {string} mime_type
* @param {string} hash
*/
  constructor(url: string, mime_type: string, hash: string);
/**
*/
  readonly aes256Gcm: Aes256Gcm | undefined;
/**
*/
  readonly blurhash: string | undefined;
/**
*/
  readonly dim: ImageDimensions | undefined;
/**
*/
  readonly hash: string;
/**
*/
  readonly magnet: string | undefined;
/**
*/
  readonly mimeType: string;
/**
*/
  readonly size: number | undefined;
/**
*/
  readonly urls: string;
}
/**
*/
export class Filter {
  free(): void;
/**
*/
  constructor();
/**
* @param {string} json
* @returns {Filter}
*/
  static fromJson(json: string): Filter;
/**
* @returns {string}
*/
  asJson(): string;
/**
* Set subscription id
* @param {EventId} id
* @returns {Filter}
*/
  id(id: EventId): Filter;
/**
* Set subscription ids
* @param {(EventId)[]} ids
* @returns {Filter}
*/
  ids(ids: (EventId)[]): Filter;
/**
* Set author
* @param {PublicKey} author
* @returns {Filter}
*/
  author(author: PublicKey): Filter;
/**
* Set authors
* @param {(PublicKey)[]} authors
* @returns {Filter}
*/
  authors(authors: (PublicKey)[]): Filter;
/**
* Set kind
* @param {number} kind
* @returns {Filter}
*/
  kind(kind: number): Filter;
/**
* Set kinds
* @param {Float64Array} kinds
* @returns {Filter}
*/
  kinds(kinds: Float64Array): Filter;
/**
* Set event
* @param {EventId} id
* @returns {Filter}
*/
  event(id: EventId): Filter;
/**
* Set events
* @param {(EventId)[]} ids
* @returns {Filter}
*/
  events(ids: (EventId)[]): Filter;
/**
* Set pubkey
* @param {PublicKey} pubkey
* @returns {Filter}
*/
  pubkey(pubkey: PublicKey): Filter;
/**
* Set pubkeys
* @param {(PublicKey)[]} pubkeys
* @returns {Filter}
*/
  pubkeys(pubkeys: (PublicKey)[]): Filter;
/**
* Set hashtag
*
* <https://github.com/nostr-protocol/nips/blob/master/12.md>
* @param {string} hashtag
* @returns {Filter}
*/
  hashtag(hashtag: string): Filter;
/**
* Set hashtags
*
* <https://github.com/nostr-protocol/nips/blob/master/12.md>
* @param {(string)[]} hashtags
* @returns {Filter}
*/
  hashtags(hashtags: (string)[]): Filter;
/**
* Set reference
*
* <https://github.com/nostr-protocol/nips/blob/master/12.md>
* @param {string} v
* @returns {Filter}
*/
  reference(v: string): Filter;
/**
* Set references
*
* <https://github.com/nostr-protocol/nips/blob/master/12.md>
* @param {(string)[]} v
* @returns {Filter}
*/
  references(v: (string)[]): Filter;
/**
* Set search field
* @param {string} value
* @returns {Filter}
*/
  search(value: string): Filter;
/**
* Set since unix timestamp
* @param {Timestamp} since
* @returns {Filter}
*/
  since(since: Timestamp): Filter;
/**
* Set until unix timestamp
* @param {Timestamp} until
* @returns {Filter}
*/
  until(until: Timestamp): Filter;
/**
* Set limit
* @param {number} limit
* @returns {Filter}
*/
  limit(limit: number): Filter;
/**
* @param {SingleLetterTag} tag
* @param {(string)[]} values
* @returns {Filter}
*/
  customTag(tag: SingleLetterTag, values: (string)[]): Filter;
/**
* @param {SingleLetterTag} tag
* @param {(string)[]} values
* @returns {Filter}
*/
  removeCustomTag(tag: SingleLetterTag, values: (string)[]): Filter;
/**
* Determine if `Filter` match given `Event`.
*
* The `search` filed is not supported yet!
* @param {Event} event
* @returns {boolean}
*/
  matchEvent(event: Event): boolean;
}
/**
*/
export class GetBalanceResponseResult {
  free(): void;
/**
* Balance amount in msats
*/
  balance: bigint;
}
/**
*/
export class GetInfoResponseResult {
  free(): void;
/**
* The alias of the lightning node
*/
  alias: string;
/**
* Most Recent Block Hash
*/
  block_hash: string;
/**
* Current block height
*/
  block_height: number;
/**
* The color of the current node in hex code format
*/
  color: string;
/**
* Available methods for this connection
*/
  methods: (string)[];
/**
* Active network
*/
  network: string;
/**
* Lightning Node's public key
*/
  pubkey: string;
}
/**
*/
export class HttpData {
  free(): void;
/**
* @param {string} url
* @param {HttpMethod} method
*/
  constructor(url: string, method: HttpMethod);
/**
*/
  readonly method: HttpMethod;
/**
*/
  readonly payload: string | undefined;
/**
*/
  readonly urls: string;
}
/**
*/
export class Image {
  free(): void;
/**
* @param {string} url
* @param {ImageDimensions | undefined} [dimensions]
*/
  constructor(url: string, dimensions?: ImageDimensions);
/**
*/
  dimensions?: ImageDimensions;
/**
*/
  url: string;
}
/**
*/
export class ImageDimensions {
  free(): void;
/**
*/
  height: bigint;
/**
*/
  width: bigint;
}
/**
* Topics a user may be interested in and pointers
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
export class Interests {
  free(): void;
/**
*/
  coordinate: (Coordinate)[];
/**
*/
  hashtags: (string)[];
}
/**
*/
export class Keys {
  free(): void;
/**
* Initialize from secret key.
* @param {SecretKey} secret_key
*/
  constructor(secret_key: SecretKey);
/**
* Try to parse keys from **secret key** `hex` or `bech32`
* @param {string} secret_key
* @returns {Keys}
*/
  static parse(secret_key: string): Keys;
/**
* Initialize with public key only (no secret key).
* @param {PublicKey} public_key
* @returns {Keys}
*/
  static fromPublicKey(public_key: PublicKey): Keys;
/**
* Generate new random keys
* @returns {Keys}
*/
  static generate(): Keys;
/**
* @param {(string)[]} prefixes
* @param {boolean} bech32
* @param {number} num_cores
* @returns {Keys}
*/
  static vanity(prefixes: (string)[], bech32: boolean, num_cores: number): Keys;
/**
* Derive keys from BIP-39 mnemonics (ENGLISH wordlist).
*
* <https://github.com/nostr-protocol/nips/blob/master/06.md>
* @param {string} mnemonic
* @param {string | undefined} [passphrase]
* @param {number | undefined} [account]
* @param {number | undefined} [typ]
* @param {number | undefined} [index]
* @returns {Keys}
*/
  static fromMnemonic(mnemonic: string, passphrase?: string, account?: number, typ?: number, index?: number): Keys;
/**
* Get public key
*/
  readonly publicKey: PublicKey;
/**
* Get secret key
*/
  readonly secretKey: SecretKey;
}
/**
* TLVs to be added to the keysend payment
*/
export class KeysendTLVRecord {
  free(): void;
/**
* TLV type
*/
  tlv_type: bigint;
/**
* TLV value
*/
  value: string;
}
/**
* List Invoice Request Params
*/
export class ListTransactionsRequestParams {
  free(): void;
/**
* Starting timestamp in seconds since epoch
*/
  from?: bigint;
/**
* Number of invoices to return
*/
  limit?: bigint;
/**
* Offset of the first invoice to return
*/
  offset?: bigint;
/**
* [`TransactionType::Incoming`] for invoices, [`TransactionType::Outgoing`] for payments, [`None`] for both
*/
  transaction_type?: TransactionType;
/**
* If true, include unpaid invoices
*/
  unpaid?: boolean;
/**
* Ending timestamp in seconds since epoch
*/
  until?: bigint;
}
/**
*/
export class LiveEvent {
  free(): void;
/**
*/
  readonly currentPartecipants: number | undefined;
/**
*/
  readonly ends: number | undefined;
/**
*/
  readonly hashtags: (string)[];
/**
*/
  readonly host: LiveEventHost | undefined;
/**
*/
  readonly id: string;
/**
*/
  readonly image: Image | undefined;
/**
*/
  readonly participants: (User)[];
/**
*/
  readonly recording: string | undefined;
/**
*/
  readonly relays: (string)[];
/**
*/
  readonly speakers: (User)[];
/**
*/
  readonly starts: number | undefined;
/**
*/
  readonly status: LiveEventStatus | undefined;
/**
*/
  readonly streaming: string | undefined;
/**
*/
  readonly summary: string | undefined;
/**
*/
  readonly title: string | undefined;
/**
*/
  readonly totalPartecipants: number | undefined;
}
/**
*/
export class LiveEventHost {
  free(): void;
/**
*/
  readonly proof: string | undefined;
/**
*/
  readonly publicKey: PublicKey;
/**
*/
  readonly relayUrl: string | undefined;
}
/**
*/
export class LiveEventStatus {
  free(): void;
/**
* @returns {LiveEventStatus}
*/
  static planned(): LiveEventStatus;
/**
* @returns {LiveEventStatus}
*/
  static live(): LiveEventStatus;
/**
* @returns {LiveEventStatus}
*/
  static ended(): LiveEventStatus;
/**
* @param {string} string
* @returns {LiveEventStatus}
*/
  static custom(string: string): LiveEventStatus;
}
/**
* Lookup Invoice Request Params
*/
export class LookupInvoiceRequestParams {
  free(): void;
/**
* Bolt11 invoice
*/
  invoice?: string;
/**
* Payment hash of invoice
*/
  payment_hash?: string;
}
/**
*/
export class LookupInvoiceResponseResult {
  free(): void;
/**
* Amount in millisatoshis
*/
  amount: bigint;
/**
* Creation timestamp in seconds since epoch
*/
  created_at: bigint;
/**
* Invoice's description
*/
  description?: string;
/**
* Invoice's description hash
*/
  description_hash?: string;
/**
* Expiration timestamp in seconds since epoch
*/
  expires_at: bigint;
/**
* Fees paid in millisatoshis
*/
  fees_paid: bigint;
/**
* Bolt11 invoice
*/
  invoice?: string;
/**
* Optional metadata about the payment
*/
  metadata: string;
/**
* Payment hash
*/
  payment_hash: string;
/**
* Payment preimage
*/
  preimage?: string;
/**
* Settled timestamp in seconds since epoch
*/
  settled_at?: bigint;
/**
* Transaction type
*/
  transaction_type?: TransactionType;
}
/**
* Make Invoice Request Params
*/
export class MakeInvoiceRequestParams {
  free(): void;
/**
* Amount in millisatoshis
*/
  amount: bigint;
/**
* Invoice description
*/
  description?: string;
/**
* Invoice description hash
*/
  description_hash?: string;
/**
* Invoice expiry in seconds
*/
  expiry?: bigint;
}
/**
*/
export class MakeInvoiceResponseResult {
  free(): void;
/**
* Bolt 11 invoice
*/
  invoice: string;
/**
* Invoice's payment hash
*/
  payment_hash: string;
}
/**
*/
export class Metadata {
  free(): void;
/**
*/
  constructor();
/**
* @param {string} json
* @returns {Metadata}
*/
  static fromJson(json: string): Metadata;
/**
* @returns {string}
*/
  asJson(): string;
/**
* @param {string} name
* @returns {Metadata}
*/
  name(name: string): Metadata;
/**
* @param {string} display_name
* @returns {Metadata}
*/
  displayName(display_name: string): Metadata;
/**
* @param {string} about
* @returns {Metadata}
*/
  about(about: string): Metadata;
/**
* @param {string} url
* @returns {Metadata}
*/
  website(url: string): Metadata;
/**
* @param {string} url
* @returns {Metadata}
*/
  picture(url: string): Metadata;
/**
* @param {string} url
* @returns {Metadata}
*/
  banner(url: string): Metadata;
/**
* @param {string} nip05
* @returns {Metadata}
*/
  nip05(nip05: string): Metadata;
/**
* @param {string} lud06
* @returns {Metadata}
*/
  lud06(lud06: string): Metadata;
/**
* @param {string} lud16
* @returns {Metadata}
*/
  lud16(lud16: string): Metadata;
}
/**
* Multi Pay Invoice Request Params
*/
export class MultiPayInvoiceRequestParams {
  free(): void;
/**
* Invoices to pay
*/
  invoices: (PayInvoiceRequestParams)[];
}
/**
* Multi Pay Keysend Request Params
*/
export class MultiPayKeysendRequestParams {
  free(): void;
/**
* Keysends
*/
  keysends: (PayKeysendRequestParams)[];
}
/**
* Things the user doesn't want to see in their feeds
*
* <https://github.com/nostr-protocol/nips/blob/master/51.md>
*/
export class MuteList {
  free(): void;
/**
*/
  event_ids: (EventId)[];
/**
*/
  hashtags: (string)[];
/**
*/
  public_keys: (PublicKey)[];
/**
*/
  words: (string)[];
}
/**
* NIP07 Signer for interaction with browser extensions (ex. Alby)
*
* <https://github.com/aljazceru/awesome-nostr#nip-07-browser-extensions>
*/
export class Nip07Signer {
  free(): void;
/**
*/
  constructor();
/**
* @returns {Promise<PublicKey>}
*/
  getPublicKey(): Promise<PublicKey>;
/**
* @param {UnsignedEvent} unsigned
* @returns {Promise<Event>}
*/
  signEvent(unsigned: UnsignedEvent): Promise<Event>;
/**
* @param {PublicKey} public_key
* @param {string} plaintext
* @returns {Promise<string>}
*/
  nip04Encrypt(public_key: PublicKey, plaintext: string): Promise<string>;
/**
* @param {PublicKey} public_key
* @param {string} ciphertext
* @returns {Promise<string>}
*/
  nip04Decrypt(public_key: PublicKey, ciphertext: string): Promise<string>;
/**
* @param {PublicKey} public_key
* @param {string} plaintext
* @returns {Promise<string>}
*/
  nip44Encrypt(public_key: PublicKey, plaintext: string): Promise<string>;
/**
* @param {PublicKey} public_key
* @param {string} ciphertext
* @returns {Promise<string>}
*/
  nip44Decrypt(public_key: PublicKey, ciphertext: string): Promise<string>;
}
/**
*/
export class Nip19Event {
  free(): void;
/**
* @param {EventId} event_id
* @param {PublicKey | undefined} author
* @param {(string)[]} relays
*/
  constructor(event_id: EventId, author: PublicKey | undefined, relays: (string)[]);
/**
* @param {string} bech32
* @returns {Nip19Event}
*/
  static fromBech32(bech32: string): Nip19Event;
/**
* @param {string} uri
* @returns {Nip19Event}
*/
  static fromNostrUri(uri: string): Nip19Event;
/**
* @returns {string}
*/
  toBech32(): string;
/**
* @returns {string}
*/
  toNostrUri(): string;
/**
* @returns {EventId}
*/
  eventId(): EventId;
/**
* @returns {PublicKey | undefined}
*/
  author(): PublicKey | undefined;
/**
* @returns {(string)[]}
*/
  relays(): (string)[];
}
/**
*/
export class Nip19Profile {
  free(): void;
/**
* New NIP19 profile
* @param {PublicKey} public_key
* @param {(string)[]} relays
*/
  constructor(public_key: PublicKey, relays: (string)[]);
/**
* @param {string} bech32
* @returns {Nip19Profile}
*/
  static fromBech32(bech32: string): Nip19Profile;
/**
* @param {string} uri
* @returns {Nip19Profile}
*/
  static fromNostrUri(uri: string): Nip19Profile;
/**
* @returns {string}
*/
  toBech32(): string;
/**
* @returns {string}
*/
  toNostrUri(): string;
/**
* @returns {PublicKey}
*/
  publicKey(): PublicKey;
/**
* @returns {(string)[]}
*/
  relays(): (string)[];
}
/**
*/
export class NostrConnectMetadata {
  free(): void;
/**
* New Nostr Connect Metadata
* @param {string} name
*/
  constructor(name: string);
/**
* URL of the website requesting the connection
* @param {string} url
* @returns {NostrConnectMetadata}
*/
  url(url: string): NostrConnectMetadata;
/**
* Description of the `App`
* @param {string} description
* @returns {NostrConnectMetadata}
*/
  description(description: string): NostrConnectMetadata;
/**
* List of URLs for icons of the `App`
* @param {(string)[]} icons
* @returns {NostrConnectMetadata}
*/
  icons(icons: (string)[]): NostrConnectMetadata;
/**
* Serialize as JSON string
* @returns {string}
*/
  as_json(): string;
}
/**
*/
export class NostrConnectURI {
  free(): void;
/**
* @param {string} uri
* @returns {NostrConnectURI}
*/
  static parse(uri: string): NostrConnectURI;
/**
* @returns {string}
*/
  asString(): string;
}
/**
*/
export class NostrLibrary {
  free(): void;
/**
*/
  constructor();
/**
* @returns {string | undefined}
*/
  gitHashVersion(): string | undefined;
}
/**
*/
export class NostrWalletConnectURI {
  free(): void;
/**
* Create new Nostr Wallet Connect URI
* @param {PublicKey} public_key
* @param {string} relay_url
* @param {SecretKey} random_secret_key
* @param {string | undefined} [lud16]
*/
  constructor(public_key: PublicKey, relay_url: string, random_secret_key: SecretKey, lud16?: string);
/**
* Parse
* @param {string} uri
* @returns {NostrWalletConnectURI}
*/
  static parse(uri: string): NostrWalletConnectURI;
/**
* App Pubkey
* @returns {PublicKey}
*/
  publicKey(): PublicKey;
/**
* URL of the relay of choice where the `App` is connected and the `Signer` must send and listen for messages.
* @returns {string}
*/
  relayUrl(): string;
/**
* 32-byte randomly generated hex encoded string
* @returns {SecretKey}
*/
  secret(): SecretKey;
/**
* A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured.
* @returns {string | undefined}
*/
  lud16(): string | undefined;
/**
* @returns {string}
*/
  asString(): string;
}
/**
* Pay Invoice Request Params
*/
export class PayInvoiceRequestParams {
  free(): void;
/**
* Optional amount in millisatoshis
*/
  amount?: bigint;
/**
* Optional id
*/
  id?: string;
/**
* Request invoice
*/
  invoice: string;
}
/**
*/
export class PayInvoiceResponseResult {
  free(): void;
/**
* Response preimage
*/
  preimage: string;
}
/**
* Pay Invoice Request Params
*/
export class PayKeysendRequestParams {
  free(): void;
/**
* Amount in millisatoshis
*/
  amount: bigint;
/**
* Optional id
*/
  id?: string;
/**
* Optional preimage
*/
  preimage?: string;
/**
* Receiver's node id
*/
  pubkey: string;
/**
* Optional TLVs to be added to the keysend payment
*/
  tlv_records: (KeysendTLVRecord)[];
}
/**
*/
export class PayKeysendResponseResult {
  free(): void;
/**
* Response preimage
*/
  preimage: string;
}
/**
*/
export class ProductData {
  free(): void;
/**
* @param {string} id
* @param {string} stall_id
* @param {string} name
* @param {string} currency
*/
  constructor(id: string, stall_id: string, name: string, currency: string);
/**
*/
  readonly categories: (string)[] | undefined;
/**
*/
  readonly currency: string;
/**
*/
  readonly description: string | undefined;
/**
*/
  readonly id: string;
/**
*/
  readonly images: (string)[] | undefined;
/**
*/
  readonly name: string;
/**
*/
  readonly price: number;
/**
*/
  readonly quantity: number;
/**
*/
  readonly shipping: (ShippingCost)[];
/**
*/
  readonly specs: (string[])[] | undefined;
/**
*/
  readonly stallId: string;
}
/**
*/
export class PublicKey {
  free(): void;
/**
* Try to parse public key from `hex`, `bech32` or [NIP21](https://github.com/nostr-protocol/nips/blob/master/21.md) uri
* @param {string} public_key
* @returns {PublicKey}
*/
  static parse(public_key: string): PublicKey;
/**
* @param {string} hex
* @returns {PublicKey}
*/
  static fromHex(hex: string): PublicKey;
/**
* @param {string} bech32
* @returns {PublicKey}
*/
  static fromBech32(bech32: string): PublicKey;
/**
* Get in hex format
* @returns {string}
*/
  toHex(): string;
/**
* Get in bech32 format
* @returns {string}
*/
  toBech32(): string;
}
/**
*/
export class RelayInformationDocument {
  free(): void;
/**
*/
  constructor();
/**
* @param {string} url
* @returns {Promise<RelayInformationDocument>}
*/
  static get(url: string): Promise<RelayInformationDocument>;
/**
*/
  readonly contact: string | undefined;
/**
*/
  readonly description: string | undefined;
/**
*/
  readonly name: string | undefined;
/**
*/
  readonly pubkey: string | undefined;
/**
*/
  readonly software: string | undefined;
/**
*/
  readonly supported_nips: Uint16Array | undefined;
/**
*/
  readonly version: string | undefined;
}
/**
*/
export class RelayListItem {
  free(): void;
/**
* @param {string} url
* @param {RelayMetadata | undefined} [metadata]
*/
  constructor(url: string, metadata?: RelayMetadata);
/**
*/
  metadata?: RelayMetadata;
/**
*/
  url: string;
}
/**
*/
export class RelayMessage {
  free(): void;
/**
* Create new `EVENT` message
* @param {string} subscription_id
* @param {Event} event
* @returns {RelayMessage}
*/
  static event(subscription_id: string, event: Event): RelayMessage;
/**
* Create new `NOTICE` message
* @param {string} message
* @returns {RelayMessage}
*/
  static notice(message: string): RelayMessage;
/**
* Create new `CLOSED` message
* @param {string} subscription_id
* @param {string} message
* @returns {RelayMessage}
*/
  static closed(subscription_id: string, message: string): RelayMessage;
/**
* Create new `EOSE` message
* @param {string} subscription_id
* @returns {RelayMessage}
*/
  static eose(subscription_id: string): RelayMessage;
/**
* Create new `OK` message
* @param {EventId} event_id
* @param {boolean} status
* @param {string} message
* @returns {RelayMessage}
*/
  static ok(event_id: EventId, status: boolean, message: string): RelayMessage;
/**
* Create new `AUTH` message
* @param {string} challenge
* @returns {RelayMessage}
*/
  static auth(challenge: string): RelayMessage;
/**
* Create new `EVENT` message
* @param {string} subscription_id
* @param {number} count
* @returns {RelayMessage}
*/
  static count(subscription_id: string, count: number): RelayMessage;
/**
* Deserialize `RelayMessage` from JSON string
*
* **This method NOT verify the event signature!**
* @param {string} json
* @returns {RelayMessage}
*/
  static fromJson(json: string): RelayMessage;
/**
* @returns {string}
*/
  asJson(): string;
}
/**
*/
export class SecretKey {
  free(): void;
/**
* Try to parse secret key from `hex` or `bech32`
* @param {string} secret_key
* @returns {SecretKey}
*/
  static parse(secret_key: string): SecretKey;
/**
* @param {string} hex
* @returns {SecretKey}
*/
  static fromHex(hex: string): SecretKey;
/**
* @param {string} bech32
* @returns {SecretKey}
*/
  static fromBech32(bech32: string): SecretKey;
/**
* @returns {string}
*/
  toHex(): string;
/**
* @returns {string}
*/
  toBech32(): string;
/**
* Encrypt secret key
*
* By default `LOG_N` is set to `16` and `KeySecurity` to `Unknown`.
* To use custom values check `EncryptedSecretKey` constructor.
* @param {string} password
* @returns {EncryptedSecretKey}
*/
  encrypt(password: string): EncryptedSecretKey;
}
/**
*/
export class ShippingCost {
  free(): void;
/**
*/
  readonly cost: number;
/**
*/
  readonly id: string;
}
/**
*/
export class ShippingMethod {
  free(): void;
/**
* @param {string} id
* @param {number} cost
*/
  constructor(id: string, cost: number);
/**
* @returns {ShippingCost}
*/
  getShippingCost(): ShippingCost;
/**
*/
  readonly cost: number;
/**
*/
  readonly id: string;
/**
*/
  readonly name: string | undefined;
/**
*/
  readonly regions: (string)[];
}
/**
*/
export class SingleLetterTag {
  free(): void;
/**
* @param {Alphabet} character
* @returns {SingleLetterTag}
*/
  static lowercase(character: Alphabet): SingleLetterTag;
/**
* @param {Alphabet} character
* @returns {SingleLetterTag}
*/
  static uppercase(character: Alphabet): SingleLetterTag;
/**
* @returns {boolean}
*/
  isLowercase(): boolean;
/**
* @returns {boolean}
*/
  isUppercase(): boolean;
}
/**
*/
export class StallData {
  free(): void;
/**
* @param {string} id
* @param {string} name
* @param {string} currency
*/
  constructor(id: string, name: string, currency: string);
/**
*/
  readonly currency: string;
/**
*/
  readonly description: string | undefined;
/**
*/
  readonly id: string;
/**
*/
  readonly name: string;
/**
*/
  readonly shipping: (ShippingMethod)[];
}
/**
*/
export class SubscriptionId {
  free(): void;
/**
* @param {string} id
*/
  constructor(id: string);
/**
* Generate new random [`SubscriptionId`]
* @returns {SubscriptionId}
*/
  static generate(): SubscriptionId;
/**
* @returns {string}
*/
  get(): string;
}
/**
*/
export class Tag {
  free(): void;
/**
* @param {(string)[]} tag
* @returns {Tag}
*/
  static parse(tag: (string)[]): Tag;
/**
* Compose `["e", "<event-id>"]` tag
* @param {EventId} event_id
* @returns {Tag}
*/
  static event(event_id: EventId): Tag;
/**
* Compose `["p", "<public-key>"]` tag
* @param {PublicKey} public_key
* @returns {Tag}
*/
  static public_key(public_key: PublicKey): Tag;
/**
* Check if `Tag` is an event `reply`
* @returns {boolean}
*/
  is_reply(): boolean;
/**
* @returns {string}
*/
  kind(): string;
/**
* Get tag as vector of string
*
* Internally clone tag and convert it to `Vec<String>`. To avoid tag clone, use `toVec()`.
* @returns {(string)[]}
*/
  asVec(): (string)[];
/**
* Consume the tag and return vector of string
* @returns {(string)[]}
*/
  toVec(): (string)[];
}
/**
*/
export class Thumbnails {
  free(): void;
/**
* @param {string} url
* @param {ImageDimensions | undefined} [dimensions]
*/
  constructor(url: string, dimensions?: ImageDimensions);
/**
*/
  dimensions?: ImageDimensions;
/**
*/
  url: string;
}
/**
*/
export class Timestamp {
  free(): void;
/**
* Get UNIX timestamp (seconds)
* @returns {Timestamp}
*/
  static now(): Timestamp;
/**
* @param {number} secs
* @returns {Timestamp}
*/
  static fromSecs(secs: number): Timestamp;
/**
* Get timestamp as seconds
* @returns {number}
*/
  asSecs(): number;
/**
* Convert `Timestamp` to human datetime
* @returns {string}
*/
  toHumanDatetime(): string;
}
/**
*/
export class UnsignedEvent {
  free(): void;
/**
* @param {string} json
* @returns {UnsignedEvent}
*/
  static fromJson(json: string): UnsignedEvent;
/**
* @returns {string}
*/
  asJson(): string;
/**
* Sign an unsigned event
*
* Internally: calculate event ID (if not set), sign it, compose and verify event.
* @param {Keys} keys
* @returns {Event}
*/
  sign(keys: Keys): Event;
/**
* Add signature to unsigned event
*
* Internally verify the event.
* @param {string} sig
* @returns {Event}
*/
  addSignature(sig: string): Event;
/**
*/
  readonly content: string;
/**
*/
  readonly createdAt: Timestamp;
/**
*/
  readonly id: EventId | undefined;
/**
*/
  readonly kind: number;
/**
*/
  readonly pubkey: PublicKey;
/**
*/
  readonly tags: (Tag)[];
}
/**
* Unwrapped Gift Wrap
*
* <https://github.com/nostr-protocol/nips/blob/master/59.md>
*/
export class UnwrappedGift {
  free(): void;
/**
* Unwrap Gift Wrap event
*
* Internally verify the `seal` event
* @param {Keys} receiver_keys
* @param {Event} gift_wrap
* @returns {UnwrappedGift}
*/
  static fromGiftWrap(receiver_keys: Keys, gift_wrap: Event): UnwrappedGift;
/**
* Get rumor
*/
  readonly rumor: UnsignedEvent;
/**
* Get sender public key
*/
  readonly sender: PublicKey;
}
/**
*/
export class User {
  free(): void;
/**
* @param {PublicKey} public_key
* @param {string | undefined} [url]
*/
  constructor(public_key: PublicKey, url?: string);
/**
*/
  publicKey: PublicKey;
/**
*/
  url?: string;
}
/**
*/
export class ZapRequestData {
  free(): void;
/**
* @param {PublicKey} public_key
* @param {(string)[]} relays
* @param {string} message
* @param {number | undefined} [amount]
* @param {string | undefined} [lnurl]
* @param {EventId | undefined} [event_id]
* @param {Coordinate | undefined} [event_coordinate]
*/
  constructor(public_key: PublicKey, relays: (string)[], message: string, amount?: number, lnurl?: string, event_id?: EventId, event_coordinate?: Coordinate);
/**
*/
  readonly amount: number | undefined;
/**
*/
  readonly eventCoordinate: Coordinate | undefined;
/**
*/
  readonly eventID: EventId | undefined;
/**
*/
  readonly lnurl: string | undefined;
/**
*/
  readonly message: string;
/**
*/
  readonly publicKey: PublicKey;
/**
*/
  readonly relays: (string)[];
}
/**
 * Load the WebAssembly module in the background, if it has not already been loaded.
 *
 * Returns a promise which will resolve once the other methods are ready.
 *
 * @returns {Promise<void>}
 */
 export function loadWasmAsync(): Promise<void>;

 export function loadWasmSync(): void;